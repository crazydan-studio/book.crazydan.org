[#chp_7]
== Chapter 7. Operations on Objects

This chapter describes operations specific to _Chez Scheme_ on nonnumeric objects, including standard objects such as pairs and numbers and _Chez Scheme_ extensions such as boxes and records. <<chp_8,Chapter 8>> describes operations on numbers. See link:../../the-scheme-programming-language-4th/en/index.html#chp_6[Chapter 6] of _The Scheme Programming Language, 4th Edition_ or the Revised^6^ Report on Scheme for a description of standard operations on objects.

=== Section 7.1. Missing R6RS Type Predicates [[section_7.1.]]

[#objects:s0]
[horizontal]
procedure:: `(enum-set? _obj_)`
returns:: `#t` if `_obj_` is an enum set, `#f` otherwise
libraries:: `(chezscheme)`

This predicate is not defined by the Revised^6^ Report, but should be.

[#objects:s1]
[horizontal]
procedure:: `(record-constructor-descriptor? _obj_)`
returns:: `#t` if `_obj_` is a record constructor descriptor, `#f` otherwise
libraries:: `(chezscheme)`

This predicate is not defined by the Revised^6^ Report, but should be.

=== Section 7.2. Pairs and Lists [[section_7.2.]]

[#objects:s2]
[horizontal]
procedure:: `(atom? _obj_)`
returns:: `#t` if `_obj_` is not a pair, `#f` otherwise
libraries:: `(chezscheme)`

`atom?` is equivalent to `(lambda (x) (not (pair? x)))`.

[source,scheme,subs="quotes"]
----
(atom? '(a b c)) ⇒ #f
(atom? '(3 . 4)) ⇒ #f
(atom? '()) ⇒ #t
(atom? 3) ⇒ #t
----

[#objects:s3]
[horizontal]
procedure:: `(list-head _list_ _n_)`
returns:: a list of the first `_n_` elements of `_list_`
libraries:: `(chezscheme)`

`_n_` must be an exact nonnegative integer less than or equal to the length of `_list_`.

`list-head` and the standard Scheme procedure `list-tail` may be used together to split a list into two separate lists. While `list-tail` performs no allocation but instead returns a sublist of the original list, `list-head` always returns a copy of the first portion of the list.

`list-head` may be defined as follows.

[source,scheme,subs="quotes"]
----
(define list-head
  (lambda (ls n)
    (if (= n 0)
        '()
        (cons (car ls) (list-head (cdr ls) (- n 1))))))

(list-head '(a b c) 0) ⇒ ()
(list-head '(a b c) 2) ⇒ (a b)
(list-head '(a b c) 3) ⇒ (a b c)
(list-head '(a b c . d) 2) ⇒ (a b)
(list-head '(a b c . d) 3) ⇒ (a b c)
(list-head '\#1=(a . #1#) 5) ⇒ (a a a a a)
----

[#objects:s4]
[horizontal]
procedure:: `(last-pair _list_)`
returns:: the last pair of a `_list_`
libraries:: `(chezscheme)`

`_list_` must not be empty. `last-pair` returns the last pair (not the last element) of `_list_`. `_list_` may be an improper list, in which case the last pair is the pair containing the last element and the terminating object.

[source,scheme,subs="quotes"]
----
(last-pair '(a b c d)) ⇒ (d)
(last-pair '(a b c . d)) ⇒ (c . d)
----

[#objects:s5]
[horizontal]
procedure:: `(list-copy _list_)`
returns:: a copy of `_list_`
libraries:: `(chezscheme)`

`list-copy` returns a list `equal?` to `_list_`, using new pairs to reform the top-level list structure.

[source,scheme,subs="quotes"]
----
(list-copy '(a b c)) ⇒ (a b c)

(let ([ls '(a b c)])
  (equal? ls (list-copy ls))) ⇒ #t

(let ([ls '(a b c)])
  (let ([ls-copy (list-copy ls)])
    (or (eq? ls-copy ls)
        (eq? (cdr ls-copy) (cdr ls))
        (eq? (cddr ls-copy) (cddr ls))))) ⇒ #f
----

[#objects:s6]
[horizontal]
procedure:: `(list* _obj_ \... _final-obj_)`
returns:: a list of `_obj_ \...` terminated by `_final-obj_`
libraries:: `(chezscheme)`

`list*` is identical to the Revised^6^ Report `cons*`.

[#objects:s7]
[horizontal]
procedure:: `(make-list _n_)`
procedure:: `(make-list _n_ _obj_)`
returns:: a list of `_n_` `_objs_`
libraries:: `(chezscheme)`

`_n_` must be a nonnegative integer. If `_obj_` is omitted, the elements of the list are unspecified.

[source,scheme,subs="quotes"]
----
(make-list 0 '()) ⇒ ()
(make-list 3 0) ⇒ (0 0 0)
(make-list 2 "hi") ⇒ ("hi" "hi")
----

[#objects:s8]
[horizontal]
procedure:: `(iota _n_)`
returns:: a list of integers from 0 (inclusive) to `_n_` (exclusive)
libraries:: `(chezscheme)`

`_n_` must be an exact nonnegative integer.

[source,scheme,subs="quotes"]
----
(iota 0) ⇒ ()
(iota 5) ⇒ (0 1 2 3 4)
----

[#objects:s9]
[horizontal]
procedure:: `(enumerate _ls_)`
returns:: a list of integers from 0 (inclusive) to the length of `_ls_` (exclusive)
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(enumerate '()) ⇒ ()
(enumerate '(a b c)) ⇒ (0 1 2)
(let ([ls '(a b c)])
  (map cons ls (enumerate ls))) ⇒ ((a . 0) (b . 1) (c . 2))
----

[#objects:s10]
[horizontal]
procedure:: `(remq! _obj_ _list_)`
procedure:: `(remv! _obj_ _list_)`
procedure:: `(remove! _obj_ _list_)`
returns:: a list containing the elements of `_list_` with all occurrences of `_obj_` removed
libraries:: `(chezscheme)`

These procedures are similar to the Revised^6^ Report `remq`, `remv`, and `remove` procedures, except `remq!`, `remv!` and `remove!` use pairs from the input list to build the output list. They perform less allocation but are not necessarily faster than their nondestructive counterparts. Their use can easily lead to confusing or incorrect results if used indiscriminately.

[source,scheme,subs="quotes"]
----
(remq! 'a '(a b a c a d)) ⇒ (b c d)

(remv! \#\a '(#\a \#\b #\c)) ⇒ (#\b #\c)

(remove! '(c) '((a) (b) (c))) ⇒ ((a) (b))
----

[#objects:s11]
[horizontal]
procedure:: `(substq _new_ _old_ _tree_)`
procedure:: `(substv _new_ _old_ _tree_)`
procedure:: `(subst _new_ _old_ _tree_)`
procedure:: `(substq! _new_ _old_ _tree_)`
procedure:: `(substv! _new_ _old_ _tree_)`
procedure:: `(subst! _new_ _old_ _tree_)`
returns:: a tree with `_new_` substituted for occurrences of `_old_` in `_tree_`
libraries:: `(chezscheme)`

These procedures traverse `_tree_`, replacing all objects equivalent to the object `_old_` with the object `_new_`.

The equivalence test for `substq` and `substq!` is `eq?`, for `substv` and `substv!` is `eqv?`, and for `subst` and `subst!` is `equal?`.

`substq!`, `substv!`, and `subst!` perform the substitutions destructively. They perform less allocation but are not necessarily faster than their nondestructive counterparts. Their use can easily lead to confusing or incorrect results if used indiscriminately.

[source,scheme,subs="quotes"]
----
(substq 'a 'b '((b c) b a)) ⇒ ((a c) a a)

(substv 2 1 '((1 . 2) (1 . 4) . 1)) ⇒ ((2 . 2) (2 . 4) . 2)

(subst 'a
       '(a . b)
       '((a . b) (c a . b) . c)) ⇒ (a (c . a) . c)

(let ([tr '((b c) b a)])
  (substq! 'a 'b tr)
  tr) ⇒ ((a c) a a)
----

[#objects:s12]
[horizontal]
procedure:: `(reverse! _list_)`
returns:: a list containing the elements of `_list_` in reverse order
libraries:: `(chezscheme)`

`reverse!` destructively reverses `_list_` by reversing its links. Using `reverse!` in place of `reverse` reduces allocation but is not necessarily faster than `reverse`. Its use can easily lead to confusing or incorrect results if used indiscriminately.

[source,scheme,subs="quotes"]
----
(reverse! '()) ⇒ ()
(reverse! '(a b c)) ⇒ (c b a)

(let ([x '(a b c)])
    (reverse! x)
    x) ⇒ (a)

(let ([x '(a b c)])
    (set! x (reverse! x))
    x) ⇒ (c b a)
----

[#objects:s13]
[horizontal]
procedure:: `(append! _list_ \...)`
returns:: the concatenation of the input lists
libraries:: `(chezscheme)`

Like `append`, `append!` returns a new list consisting of the elements of the first list followed by the elements of the second list, the elements of the third list, and so on. Unlike `append`, `append!` reuses the pairs in all of the arguments in forming the new list. That is, the last cdr of each list argument but the last is changed to point to the next list argument. If any argument but the last is the empty list, it is essentially ignored. The final argument (which need not be a list) is not altered.

`append!` performs less allocation than `append` but is not necessarily faster. Its use can easily lead to confusing or incorrect results if used indiscriminately.

[source,scheme,subs="quotes"]
----
(append! '(a b) '(c d)) ⇒ (a b c d)

(let ([x '(a b)])
    (append! x '(c d))
    x) ⇒ (a b c d)
----

=== Section 7.3. Characters [[section_7.3.]]

_Chez Scheme_ extends the syntax of characters in two ways. First, a `\#\` prefix followed by exactly three octal digits is read as a character whose numeric code is the octal value of the three digits, e.g., `#\044` is read as `\#\$`. Second, it recognizes several nonstandard named characters: `#\rubout` (which is the same as `\#\delete`), `#\bel` (which is the same as `\#\alarm`), `#\vt` (which is the same as `\#\vtab`), `#\nel` (the Unicode NEL character), and `#\ls` (the Unicode LS character). The set of nonstandard character names may be changed via the procedure `char-name` (<<section_9.14.,Section 9.14>>).

These extensions are disabled in an input stream after `\#!r6rs` has been seen by the reader, unless `#!chezscheme` has been seen more recently.

[#objects:s15]
[horizontal]
procedure:: `(char=? _char~1~_ _char~2~_ \...)`
procedure:: `(char<? _char~1~_ _char~2~_ \...)`
procedure:: `(char>? _char~1~_ _char~2~_ \...)`
procedure:: `(char\<=? _char~1~_ _char~2~_ \...)`
procedure:: `(char>=? _char~1~_ _char~2~_ \...)`
procedure:: `(char-ci=? _char~1~_ _char~2~_ \...)`
procedure:: `(char-ci<? _char~1~_ _char~2~_ \...)`
procedure:: `(char-ci>? _char~1~_ _char~2~_ \...)`
procedure:: `(char-ci\<=? _char~1~_ _char~2~_ \...)`
procedure:: `(char-ci>=? _char~1~_ _char~2~_ \...)`
returns:: `#t` if the relation holds, `#f` otherwise
libraries:: `(chezscheme)`

These predicates are identical to the Revised^6^ Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns `#t`.

[source,scheme,subs="quotes"]
----
(char>? #\a) ⇒ #t
(char&lt;? #\a) ⇒ #t
(char-ci=? #\a) ⇒ #t
----

[#objects:s16]
[horizontal]
procedure:: `(char- _char~1~_ _char~2~_)`
returns:: the integer difference between `_char~1~_` and `_char~2~_`
libraries:: `(chezscheme)`

`char-` subtracts the integer value of `_char~2~_` from the integer value of `_char~1~_` and returns the difference. The following examples assume that the integer representation is the ASCII code for the character.

[source,scheme,subs="quotes"]
----
(char- #\f #\e) ⇒ 1

(define digit-value
 ; returns the digit value of the base-r digit c, or #f if c
 ; is not a valid digit
  (lambda (c r)
    (let ([v (cond
               [(char<=? #\0 c #\9) (char- c #\0)]
               [(char<=? #\A c #\Z) (char- c #\7)]
               [(char<=? #\a c #\z) (char- c #\W)]
               [else 36])])
      (and (fx< v r) v))))
(digit-value #\8 10) ⇒ 8
(digit-value #\z 10) ⇒ #f
(digit-value #\z 36) ⇒ 35
----

`char-` might be defined as follows.

[source,scheme,subs="quotes"]
----
(define char-
  (lambda (c1 c2)
    (- (char->integer c1) (char->integer c2))))
----

=== Section 7.4. Strings [[section_7.4.]]

_Chez Scheme_ extends the standard string syntax with two character escapes: `\'`, which produces the single quote character, and `++\++_nnn_`, i.e., backslash followed by 3 octal digits, which produces the character equivalent of the octal value of the 3 digits. These extensions are disabled in an input stream after `\#!r6rs` has been seen by the reader, unless `#!chezscheme` has been seen more recently.

[#objects:s18]
All strings are mutable by default, including constants. A program can create immutable strings via `string\->immutable-string`. Any attempt to modify an immutable string causes an exception to be raised.

The length and indices of a string in _Chez Scheme_ are always fixnums.

[#objects:s20]
[horizontal]
procedure:: `(string=? _string~1~_ _string~2~_ _string~3~_ \...)`
procedure:: `(string<? _string~1~_ _string~2~_ _string~3~_ \...)`
procedure:: `(string>? _string~1~_ _string~2~_ _string~3~_ \...)`
procedure:: `(string\<=? _string~1~_ _string~2~_ _string~3~_ \...)`
procedure:: `(string>=? _string~1~_ _string~2~_ _string~3~_ \...)`
procedure:: `(string-ci=? _string~1~_ _string~2~_ _string~3~_ \...)`
procedure:: `(string-ci<? _string~1~_ _string~2~_ _string~3~_ \...)`
procedure:: `(string-ci>? _string~1~_ _string~2~_ _string~3~_ \...)`
procedure:: `(string-ci\<=? _string~1~_ _string~2~_ _string~3~_ \...)`
procedure:: `(string-ci>=? _string~1~_ _string~2~_ _string~3~_ \...)`
returns:: `#t` if the relation holds, `#f` otherwise
libraries:: `(chezscheme)`

These predicates are identical to the Revised^6^ Report counterparts, except they are extended to accept one or more rather than two or more arguments. When passed one argument, each of these predicates returns `#t`.

[source,scheme,subs="quotes"]
----
(string>? "a") ⇒ #t
(string&lt;? "a") ⇒ #t
(string-ci=? "a") ⇒ #t
----

[#objects:s21]
[horizontal]
procedure:: `(string-copy! _src_ _src-start_ _dst_ _dst-start_ _n_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_src_` and `_dst_` must be strings, and `_dst_` must be mutable. `_src-start_`, `_dst-start_`, and `_n_` must be exact nonnegative integers. The sum of `_src-start_` and `_n_` must not exceed the length of `_src_`, and the sum of `_dst-start_` and `_n_` must not exceed the length of `_dst_`.

`string-copy!` overwrites the `_n_` bytes of `_dst_` starting at `_dst-start_` with the `_n_` bytes of `_dst_` starting at `_src-start_`. This works even if `_dst_` is the same string as `_src_` and the source and destination locations overlap. That is, the destination is filled with the characters that appeared at the source before the operation began.

[source,scheme,subs="quotes"]
----
(define s1 "to boldly go")
(define s2 (make-string 10 #\-))

(string-copy! s1 3 s2 1 3)
s2 ⇒ "-bol------"

(string-copy! s1 7 s2 4 2)
s2 ⇒ "-bolly----"

(string-copy! s2 2 s2 5 4)
s2 ⇒ "-bollolly-"
----

[#objects:s22]
[horizontal]
procedure:: `(substring-fill! _string_ _start_ _end_ _char_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_string_` must be mutable. The characters of `_string_` from `_start_` (inclusive) to `_end_` (exclusive) are set to `_char_`. `_start_` and `_end_` must be nonnegative integers; `_start_` must be strictly less than the length of `_string_`, while `_end_` may be less than or equal to the length of `_string_`. If _end_ ≤ _start_, the string is left unchanged.

[source,scheme,subs="quotes"]
----
(let ([str (string-copy "a tpyo typo")])
  (substring-fill! str 2 6 #\X)
  str) ⇒ "a XXXX typo"
----

[#objects:s23]
[horizontal]
procedure:: `(string-truncate! _string_ _n_)`
returns:: `_string_` or the empty string
libraries:: `(chezscheme)`

`_string_` must be mutable. `_n_` must be an exact nonnegative fixnum not greater than the length of `_string_`. If `_n_` is zero, `string-truncate!` returns the empty string. Otherwise, `_string-truncate!_` destructively truncates `_string_` to its first `_n_` characters and returns `_string_`.

[source,scheme,subs="quotes"]
----
(define s (make-string 7 #\$))
(string-truncate! s 0) ⇒ ""
s ⇒ "$$$$$$$"
(string-truncate! s 3) ⇒ "$$$"
s ⇒ "$$$"
----

[#objects:s24]
[horizontal]
procedure:: `(mutable-string? _obj_)`
returns:: `#t` if `_obj_` is a mutable string, `#f` otherwise
procedure:: `(immutable-string? _obj_)`
returns:: `#t` if `_obj_` is an immutable string, `#f` otherwise
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(mutable-string? (string #\a #\b #\c)) ⇒ #t
(mutable-string? (string->immutable-string "abc")) ⇒ #f
(immutable-string? (string #\a #\b #\c)) ⇒ #f
(immutable-string? (string->immutable-string "abc")) ⇒ #t
(immutable-string? (cons 3 4)) ⇒ #f
----

[#objects:s25]
[horizontal]
procedure:: `(string\->immutable-string _string_)`
returns:: an immutable string equal to `_string_`
libraries:: `(chezscheme)`

[#objects:s26]
[#objects:s27]
The result is `_string_` itself if `_string_` is immutable; otherwise, the result is an immutable string with the same content as `_string_`.

[source,scheme,subs="quotes"]
----
(define s (string->immutable-string (string #\x #\y #\z)))
(string-set! s 0 #\a) ⇒ _exception: not mutable_
----

=== Section 7.5. Vectors [[section_7.5.]]

_Chez Scheme_ extends the syntax of vectors to allow the length of the vector to be specified between the `\#` and open parenthesis, e.g., `#3(a b c)`. If fewer elements are supplied in the syntax than the specified length, each element after the last printed element is the same as the last printed element. This extension is disabled in an input stream after `#!r6rs` has been seen by the reader, unless `#!chezscheme` has been seen more recently.

The length and indices of a vector in _Chez Scheme_ are always fixnums.

[#objects:s29]
All vectors are mutable by default, including constants. A program can create immutable vectors via `vector\->immutable-vector`. Any attempt to modify an immutable vector causes an exception to be raised.

[#objects:s31]
[horizontal]
procedure:: `(vector-copy _vector_)`
returns:: a copy of `_vector_`
libraries:: `(chezscheme)`

`vector-copy` creates a new vector of the same length and contents as `_vector_`. The elements themselves are not copied.

[source,scheme,subs="quotes"]
----
(vector-copy '\#(a b c)) ⇒ #(a b c)

(let ([v '#(a b c)])
  (eq? v (vector-copy v))) ⇒ #f
----

[#objects:s32]
[horizontal]
procedure:: `(vector-set-fixnum! _vector_ _n_ _fixnum_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_vector_` must be mutable. `vector-set-fixnum!` changes the ``_n_``th element of `_vector_` to `_fixnum_`. `_n_` must be an exact nonnegative integer strictly less than the length of `_vector_`.

It is faster to store a fixnum than an arbitrary value, since for arbitrary values, the system has to record potential assignments from older to younger objects to support generational garbage collection. Care must be taken to ensure that the argument is indeed a fixnum, however; otherwise, the collector may not properly track the assignment. The primitive performs a fixnum check on the argument except at optimization level 3.

See also the description of fixnum-only vectors (fxvectors) below.

[source,scheme,subs="quotes"]
----
(let ([v (vector 1 2 3 4 5)])
  (vector-set-fixnum! v 2 73)
  v) ⇒ #(1 2 73 4 5)
----

[#objects:s33]
[horizontal]
procedure:: `(vector-cas! _vector_ _n_ _old-obj_ _new-obj_)`
returns:: `#t` if `_vector_` is changed, `#f` otherwise
libraries:: `(chezscheme)`

`_vector_` must be mutable. `vector-cas!` atomically changes the ``_n_``th element of `_vector_` to `_new-obj_` if the replaced ``_n_``th element is `eq?` to `_old-obj_`. If the ``_n_``th element of `_vector_` that would be replaced is not `eq?` to `_old-obj_`, then `_vector_` is unchanged.

[source,scheme,subs="quotes"]
----
(define v (vector 'old0 'old1 'old2))
(vector-cas! v 1 'old1 'new1) ⇒ #t
(vector-ref v 1) ⇒ 'new1
(vector-cas! v 2 'old1 'new2) ⇒ #f
(vector-ref v 2) ⇒ 'old2
----

[#objects:s34]
[horizontal]
procedure:: `(mutable-vector? _obj_)`
returns:: `#t` if `_obj_` is a mutable vector, `#f` otherwise
procedure:: `(immutable-vector? _obj_)`
returns:: `#t` if `_obj_` is an immutable vector, `#f` otherwise
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(mutable-vector? (vector 1 2 3)) ⇒ #t
(mutable-vector? (vector->immutable-vector (vector 1 2 3))) ⇒ #f
(immutable-vector? (vector 1 2 3)) ⇒ #f
(immutable-vector? (vector->immutable-vector (vector 1 2 3))) ⇒ #t
(immutable-vector? (cons 3 4)) ⇒ #f
----

[#objects:s35]
[horizontal]
procedure:: `(vector\->immutable-vector _vector_)`
returns:: an immutable vector equal to `_vector_`
libraries:: `(chezscheme)`

[#objects:s36]
[#objects:s37]
The result is `_vector_` itself if `_vector_` is immutable; otherwise, the result is an immutable vector with the same content as `_vector_`.

[source,scheme,subs="quotes"]
----
(define v (vector->immutable-vector (vector 1 2 3)))
(vector-set! v 0 0) ⇒ _exception: not mutable_
----

=== Section 7.6. Fixnum-Only Vectors [[section_7.6.]]

Fixnum-only vectors, or "fxvectors," are like vectors but contain only fixnums. Fxvectors are written with the `\#vfx` prefix in place of the `#` prefix for vectors, e.g., `\#vfx(1 2 3)` or `#10vfx(2)`. The fxvector syntax is disabled in an input stream after `#!r6rs` has been seen by the reader, unless `#!chezscheme` has been seen more recently.

The length and indices of an fxvector are always fixnums.

Updating an fxvector is generally less expensive than updating a vector, since for vectors, the system records potential assignments from older to younger objects to support generational garbage collection. The storage management system also takes advantage of the fact that fxvectors contain no pointers to place them in an area of memory that does not have to be traced during collection.

[#objects:s40]
All fxvectors are mutable by default, including constants. A program can create immutable fxvectors via `fxvector\->immutable-fxvector`. Any attempt to modify an immutable fxvector causes an exception to be raised.

See also `vector-set-fixnum!` above.

[#objects:s42]
[horizontal]
procedure:: `(fxvector? _obj_)`
returns:: `#t` if `_obj_` is an fxvector, `#f` otherwise
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(fxvector? \#vfx()) ⇒ #t
(fxvector? #vfx(1 2 3)) ⇒ #t
(fxvector? (fxvector 1 2 3)) ⇒ #t
(fxvector? '#(a b c)) ⇒ #f
(fxvector? '(a b c)) ⇒ #f
(fxvector? "abc") ⇒ #f
----

[#objects:s43]
[horizontal]
procedure:: `(fxvector _fixnum_ \...)`
returns:: an fxvector of the fixnums `_fixnum_ \...`
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(fxvector) ⇒ #vfx()
(fxvector 1 3 5) ⇒ #vfx(1 3 5)
----

[#objects:s44]
[horizontal]
procedure:: `(make-fxvector _n_)`
procedure:: `(make-fxvector _n_ _fixnum_)`
returns:: an fxvector of length `_n_`
libraries:: `(chezscheme)`

`_n_` must be a fixnum. If `_fixnum_` is supplied, each element of the fxvector is initialized to `_fixnum_`; otherwise, the elements are unspecified.

[source,scheme,subs="quotes"]
----
(make-fxvector 0) ⇒ #vfx()
(make-fxvector 0 7) ⇒ #vfx()
(make-fxvector 5 7) ⇒ #vfx(7 7 7 7 7)
----

[#objects:s45]
[horizontal]
procedure:: `(fxvector-length _fxvector_)`
returns:: the number of elements in `_fxvector_`
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(fxvector-length #vfx()) ⇒ 0
(fxvector-length #vfx(1 2 3)) ⇒ 3
(fxvector-length #10vfx(1 2 3)) ⇒ 10
(fxvector-length (fxvector 1 2 3 4)) ⇒ 4
(fxvector-length (make-fxvector 300)) ⇒ 300
----

[#objects:s46]
[horizontal]
procedure:: `(fxvector-ref _fxvector_ _n_)`
returns:: the ``_n_``th element (zero-based) of `_fxvector_`
libraries:: `(chezscheme)`

`_n_` must be a nonnegative fixnum strictly less than the length of `_fxvector_`.

[source,scheme,subs="quotes"]
----
(fxvector-ref #vfx(-1 2 4 7) 0) ⇒ -1
(fxvector-ref #vfx(-1 2 4 7) 1) ⇒ 2
(fxvector-ref #vfx(-1 2 4 7) 3) ⇒ 7
----

[#objects:s47]
[horizontal]
procedure:: `(fxvector-set! _fxvector_ _n_ _fixnum_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_fxvector_` must be mutable. `_n_` must be a nonnegative fixnum strictly less than the length of `_fxvector_`. `fxvector-set!` changes the ``_n_``th element of `_fxvector_` to `_fixnum_`.

[source,scheme,subs="quotes"]
----
(let ([v (fxvector 1 2 3 4 5)])
  (fxvector-set! v 2 (fx- (fxvector-ref v 2)))
  v) ⇒ #vfx(1 2 -3 4 5)
----

[#objects:s48]
[horizontal]
procedure:: `(fxvector-fill! _fxvector_ _fixnum_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_fxvector_` must be mutable. `fxvector-fill!` replaces each element of `_fxvector_` with `_fixnum_`.

[source,scheme,subs="quotes"]
----
(let ([v (fxvector 1 2 3)])
  (fxvector-fill! v 0)
  v) ⇒ #vfx(0 0 0)
----

[#objects:s49]
[horizontal]
procedure:: `(fxvector\->list _fxvector_)`
returns:: a list of the elements of `_fxvector_`
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(fxvector->list (fxvector)) ⇒ ()
(fxvector->list #vfx(7 5 2)) ⇒ (7 5 2)

(let ([v #vfx(1 2 3 4 5)])
  (apply fx* (fxvector->list v))) ⇒ 120
----

[#objects:s50]
[horizontal]
procedure:: `(list\->fxvector _list_)`
returns:: an fxvector of the elements of `_list_`
libraries:: `(chezscheme)`

`_list_` must consist entirely of fixnums.

[source,scheme,subs="quotes"]
----
(list->fxvector '()) ⇒ #vfx()
(list->fxvector '(3 5 7)) ⇒ #vfx(3 5 7)

(let ([v #vfx(1 2 3 4 5)])
  (let ([ls (fxvector->list v)])
    (list->fxvector (map fx* ls ls)))) ⇒ #vfx(1 4 9 16 25)
----

[#objects:s51]
[horizontal]
procedure:: `(fxvector-copy _fxvector_)`
returns:: a copy of `_fxvector_`
libraries:: `(chezscheme)`

`fxvector-copy` creates a new fxvector with the same length and contents as `_fxvector_`.

[source,scheme,subs="quotes"]
----
(fxvector-copy #vfx(3 4 5)) ⇒ #vfx(3 4 5)

(let ([v #vfx(3 4 5)])
  (eq? v (fxvector-copy v))) ⇒ #f
----

[#objects:s52]
[horizontal]
procedure:: `(mutable-fxvector? _obj_)`
returns:: `#t` if `_obj_` is a mutable fxvector, `#f` otherwise
procedure:: `(immutable-fxvector? _obj_)`
returns:: `#t` if `_obj_` is an immutable fxvector, `#f` otherwise
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(mutable-fxvector? (fxvector 1 2 3)) ⇒ #t
(mutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) ⇒ #f
(immutable-fxvector? (fxvector 1 2 3)) ⇒ #f
(immutable-fxvector? (fxvector->immutable-fxvector (fxvector 1 2 3))) ⇒ #t
(immutable-fxvector? (cons 3 4)) ⇒ #f
----

[#objects:s53]
[horizontal]
procedure:: `(fxvector\->immutable-fxvector _fxvector_)`
returns:: either an immutable copy of `_fxvector_` or `_fxvector_` itself
libraries:: `(chezscheme)`

[#objects:s54]
[#objects:s55]
The result is `_fxvector_` itself if `_fxvector_` is immutable; otherwise, the result is an immutable fxvector with the same content as `_fxvector_`.

[source,scheme,subs="quotes"]
----
(define v (fxvector->immutable-fxvector (fxvector 1 2 3)))
(fxvector-set! v 0 0) ⇒ _exception: not mutable_
----

=== Section 7.7. Bytevectors [[section_7.7.]]

As with vectors, _Chez Scheme_ extends the syntax of bytevectors to allow the length of the vector to be specified between the `\#` and open parenthesis, e.g., `#3vu8(1 105 73)`. If fewer elements are supplied in the syntax than the specified length, each element after the last printed element is the same as the last printed element. This extension is disabled in an input stream after `#!r6rs` has been seen by the reader, unless `#!chezscheme` has been seen more recently.

_Chez Scheme_ also extends the set of bytevector primitives, including primitives for loading and storing 3, 5, 6, and 7-byte quantities.

The length and indices of a bytevector in _Chez Scheme_ are always fixnums.

[#objects:s57]
All bytevectors are mutable by default, including constants. A program can create immutable bytevectors via `bytevector\->immutable-bytevector`. Any attempt to modify an immutable bytevector causes an exception to be raised.

[#objects:s59]
[horizontal]
procedure:: `(bytevector _fill_ \...)`
returns:: a new bytevector containing `_fill_ \...`
libraries:: `(chezscheme)`

Each `_fill_` value must be an exact integer representing a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative fill value is treated as its two's complement equivalent.

[source,scheme,subs="quotes"]
----
(bytevector) ⇒ #vu8()
(bytevector 1 3 5) ⇒ #vu8(1 3 5)
(bytevector -1 -3 -5) ⇒ #vu8(255 253 251)
----

[#objects:s60]
[horizontal]
procedure:: `(bytevector\->s8-list _bytevector_)`
returns:: a new list of the 8-bit signed elements of `_bytevector_`
libraries:: `(chezscheme)`

The values in the returned list are exact eight-bit signed integers, i.e., values in the range -128 to 127 inclusive. `bytevector\->s8-list` is similar to the Revised^6^ Report `bytevector\->u8-list` except the values in the returned list are signed rather than unsigned.

[source,scheme,subs="quotes"]
----
(bytevector->s8-list (make-bytevector 0)) ⇒ ()
(bytevector->s8-list #vu8(1 127 128 255)) ⇒ (1 127 -128 -1)

(let ([v #vu8(1 2 3 255)])
  (apply * (bytevector->s8-list v))) ⇒ -6
----

[#objects:s61]
[horizontal]
procedure:: `(s8-list\->bytevector _list_)`
returns:: a new bytevector of the elements of `_list_`
libraries:: `(chezscheme)`

`_list_` must consist entirely of exact eight-bit signed integers, i.e., values in the range -128 to 127 inclusive. `s8-list\->bytevector` is similar to the Revised^6^ Report procedure `u8-list\->bytevector`, except the elements of the input list are signed rather than unsigned.

[source,scheme,subs="quotes"]
----
(s8-list->bytevector '()) ⇒ #vu8()
(s8-list->bytevector '(1 127 -128 -1)) ⇒ #vu8(1 127 128 255)

(let ([v #vu8(1 2 3 4 5)])
  (let ([ls (bytevector->s8-list v)])
    (s8-list->bytevector (map - ls)))) ⇒ #vu8(255 254 253 252 251)
----

[#objects:s62]
[horizontal]
procedure:: `(bytevector-truncate! _bytevector_ _n_)`
returns:: `_bytevector_` or the empty bytevector
libraries:: `(chezscheme)`

`_bytevector_` must be mutable. `_n_` must be an exact nonnegative fixnum not greater than the length of `_bytevector_`. If `_n_` is zero, `bytevector-truncate!` returns the empty bytevector. Otherwise, `_bytevector-truncate!_` destructively truncates `_bytevector_` to its first `_n_` bytes and returns `_bytevector_`.

[source,scheme,subs="quotes"]
----
(define bv (make-bytevector 7 19))
(bytevector-truncate! bv 0) ⇒ #vu8()
bv ⇒ #vu8(19 19 19 19 19 19 19)
(bytevector-truncate! bv 3) ⇒ #vu8(19 19 19)
bv ⇒ #vu8(19 19 19)
----

[#objects:s63]
[horizontal]
procedure:: `(bytevector-u24-ref _bytevector_ _n_ _eness_)`
returns:: the 24-bit unsigned integer at index `_n_` (zero-based) of `_bytevector_`
procedure:: `(bytevector-s24-ref _bytevector_ _n_ _eness_)`
returns:: the 24-bit signed integer at index `_n_` (zero-based) of `_bytevector_`
procedure:: `(bytevector-u40-ref _bytevector_ _n_ _eness_)`
returns:: the 40-bit unsigned integer at index `_n_` (zero-based) of `_bytevector_`
procedure:: `(bytevector-s40-ref _bytevector_ _n_ _eness_)`
returns:: the 40-bit signed integer at index `_n_` (zero-based) of `_bytevector_`
procedure:: `(bytevector-u48-ref _bytevector_ _n_ _eness_)`
returns:: the 48-bit unsigned integer at index `_n_` (zero-based) of `_bytevector_`
procedure:: `(bytevector-s48-ref _bytevector_ _n_ _eness_)`
returns:: the 48-bit signed integer at index `_n_` (zero-based) of `_bytevector_`
procedure:: `(bytevector-u56-ref _bytevector_ _n_ _eness_)`
returns:: the 56-bit unsigned integer at index `_n_` (zero-based) of `_bytevector_`
procedure:: `(bytevector-s56-ref _bytevector_ _n_ _eness_)`
returns:: the 56-bit signed integer at index `_n_` (zero-based) of `_bytevector_`
libraries:: `(chezscheme)`

`_n_` must be an exact nonnegative integer and indexes the starting byte of the value. The sum of `_n_` and the number of bytes occupied by the value (3 for 24-bit values, 5 for 40-bit values, 6 for 48-bit values, and 7 for 56-bit values) must not exceed the length of `_bytevector_`. `_eness_` must be a valid endianness symbol naming the endianness.

The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two's complement value.

[#objects:s64]
[horizontal]
procedure:: `(bytevector-u24-set! _bytevector_ _n_ _u24_ _eness_)`
procedure:: `(bytevector-s24-set! _bytevector_ _n_ _s24_ _eness_)`
procedure:: `(bytevector-u40-set! _bytevector_ _n_ _u40_ _eness_)`
procedure:: `(bytevector-s40-set! _bytevector_ _n_ _s40_ _eness_)`
procedure:: `(bytevector-u48-set! _bytevector_ _n_ _u48_ _eness_)`
procedure:: `(bytevector-s48-set! _bytevector_ _n_ _s48_ _eness_)`
procedure:: `(bytevector-u56-set! _bytevector_ _n_ _u56_ _eness_)`
procedure:: `(bytevector-s56-set! _bytevector_ _n_ _s56_ _eness_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_bytevector_` must be mutable. `_n_` must be an exact nonnegative integer and indexes the starting byte of the value. The sum of `_n_` and the number of bytes occupied by the value must not exceed the length of `_bytevector_`. `_u24_` must be a 24-bit unsigned value, i.e., a value in the range 0 to 2^24^ - 1 inclusive; `_s24_` must be a 24-bit signed value, i.e., a value in the range -2^23^ to 2^23^ - 1 inclusive; `_u40_` must be a 40-bit unsigned value, i.e., a value in the range 0 to 2^40^ - 1 inclusive; `_s40_` must be a 40-bit signed value, i.e., a value in the range -2^39^ to 2^39^ - 1 inclusive; `_u48_` must be a 48-bit unsigned value, i.e., a value in the range 0 to 2^48^ - 1 inclusive; `_s48_` must be a 48-bit signed value, i.e., a value in the range -2^47^ to 2^47^ - 1 inclusive; `_u56_` must be a 56-bit unsigned value, i.e., a value in the range 0 to 2^56^ - 1 inclusive; and `_s56_` must be a 56-bit signed value, i.e., a value in the range -2^55^ to 2^55^ - 1 inclusive. `_eness_` must be a valid endianness symbol naming the endianness.

These procedures store the given value in the 3, 5, 6, or 7 bytes starting at index `_n_` (zero-based) of `_bytevector_`. Negative values are stored as their two's complement equivalent.

[#objects:s65]
[horizontal]
procedure:: `(mutable-bytevector? _obj_)`
returns:: `#t` if `_obj_` is a mutable bytevector, `#f` otherwise
procedure:: `(immutable-bytevector? _obj_)`
returns:: `#t` if `_obj_` is an immutable bytevector, `#f` otherwise
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(mutable-bytevector? (bytevector 1 2 3)) ⇒ #t
(mutable-bytevector?
  (bytevector->immutable-bytevector (bytevector 1 2 3))) ⇒ #f
(immutable-bytevector? (bytevector 1 2 3)) ⇒ #f
(immutable-bytevector?
  (bytevector->immutable-bytevector (bytevector 1 2 3))) ⇒ #t
(immutable-bytevector? (cons 3 4)) ⇒ #f
----

[#objects:s66]
[horizontal]
procedure:: `(bytevector\->immutable-bytevector _bytevector_)`
returns:: an immutable bytevector equal to `_bytevector_`
libraries:: `(chezscheme)`

[#objects:s67]
[#objects:s68]
The result is `_bytevector_` itself if `_bytevector_` is immutable; otherwise, the result is an immutable bytevector with the same content as `_bytevector_`.

[source,scheme,subs="quotes"]
----
(define bv (bytevector->immutable-bytevector (bytevector 1 2 3)))
(bytevector-u8-set! bv 0 0) ⇒ _exception: not mutable_
----

[#objects:s69]
[horizontal]
procedure:: `(bytevector-compress _bytevector_)`
returns:: a new bytevector containing compressed content of `_bytevector_`
libraries:: `(chezscheme)`

The result is the raw compressed data with a minimal header to record the uncompressed size and the compression mode. The result does not include the header that is written by port-based compression using the `compressed` option. The compression format is determined by the `compress-format` parameter, and the compression level is determined by the `compress-level` parameter.

[#objects:s72]
[horizontal]
procedure:: `(bytevector-uncompress _bytevector_)`
returns:: a bytevector containing uncompressed content of `_bytevector_`
libraries:: `(chezscheme)`

Uncompresses a `_bytevector_` produced by `bytevector-compress` to a new bytevector with the same content as the original given to `bytevector-compress`.

=== Section 7.8. Boxes [[section_7.8.]]

Boxes are single-cell objects that are primarily useful for providing an "extra level of indirection." This extra level of indirection is typically used to allow more than one body of code or data structure to share a reference, or pointer, to an object. For example, boxes may be used to implement _call-by-reference_ semantics in an interpreter for a language employing this parameter passing discipline.

Boxes are written with the prefix `\#&` (pronounced "hash-ampersand"). For example, `#&(a b c)` is a box holding the list `(a b c)`. The box syntax is disabled in an input stream after `\#!r6rs` has been seen by the reader, unless `#!chezscheme` has been seen more recently.

[#objects:s79]
All boxes are mutable by default, including constants. A program can create immutable boxes via `box-immutable`. Any attempt to modify an immutable box causes an exception to be raised.

[#objects:s81]
[horizontal]
procedure:: `(box? _obj_)`
returns:: `#t` if `_obj_` is a box, `#f` otherwise
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(box? '#&a) ⇒ #t
(box? 'a) ⇒ #f
(box? (box 3)) ⇒ #t
----

[#objects:s82]
[horizontal]
procedure:: `(box _obj_)`
returns:: a new box containing `_obj_`
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(box 'a) ⇒ \#&a
(box (box '(a b c))) ⇒ #&#&(a b c)
----

[#objects:s83]
[horizontal]
procedure:: `(unbox _box_)`
returns:: contents of `_box_`
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(unbox \#&a) ⇒ a
(unbox #&#&(a b c)) ⇒ #&(a b c)

(let ([b (box "hi")])
  (unbox b)) ⇒ "hi"
----

[#objects:s84]
[horizontal]
procedure:: `(set-box! _box_ _obj_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_box_` must be mutable. `set-box!` sets the contents of `_box_` to `_obj_`.

[source,scheme,subs="quotes"]
----
(let ([b (box 'x)])
  (set-box! b 'y)
  b) ⇒ #&y

(let ([incr!
       (lambda (x)
         (set-box! x (+ (unbox x) 1)))])
  (let ([b (box 3)])
    (incr! b)
    (unbox b))) ⇒ 4
----

[#objects:s85]
[horizontal]
procedure:: `(box-cas! _box_ _old-obj_ _new-obj_)`
returns:: `#t` if `_box_` is changed, `#f` otherwise
libraries:: `(chezscheme)`

`_box_` must be mutable. `box-cas!` atomically changes the content of `_box_` to `_new-obj_` if the replaced content is `eq?` to `_old-obj_`. If the content of `_box_` that would be replaced is not `eq?` to `_old-obj_`, then `_box_` is unchanged.

[source,scheme,subs="quotes"]
----
(define b (box 'old))
(box-cas! b 'old 'new) ⇒ #t
(unbox b) ⇒ 'new
(box-cas! b 'other 'wrong) ⇒ #f
(unbox b) ⇒ 'new
----

[#objects:s86]
[horizontal]
procedure:: `(mutable-box? _obj_)`
returns:: `#t` if `_obj_` is a mutable box, `#f` otherwise
procedure:: `(immutable-box? _obj_)`
returns:: `#t` if `_obj_` is an immutable box, `#f` otherwise
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(mutable-box? (box 1)) ⇒ #t
(mutable-box? (box-immutable 1)) ⇒ #f
(immutable-box? (box 1)) ⇒ #f
(immutable-box? (box-immutable 1)) ⇒ #t
(mutable-box? (cons 3 4)) ⇒ #f
----

[#objects:s87]
[horizontal]
procedure:: `(box-immutable _obj_)`
returns:: a new immutable box containing `_obj_`
libraries:: `(chezscheme)`

[#objects:s88]
[#objects:s89]
Boxes are typically intended to support shared, mutable structure, so immutable boxes are not often useful.

[source,scheme,subs="quotes"]
----
(define b (box-immutable 1))
(set-box! b 0) ⇒ _exception: not mutable_
----

=== Section 7.9. Symbols [[section_7.9.]]

_Chez Scheme_ extends the standard symbol syntax in several ways:

- Symbol names may begin with `@`, but `,@abc` is parsed as `(unquote-splicing abc)`; to produce `(unquote @abc)` one can type `, @abc`, `, \x40;abc`, or `,|@abc|`.

- The single-character sequences `{` and `}` are read as symbols.

- A symbol's name may begin with any character that might normally start a number, including a digit, `.`, `+`, `-`, as long as the delimited sequence of characters starting with that character cannot be parsed as a number.

- A symbol whose name contains arbitrary characters may be written by escaping them with `\` or with `|`. `\` is used to escape a single character (except 'x', since `\x` marks the start of a hex scalar value), whereas `|` is used to escape the group of characters that follow it up through the matching `|`.

The printer always prints symbols using the standard R6RS syntax, so that, e.g., `@abc` prints as `\x40;abc` and `1-` prints as `\x31;-`.

Gensyms are printed `\#{` and `}` brackets that enclose both the "pretty" and "unique" names, e.g., `#{g1426 e5g1c94g642dssw-a}`. They may also be printed using the pretty name only with the prefix `\#:`, e.g., `#:g1426`.

These extensions are disabled in an input stream after `\#!r6rs` has been seen by the reader, unless `#!chezscheme` has been seen more recently. [[objects:s92]]

[#desc:gensym]
[horizontal]
procedure:: `(gensym)`
procedure:: `(gensym _pretty-name_)`
procedure:: `(gensym _pretty-name_ _unique-name_)`
returns:: a unique generated symbol
libraries:: `(chezscheme)`

[#objects:s93]
[#objects:s94]
Each call to `gensym` returns a unique generated symbol, or _gensym_. Each generated symbol has two names: a "pretty" name and a "unique" name.

In the first form above, the pretty name is formed (lazily---see below) by combining an internal prefix with the value of an internal counter. After each name is formed, the internal counter is incremented. The parameters `gensym-prefix` and `gensym-count`, described below, may be used to access and set the internal prefix and counter. By default, the prefix is the single-character string `"g"`. In the second and third forms, the pretty name of the new gensym is `_pretty-name_`, which must be a string. The pretty name of a gensym is returned by the procedure `symbol\->string`.

In both the first and second forms, the unique name is an automatically generated globally unique name. Globally unique names are constructed (lazily---see below) from the combination of a universally unique identifier and an internal counter. In the third form of gensym, the unique name of the new gensym is `_unique-name_`, which must be a string. The unique name of a gensym may be obtained via the procedure `gensym\->unique-string`.

The unique name allows gensyms to be written in such a way that they can be read back and reliably commonized on input. The syntax for gensyms includes both the pretty name and the unique name, as shown in the example below:

[source,scheme,subs="quotes"]
----
(gensym) ⇒ #{g0 bcsfg5eq4e9b3h9o-a}
----

When the parameter `print-gensym` is set to `pretty`, the printer prints the pretty name only, with a `#:` syntax, so

[source,scheme,subs="quotes"]
----
(parameterize ([print-gensym 'pretty])
  (write (gensym)))
----

prints `#:g0`.

When the reader sees the `#:` syntax, it produces a gensym with the given pretty name, but the original unique name is lost.

When the parameter is set to `#f`, the printer prints just the pretty name, so

[source,scheme,subs="quotes"]
----
(parameterize ([print-gensym #f])
  (write (gensym)))
----

prints `g0`. This is useful only when gensyms do not need to be read back in as gensyms.

In order to reduce construction and (when threaded) synchronization overhead when gensyms are frequently created but rarely printed or stored in an object file, generated pretty and unique names are created lazily, i.e., not until first requested, either by the printer, fasl writer, or explicitly by one of the procedures `symbol\->string` or `gensym\->unique-string`. In addition, a gensym is not placed into the system's internal symbol table (the oblist; see <<desc:oblist,page 156>>) until the unique name is requested. This allows a gensym to be reclaimed by the storage manager if no references to the gensym exist and no unique name exists by which to access it, even if it has a top-level binding or a nonempty property list.

[source,scheme,subs="quotes"]
----
(define x (gensym))
x                         ⇒ #{g2 bcsfg5eq4e9b3h9o-c}
(symbol->string x)        ⇒ "g2"
(gensym->unique-string x) ⇒ "bcsfg5eq4e9b3h9o-c"
----

Gensyms subsume the notion of _uninterned symbols_ supported by earlier versions of _Chez Scheme_. Similarly, the predicate `uninterned-symbol?` has been replaced by `gensym?`.

[#objects:s100]
[horizontal]
thread parameter:: `gensym-prefix`
thread parameter:: `gensym-count`
libraries:: `(chezscheme)`

[#objects:s101]
The parameters `gensym-prefix` and `gensym-count` are used to access and set the internal prefix and counter from which the pretty name of a gensym is generated when `gensym` is not given an explicit string argument. `gensym-prefix` defaults to the string `"g"` and may be set to any object. `gensym-count` starts at 0 and may be set to any nonnegative integer.

As described above, _Chez Scheme_ delays the creation of the pretty name until the name is first requested by the printer or by an explicit call to `symbol\->string`. These parameters are not consulted until that time; setting them when `gensym` is called thus has no effect on the generated name.

[source,scheme,subs="quotes"]
----
(let ([x (parameterize ([gensym-prefix "genny"]
                        [gensym-count 17]
                        [print-gensym 'pretty])
           (gensym))])
  (format "~s" x))                       ⇒ "#{g4 bcsfg5eq4e9b3h9o-e}"
(let ([x (gensym)])
  (parameterize ([gensym-prefix "genny"]
                 [gensym-count 17]
                 [print-gensym #f])
    (format "~s" (gensym))))             ⇒ "genny17"
----

[#objects:s102]
[horizontal]
procedure:: `(gensym\->unique-string _gensym_)`
returns:: the unique name of `_gensym_`
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(gensym->unique-string (gensym)) ⇒ "bd3kufa7ypjcuvut-g"
----

[#objects:s103]
[horizontal]
procedure:: `(gensym? _obj_)`
returns:: `#t` if `_obj_` is gensym, `#f` otherwise
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(gensym? (string->symbol "z")) ⇒ \#f
(gensym? (gensym "z")) ⇒ #t
(gensym? 'a) ⇒ #f
(gensym? 3) ⇒ #f
(gensym? (gensym)) ⇒ #t
(gensym? '#{g2 bcsfg5eq4e9b3h9o-c}) ⇒ #t
----

[#property-lists]
[horizontal]
procedure:: `(putprop _symbol_ _key_ _value_)` [[objects:s104]]
returns:: unspecified
libraries:: `(chezscheme)`

_Chez Scheme_ associates a _property list_ with each symbol, allowing multiple `_key-value_` pairs to be stored directly with the symbol. New key-value pairs may be placed in the property list or retrieved in a manner analogous to the use of association lists, using the procedures `putprop` and `getprop`. Property lists are often used to store information related to the symbol itself. For example, a natural language program might use symbols to represent words, using their property lists to store information about use and meaning.

`putprop` associates `_value_` with `_key_` on the property list of `_symbol_`. `_key_` and `_value_` may be any types of object, although `_key_` is typically a symbol.

`putprop` may be used to establish a new property or to change an existing property.

See the examples under `getprop` below.

[#objects:s106]
[horizontal]
procedure:: `(getprop _symbol_ _key_)`
procedure:: `(getprop _symbol_ _key_ _default_)`
returns:: the value associated with `_key_` on the property list of `_symbol_`
libraries:: `(chezscheme)`

[#objects:s107]
`getprop` searches the property list of `_symbol_` for a key identical to `_key_` (in the sense of `eq?`), and returns the value associated with this key, if any. If no value is associated with `_key_` on the property list of `_symbol_`, `getprop` returns `_default_`, or `#f` if the `_default_` argument is not supplied.

[source,scheme,subs="quotes"]
----
(putprop 'fred 'species 'snurd)
(putprop 'fred 'age 4)
(putprop 'fred 'colors '(black white))

(getprop 'fred 'species) ⇒ snurd
(getprop 'fred 'colors) ⇒ (black white)
(getprop 'fred 'nonkey) ⇒ #f
(getprop 'fred 'nonkey 'unknown) ⇒ unknown

(putprop 'fred 'species #f)
(getprop 'fred 'species 'unknown) ⇒ #f
----

[#objects:s108]
[horizontal]
procedure:: `(remprop _symbol_ _key_)`
returns:: unspecified
libraries:: `(chezscheme)`

`remprop` removes the property with key `_key_` from the property list of `_symbol_`, if such a property exists.

[source,scheme,subs="quotes"]
----
(putprop 'fred 'species 'snurd)
(getprop 'fred 'species) ⇒ snurd

(remprop 'fred 'species)
(getprop 'fred 'species 'unknown) ⇒ unknown
----

[#objects:s110]
[horizontal]
procedure:: `(property-list _symbol_)`
returns:: a copy of the internal property list for `_symbol_`
libraries:: `(chezscheme)`

A property list is a list of alternating keys and values, i.e., `(_key_ _value_ \...)`.

[source,scheme,subs="quotes"]
----
(putprop 'fred 'species 'snurd)
(putprop 'fred 'colors '(black white))
(property-list 'fred) ⇒ (colors (black white) species snurd)
----

[#desc:oblist]
[horizontal]
procedure:: `(oblist)` [[objects:s111]]
returns:: a list of interned symbols
libraries:: `(chezscheme)`

The system maintains an internal symbol table used to insure that any two occurrences of the same symbol name resolve to the same symbol object. The `oblist` procedure returns a list of the symbols currently in this symbol table.

The list of interned symbols grows when a new symbol is introduced into the system or when the unique name of a gensym (see <<desc:gensym,page 152>>) is requested. It shrinks when the garbage collector determines that it is safe to discard a symbol. It is safe to discard a symbol only if the symbol is not accessible except through the oblist, has no top-level binding, and has no properties on its property list.

[source,scheme,subs="quotes"]
----
(if (memq 'tiger (oblist)) 'yes 'no) ⇒ yes
(equal? (oblist) (oblist)) ⇒ #t
(= (length (oblist)) (length (oblist))) ⇒ #t _or_ #f
----

The first example above follows from the property that all interned symbols are in the oblist from the time they are read, which happens prior to evaluation. The second example follows from the fact that no symbols can be removed from the oblist while references to those symbols exist, in this case, within the list returned by the first call to `oblist` (whichever call is performed first). The expression in the third example can return `#f` only if a garbage collection occurs sometime between the two calls to `oblist`, and only if one or more symbols are removed from the oblist by that collection.

=== Section 7.10. Void [[section_7.10.]]

Many Scheme operations return an unspecified result. _Chez Scheme_ typically returns a special _void_ object when the value returned by an operation is unspecified. The _Chez Scheme_ void object is not meant to be used as a datum, and consequently does not have a reader syntax. As for other objects without a reader syntax, such as procedures and ports, _Chez Scheme_ output procedures print the void object using a nonreadable representation, i.e., `#<void>`. Since the void object should be returned only by operations that do not have "interesting" values, the default waiter printer (see `waiter-write`) suppresses the printing of the void object. `set!`, `set-car!`, `load`, and `write` are examples of _Chez Scheme_ operations that return the void object.

[#objects:s112]
[horizontal]
procedure:: `(void)`
returns:: the void object
libraries:: `(chezscheme)`

`void` is a procedure of no arguments that returns the void object. It can be used to force expressions that are used for effect or whose values are otherwise unspecified to evaluate to a consistent, trivial value. Since most _Chez Scheme_ operations that are used for effect return the void object, however, it is rarely necessary to explicitly invoke the `void` procedure.

Since the void object is used explicitly as an "unspecified" value, it is a bad idea to use it for any other purpose or to count on any given expression evaluating to the void object.

The default waiter printer suppresses the void object; that is, nothing is printed for expressions that evaluate to the void object.

[source,scheme,subs="quotes"]
----
(eq? (void) #f) ⇒ #f
(eq? (void) #t) ⇒ #f
(eq? (void) '()) ⇒ #f
----

=== Section 7.11. Sorting [[section_7.11.]]

[#objects:s113]
[horizontal]
procedure:: `(sort _predicate_ _list_)`
procedure:: `(sort! _predicate_ _list_)`
returns:: a list containing the elements of `_list_` sorted according to `_predicate_`
libraries:: `(chezscheme)`

`sort` is identical to the Revised^6^ Report `list-sort`, and `sort!` is a destructive version of `sort`, i.e., it reuses pairs from the input list to form the output list.

[source,scheme,subs="quotes"]
----
(sort < '(3 4 2 1 2 5)) ⇒ (1 2 2 3 4 5)
(sort! < '(3 4 2 1 2 5)) ⇒ (1 2 2 3 4 5)
----

[#objects:s114]
[horizontal]
procedure:: `(merge _predicate_ _list~1~_ _list~2~_)`
procedure:: `(merge! _predicate_ _list~1~_ _list~2~_)`
returns:: `_list~1~_` merged with `_list~2~_` in the order specified by `_predicate_`
libraries:: `(chezscheme)`

`_predicate_` should be a procedure that expects two arguments and returns `#t` if its first argument must precede its second in the merged list. It should not have any side effects. That is, if `_predicate_` is applied to two objects `_x_` and `_y_`, where `_x_` is taken from the second list and `_y_` is taken from the first list, it should return true only if `_x_` should appear before `_y_` in the output list. If this constraint is met, `merge` and `merge!` are stable, in that items from `_list~1~_` are placed in front of equivalent items from `_list~2~_` in the output list. Duplicate elements are included in the merged list.

`merge!` combines the lists destructively, using pairs from the input lists to form the output list.

[source,scheme,subs="quotes"]
----
(merge char&lt;?
       '(\#\a #\c)
       '(#\b \#\c #\d)) ⇒ (#\a #\b #\c #\c #\d)
(merge <
       '(1/2 2/3 3/4)
       '(0.5 0.6 0.7)) ⇒ (1/2 0.5 0.6 2/3 0.7 3/4)
----

=== Section 7.12. Hashtables [[section_7.12.]]

_Chez Scheme_ provides several extensions to the hashtable mechanism, including a mechanism for directly accessing a key, value pair in a hashtable, support for weak eq and eqv hashtables, and a set of procedures specialized to eq and symbol hashtables.

[#objects:s115]
[horizontal]
procedure:: `(hashtable-cell _hashtable_ _key_ _default_)`
returns:: a pair (see below)
libraries:: `(chezscheme)`

`_hashtable_` must be a hashtable. `_key_` and `_default_` may be any Scheme values.

If no value is associated with `_key_` in `_hashtable_`, `hashtable-cell` modifies `_hashtable_` to associate `_key_` with `_default_`. It returns a pair whose car is `_key_` and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate `_key_` with a new value. The `_key_` in the car field should not be changed. The advantage of this procedure over the Revised^6^ Report procedures for manipulating hashtable entries is that the value associated with a key may be read or written many times with only a single hashtable lookup.

[source,scheme,subs="quotes"]
----
(define ht (make-eq-hashtable))
(define v (vector 'a 'b 'c))
(define cell (hashtable-cell ht v 3))
cell ⇒ (#(a b c) . 3)
(hashtable-ref ht v 0) ⇒ 3
(set-cdr! cell 4)
(hashtable-ref ht v 0) ⇒ 4
----

[#objects:s116]
[horizontal]
procedure:: `(hashtable-keys _hashtable_)`
procedure:: `(hashtable-keys _hashtable_ _size_)`
returns:: a vector containing the keys in `_hashtable_`
libraries:: `(chezscheme)`

Identitcal to the Revised^6^ Report counterpart, but allowing an optional `_size_` argument. If `_size_` is specified, then it must be an exact, nonnegative integer, and the result vector contains no more than `_size_` elements. Different calls to `hashtable-keys` with a `_size_` less than `(hashtable-size _hashtable_)` may return different subsets of ``_hashtable_``'s keys.

[source,scheme,subs="quotes"]
----
(define ht (make-eq-hashtable))
(hashtable-set! ht 'a "one")
(hashtable-set! ht 'b "two")
(hashtable-set! ht 'c "three")
(hashtable-keys ht) ⇒ #(a b c) _or any permutation_
(hashtable-keys ht 1) ⇒ #(a) _or_ #(b) _or_ #(c)
----

[#objects:s117]
[horizontal]
procedure:: `(hashtable-values _hashtable_)`
procedure:: `(hashtable-values _hashtable_ _size_)`
returns:: a vector containing the values in `_hashtable_`
libraries:: `(chezscheme)`

Each value is the value of one of the keys in `_hashtable_`. Duplicate values are not removed. The values may appear in any order in the returned vector. If `_size_` is specified, then it must be an exact, nonnegative integer, and the result vector contains no more than `_size_` elements. Different calls to `hashtable-values` with a `_size_` less than `(hashtable-size _hashtable_)` may return different subsets of ``_hashtable_``'s values.

[source,scheme,subs="quotes"]
----
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 "one")
(hashtable-set! ht p2 "two")
(hashtable-set! ht 'q "two")
(hashtable-values ht) ⇒ #("one" "two" "two") _or any permutation_
(hashtable-values ht 1) ⇒ #("one") _or_ #("two")
----

This procedure is equivalent to calling `hashtable-entries` and returning only the second result, but it is more efficient since the separate vector of keys need not be created.

[#objects:s118]
[horizontal]
procedure:: `(hashtable-entries _hashtable_)`
procedure:: `(hashtable-entries _hashtable_ _size_)`
returns:: two vectors containing the keys and values in `_hashtable_`
libraries:: `(chezscheme)`

Identitcal to the Revised^6^ Report counterpart, but allowing an optional `_size_` argument. If `_size_` is specified, then it must be an exact, nonnegative integer, and the result vectors contain no more than `_size_` elements. Different calls to `hashtable-entries` with a `_size_` less than `(hashtable-size _hashtable_)` may return different subsets of ``_hashtable_``'s entries.

[source,scheme,subs="quotes"]
----
(define ht (make-eq-hashtable))
(hashtable-set! ht 'a "one")
(hashtable-set! ht 'b "two")
(hashtable-entries ht) ⇒ #(a b) #("one" "two") _or the other permutation_
(hashtable-entries ht 1) ⇒ #(a) #("one") _or_ #(b) #("two")
----

[#objects:s119]
[horizontal]
procedure:: `(hashtable-cells _hashtable_)`
procedure:: `(hashtable-cells _hashtable_ _size_)`
returns:: a vector of up to `_size_` elements containing the cells of `_hashtable_`
libraries:: `(chezscheme)`

Each element of the result vector is the value of one of the cells in `_hashtable_`. The cells may appear in any order in the returned vector. If `_size_` is specified, then it must be an exact, nonnegative integer, and the result vector contains no more than `_size_` cells. If `_size_` is not specified, then the result vector has `(hashtable-size _hashtable_)` elements. Different calls to `hashtable-cells` with a `_size_` less than `(hashtable-size _hashtable_)` may return different subsets of ``_hashtable_``'s cells.

[source,scheme,subs="quotes"]
----
(define ht (make-eqv-hashtable))
(hashtable-set! ht 1 'one)
(hashtable-set! ht 2 'two)
(hashtable-cells ht) ⇒ #((1 . one) (2 . two)) _or_ #((2 . two) (1 . one))
(hashtable-cells ht 1) ⇒ #((1 . one)) _or_ #((2 . two))
(hashtable-cells ht 0) ⇒ #()
----

[#objects:s120]
[horizontal]
procedure:: `(make-weak-eq-hashtable)`
procedure:: `(make-weak-eq-hashtable _size_)`
procedure:: `(make-weak-eqv-hashtable)`
procedure:: `(make-weak-eqv-hashtable _size_)`
returns:: a new weak eq hashtable
libraries:: `(chezscheme)`

These procedures are like the Revised^6^ Report procedures `make-eq-hashtable` and `make-eqv-hashtable` except the keys of the hashtable are held weakly, i.e., they are not protected from the garbage collector. Keys reclaimed by the garbage collector are removed from the table, and their associated values are dropped the next time the table is modified, if not sooner.

Values in the hashtable are referenced normally as long as the key is not reclaimed, since keys are paired values using weak pairs. Consequently, if a value in the hashtable refers to its own key, then garbage collection is prevented from reclaiming the key. See `make-ephemeron-eq-hashtable` and `make-ephemeron-eqv-hashtable`.

A copy of a weak eq or eqv hashtable created by `hashtable-copy` is also weak. If the copy is immutable, inaccessible keys may still be dropped from the hashtable, even though the contents of the table is otherwise unchanging. The effect of this can be observed via `hashtable-keys` and `hashtable-entries`.

[source,scheme,subs="quotes"]
----
(define ht1 (make-weak-eq-hashtable))
(define ht2 (make-weak-eq-hashtable 32))
----

[#objects:s121]
[horizontal]
procedure:: `(make-ephemeron-eq-hashtable)`
procedure:: `(make-ephemeron-eq-hashtable _size_)`
procedure:: `(make-ephemeron-eqv-hashtable)`
procedure:: `(make-ephemeron-eqv-hashtable _size_)`
returns:: a new ephemeron eq hashtable
libraries:: `(chezscheme)`

These procedures are like `make-weak-eq-hashtable` and `make-weak-eqv-hashtable`, but a value in the hashtable can refer to a key in the hashtable (directly or indirectly) without preventing garbage collection from reclaiming the key, because keys are paired with values using ephemeron pairs.

A copy of an ephemeron eq or eqv hashtable created by `hashtable-copy` is also an ephemeron table, and an inaccesible key can be dropped from an immutable ephemeron hashtable in the same way as for an immutable weak hashtable.

[source,scheme,subs="quotes"]
----
(define ht1 (make-ephemeron-eq-hashtable))
(define ht2 (make-ephemeron-eq-hashtable 32))
----

[#objects:s122]
[horizontal]
procedure:: `(hashtable-weak? _obj_)`
returns:: `#t` if `_obj_` is a weak eq or eqv hashtable, `#f` otherwise
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(define ht1 (make-weak-eq-hashtable))
(define ht2 (hashtable-copy ht1))
(hashtable-weak? ht2) ⇒ #t
----

[#objects:s123]
[horizontal]
procedure:: `(hashtable-ephemeron? _obj_)`
returns:: `#t` if `_obj_` is an ephemeron eq or eqv hashtable, `#f` otherwise
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(define ht1 (make-ephemeron-eq-hashtable))
(define ht2 (hashtable-copy ht1))
(hashtable-ephemeron? ht2) ⇒ #t
----

[#objects:s124]
[horizontal]
procedure:: `(eq-hashtable? _obj_)`
returns:: `#t` if `_obj_` is an eq hashtable, `#f` otherwise
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(eq-hashtable? (make-eq-hashtable)) ⇒ #t
(eq-hashtable? '(not a hash table)) ⇒ #f
----

[#objects:s125]
[horizontal]
procedure:: `(eq-hashtable-weak? _hashtable_)`
returns:: `#t` if `_hashtable_` is weak, `#f` otherwise
libraries:: `(chezscheme)`

`_hashtable_` must be an eq hashtable.

[source,scheme,subs="quotes"]
----
(eq-hashtable-weak? (make-eq-hashtable)) ⇒ #f
(eq-hashtable-weak? (make-weak-eq-hashtable)) ⇒ #t
----

[#objects:s126]
[horizontal]
procedure:: `(eq-hashtable-ephemeron? _hashtable_)`
returns:: `#t` if `_hashtable_` uses ephemeron pairs, `#f` otherwise
libraries:: `(chezscheme)`

`_hashtable_` must be an eq hashtable.

[source,scheme,subs="quotes"]
----
(eq-hashtable-ephemeron? (make-eq-hashtable)) ⇒ #f
(eq-hashtable-ephemeron? (make-ephemeron-eq-hashtable)) ⇒ #t
----

[#objects:s127]
[horizontal]
procedure:: `(eq-hashtable-set! _hashtable_ _key_ _value_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_hashtable_` must be a mutable eq hashtable. `_key_` and `_value_` may be any Scheme values.

`eq-hashtable-set!` associates the value `_value_` with the key `_key_` in `_hashtable_`.

[source,scheme,subs="quotes"]
----
(define ht (make-eq-hashtable))
(eq-hashtable-set! ht 'a 73)
----

[#objects:s128]
[horizontal]
procedure:: `(eq-hashtable-ref _hashtable_ _key_ _default_)`
returns:: see below
libraries:: `(chezscheme)`

`_hashtable_` must be an eq hashtable. `_key_` and `_default_` may be any Scheme values.

`eq-hashtable-ref` returns the value associated with `_key_` in `_hashtable_`. If no value is associated with `_key_` in `_hashtable_`, `eq-hashtable-ref` returns `_default_`.

[source,scheme,subs="quotes"]
----
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(eq-hashtable-set! ht p1 73)
(eq-hashtable-ref ht p1 55) ⇒ 73
(eq-hashtable-ref ht p2 55) ⇒ 55
----

[#objects:s129]
[horizontal]
procedure:: `(eq-hashtable-contains? _hashtable_ _key_)`
returns:: `#t` if an association for `_key_` exists in `_hashtable_`, `#f` otherwise
libraries:: `(chezscheme)`

`_hashtable_` must be an eq hashtable. `_key_` may be any Scheme value.

[source,scheme,subs="quotes"]
----
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(eq-hashtable-set! ht p1 73)
(eq-hashtable-contains? ht p1) ⇒ #t
(eq-hashtable-contains? ht p2) ⇒ #f
----

[#objects:s130]
[horizontal]
procedure:: `(eq-hashtable-update! _hashtable_ _key_ _procedure_ _default_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_hashtable_` must be a mutable eq hashtable. `_key_` and `_default_` may be any Scheme values. `_procedure_` should accept one argument, should return one value, and should not modify `_hashtable_`.

`eq-hashtable-update!` applies `_procedure_` to the value associated with `_key_` in `_hashtable_`, or to `_default_` if no value is associated with `_key_` in `_hashtable_`. If `_procedure_` returns, `eq-hashtable-update!` associates `_key_` with the value returned by `_procedure_`, replacing the old association, if any.

A version of `eq-hashtable-update!` that does not verify that it receives arguments of the proper type might be defined as follows.

[source,scheme,subs="quotes"]
----
(define eq-hashtable-update!
  (lambda (ht key proc value)
    (eq-hashtable-set! ht key
      (proc (eq-hashtable-ref ht key value)))))
----

An implementation may, however, be able to implement `eq-hashtable-update!` more efficiently by avoiding multiple hash computations and hashtable lookups.

[source,scheme,subs="quotes"]
----
(define ht (make-eq-hashtable))
(eq-hashtable-update! ht 'a
  (lambda (x) (* x 2))
  55)
(eq-hashtable-ref ht 'a 0) ⇒ 110
(eq-hashtable-update! ht 'a
  (lambda (x) (* x 2))
  0)
(eq-hashtable-ref ht 'a 0) ⇒ 220
----

[#objects:s131]
[horizontal]
procedure:: `(eq-hashtable-cell _hashtable_ _key_ _default_)`
returns:: a pair (see below)
libraries:: `(chezscheme)`

`_hashtable_` must be an eq hashtable. `_key_` and `_default_` may be any Scheme values.

If no value is associated with `_key_` in `_hashtable_`, `eq-hashtable-cell` modifies `_hashtable_` to associate `_key_` with `_default_`. It returns a pair whose car is `_key_` and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate `_key_` with a new value. The `_key_` should not be changed.

[source,scheme,subs="quotes"]
----
(define ht (make-eq-hashtable))
(define v (vector 'a 'b 'c))
(define cell (eq-hashtable-cell ht v 3))
cell ⇒ (#(a b c) . 3)
(eq-hashtable-ref ht v 0) ⇒ 3
(set-cdr! cell 4)
(eq-hashtable-ref ht v 0) ⇒ 4
----

[#objects:s132]
[horizontal]
procedure:: `(eq-hashtable-delete! _hashtable_ _key_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_hashtable_` must be a mutable eq hashtable. `_key_` may be any Scheme value.

`eq-hashtable-delete!` drops any association for `_key_` from `_hashtable_`.

[source,scheme,subs="quotes"]
----
(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(eq-hashtable-set! ht p1 73)
(eq-hashtable-contains? ht p1) ⇒ #t
(eq-hashtable-delete! ht p1)
(eq-hashtable-contains? ht p1) ⇒ #f
(eq-hashtable-contains? ht p2) ⇒ #f
(eq-hashtable-delete! ht p2)
----

[#objects:s133]
[horizontal]
procedure:: `(symbol-hashtable? _obj_)`
returns:: `#t` if `_obj_` is an eq hashtable, `#f` otherwise
libraries:: `(chezscheme)`

[source,scheme,subs="quotes"]
----
(symbol-hashtable? (make-hashtable symbol-hash eq?)) ⇒ #t
(symbol-hashtable? (make-eq-hashtable)) ⇒ #f
----

[#objects:s134]
[horizontal]
procedure:: `(symbol-hashtable-set! _hashtable_ _key_ _value_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_hashtable_` must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function `symbol-hash` and equivalence function `eq?`, `eqv?`, `equal?`, or `symbol=?`.) `_key_` must be a symbol, and `_value_` may be any Scheme value.

`symbol-hashtable-set!` associates the value `_value_` with the key `_key_` in `_hashtable_`.

[source,scheme,subs="quotes"]
----
(define ht (make-hashtable symbol-hash eq?))
(symbol-hashtable-ref ht 'a #f) ⇒ #f
(symbol-hashtable-set! ht 'a 73)
(symbol-hashtable-ref ht 'a #f) ⇒ 73
----

[#objects:s135]
[horizontal]
procedure:: `(symbol-hashtable-ref _hashtable_ _key_ _default_)`
returns:: see below
libraries:: `(chezscheme)`

`_hashtable_` must be a symbol hashtable. (A symbol hashtable is a hashtable created with hash function `symbol-hash` and equivalence function `eq?`, `eqv?`, `equal?`, or `symbol=?`.) `_key_` must be a symbol, and `_default_` may be any Scheme value.

`symbol-hashtable-ref` returns the value associated with `_key_` in `_hashtable_`. If no value is associated with `_key_` in `_hashtable_`, `symbol-hashtable-ref` returns `_default_`.

[source,scheme,subs="quotes"]
----
(define ht (make-hashtable symbol-hash eq?))
(define k1 'abcd)
(define k2 'not-abcd)
(symbol-hashtable-set! ht k1 "hi")
(symbol-hashtable-ref ht k1 "bye") ⇒ "hi"
(symbol-hashtable-ref ht k2 "bye") ⇒ "bye"
----

[#objects:s136]
[horizontal]
procedure:: `(symbol-hashtable-contains? _hashtable_ _key_)`
returns:: `#t` if an association for `_key_` exists in `_hashtable_`, `#f` otherwise
libraries:: `(chezscheme)`

`_hashtable_` must be a symbol hashtable. (A symbol hashtable is a hashtable created with hash function `symbol-hash` and equivalence function `eq?`, `eqv?`, `equal?`, or `symbol=?`.) `_key_` must be a symbol.

[source,scheme,subs="quotes"]
----
(define ht (make-hashtable symbol-hash eq?))
(define k1 'abcd)
(define k2 'not-abcd)
(symbol-hashtable-set! ht k1 "hi")
(symbol-hashtable-contains? ht k1) ⇒ #t
(symbol-hashtable-contains? ht k2 ) ⇒ #f
----

[#objects:s137]
[horizontal]
procedure:: `(symbol-hashtable-update! _hashtable_ _key_ _procedure_ _default_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_hashtable_` must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function `symbol-hash` and equivalence function `eq?`, `eqv?`, `equal?`, or `symbol=?`.) `_key_` must be a symbol, and `_default_` may be any Scheme value. `_procedure_` should accept one argument, should return one value, and should not modify `_hashtable_`.

`symbol-hashtable-update!` applies `_procedure_` to the value associated with `_key_` in `_hashtable_`, or to `_default_` if no value is associated with `_key_` in `_hashtable_`. If `_procedure_` returns, `symbol-hashtable-update!` associates `_key_` with the value returned by `_procedure_`, replacing the old association, if any.

A version of `symbol-hashtable-update!` that does not verify that it receives arguments of the proper type might be defined as follows.

[source,scheme,subs="quotes"]
----
(define symbol-hashtable-update!
  (lambda (ht key proc value)
    (symbol-hashtable-set! ht key
      (proc (symbol-hashtable-ref ht key value)))))
----

An implementation may, however, be able to implement `symbol-hashtable-update!` more efficiently by avoiding multiple hash computations and hashtable lookups.

[source,scheme,subs="quotes"]
----
(define ht (make-hashtable symbol-hash eq?))
(symbol-hashtable-update! ht 'a
  (lambda (x) (* x 2))
  55)
(symbol-hashtable-ref ht 'a 0) ⇒ 110
(symbol-hashtable-update! ht 'a
  (lambda (x) (* x 2))
  0)
(symbol-hashtable-ref ht 'a 0) ⇒ 220
----

[#objects:s138]
[horizontal]
procedure:: `(symbol-hashtable-cell _hashtable_ _key_ _default_)`
returns:: a pair (see below)
libraries:: `(chezscheme)`

`_hashtable_` must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function `symbol-hash` and equivalence function `eq?`, `eqv?`, `equal?`, or `symbol=?`.) `_key_` must be a symbol, and `_default_` may be any Scheme value.

If no value is associated with `_key_` in `_hashtable_`, `symbol-hashtable-cell` modifies `_hashtable_` to associate `_key_` with `_default_`. It returns a pair whose car is `_key_` and whose cdr is the associated value. Changing the cdr of this pair effectively updates the table to associate `_key_` with a new value. The `_key_` should not be changed.

[source,scheme,subs="quotes"]
----
(define ht (make-hashtable symbol-hash eq?))
(define k 'a-key)
(define cell (symbol-hashtable-cell ht k 3))
cell ⇒ (a-key . 3)
(symbol-hashtable-ref ht k 0) ⇒ 3
(set-cdr! cell 4)
(symbol-hashtable-ref ht k 0) ⇒ 4
----

[#objects:s139]
[horizontal]
procedure:: `(symbol-hashtable-delete! _hashtable_ _key_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_hashtable_` must be a mutable symbol hashtable. (A symbol hashtable is a hashtable created with hash function `symbol-hash` and equivalence function `eq?`, `eqv?`, `equal?`, or `symbol=?`.) `_key_` must be a symbol.

`symbol-hashtable-delete!` drops any association for `_key_` from `_hashtable_`.

[source,scheme,subs="quotes"]
----
(define ht (make-hashtable symbol-hash eq?))
(define k1 (gensym))
(define k2 (gensym))
(symbol-hashtable-set! ht k1 73)
(symbol-hashtable-contains? ht k1) ⇒ #t
(symbol-hashtable-delete! ht k1)
(symbol-hashtable-contains? ht k1) ⇒ #f
(symbol-hashtable-contains? ht k2) ⇒ #f
(symbol-hashtable-delete! ht k2)
----

=== Section 7.13. Record Types [[section_7.13.]]

[#objects:s141]
Chez Scheme extends the Revised^6^ Report's `define-record-type` syntax in one way, which is that it allows a generative record type to be declared explicitly as such (in a double-negative sort of way) by including a `nongenerative` clause with `#f` as the uid, i.e.:

[source,scheme,subs="quotes"]
----
(nongenerative #f)
----

This can be used in conjunction with the parameter `require-nongenerative-clause` to catch the accidental use of generative record types while avoiding spurious errors for record types that must be generative. Generative record types are rarely needed and are generally less efficient since a run-time representation of the type is created each time the `define-record-clause` is evaluated, rather than once at compile (expansion) time.

[#objects:s142]
[horizontal]
thread parameter:: `require-nongenerative-clause`
libraries:: `(chezscheme)`

This parameter holds a boolean value that determines whether `define-record-type` requires a nongenerative clause. The default value is `#f`. The lead-in above describes why one might want to set this to `#t`.

=== Section 7.14. Record Equality and Hashing [[section_7.14.]]

[#objects:s145]
By default, the `equal?` primitive compares record instances using `eq?`, i.e., it distinguishes non-eq? instances even if they are of the same type and have equal contents. A program can override this behavior for instances of a record type (and its subtypes that do not have their own equality procedures) by using `record-type-equal-procedure` to associate an equality procedure with the record-type descriptor (`_rtd_`) that describes the record type.

When comparing two eq? instances, `equal?` always returns `#t`. When comparing two non-eq? instances that share an equality procedure `_equal-proc_`, `equal?` uses `_equal-proc_` to compare the instances. Two instances `_x_` and `_y_` share an equality procedure if they inherit an equality procedure from the same point in the inheritance chain, i.e., if `(record-equal-procedure _x_ _y_)` returns a procedure (`_equal-proc_`) rather than `#f`. `_equal?_` passes `_equal-proc_` three arguments: the two instances plus a `_eql?_` procedure that should be used for recursive comparison of values within the two instances. Use of `_eql?_` for recursive comparison is necessary to allow comparison of potentially cyclic structure. When comparing two non-eq? instances that do not share an equality procedure, `equal?` returns `#f`.

A default equality procedure to be used for all record types (including opaque types) can be specified via the parameter `default-record-equal-procedure`. The default equality procedure is used only if neither instance's type has or inherits a type-specific record equality procedure.

[#objects:s151]
Similarly, when the `equal-hash` primitive hashes a record instance, it defaults to a value that is independent of the record type and contents of the instance. A program can override this behavior for instances of a record type by using `record-type-hash-procedure` to associate a hash procedure with the record-type descriptor (`_rtd_`) that describes the record type. The procedure `record-hash-procedure` can be used to find the hash procedure for a given record instance, following the inheritance chain. `_equal-hash_` passes the hash procedure two arguments: the instance plus a `_hash_` procedure that should be used for recursive hashing of values within the instance. Use of `_hash_` for recursive hashing is necessary to allow hashing of potentially cyclic structure and to make the hashing of shared structure more efficient.

A default hash procedure to be used for all record types (including opaque types) can be specified via the parameter `default-record-hash-procedure`. The default hash procedure is used only if an instance's type does not have or inherit a type-specific hash procedure.

The following example illustrates the setting of equality and hash procedures.

[source,scheme,subs="quotes"]
----
(define-record-type marble
  (nongenerative)
  (fields color quality))

(record-type-equal-procedure (record-type-descriptor marble)) ⇒ #f
(equal? (make-marble 'blue 'medium) (make-marble 'blue 'medium)) ⇒ #f
(equal? (make-marble 'blue 'medium) (make-marble 'blue 'high)) ⇒ #f

; Treat marbles as equal when they have the same color
(record-type-equal-procedure (record-type-descriptor marble)
  (lambda (m1 m2 eql?)
    (eql? (marble-color m1) (marble-color m2))))
(record-type-hash-procedure (record-type-descriptor marble)
  (lambda (m hash)
    (hash (marble-color m))))

(equal? (make-marble 'blue 'medium) (make-marble 'blue 'high)) ⇒ #t
(equal? (make-marble 'red 'high) (make-marble 'blue 'high)) ⇒ #f

(define ht (make-hashtable equal-hash equal?))
(hashtable-set! ht (make-marble 'blue 'medium) "glass")
(hashtable-ref ht (make-marble 'blue 'high) #f) ⇒ "glass"

(define-record-type shooter
  (nongenerative)
  (parent marble)
  (fields size))

(equal? (make-marble 'blue 'medium) (make-shooter 'blue 'large 17)) ⇒ #t
(equal? (make-shooter 'blue 'large 17) (make-marble 'blue 'medium)) ⇒ #t
(hashtable-ref ht (make-shooter 'blue 'high 17) #f) ⇒ "glass"
----

This example illustrates the application of equality and hash procedures to cyclic record structures.

[source,scheme,subs="quotes"]
----
(define-record-type node
  (nongenerative)
  (fields (mutable left) (mutable right)))

(record-type-equal-procedure (record-type-descriptor node)
  (lambda (x y e?)
    (and
      (e? (node-left x) (node-left y))
      (e? (node-right x) (node-right y)))))
(record-type-hash-procedure (record-type-descriptor node)
  (lambda (x hash)
    (+ (hash (node-left x)) (hash (node-right x)) 23)))

(define graph1
  (let ([x (make-node "a" (make-node #f "b"))])
    (node-left-set! (node-right x) x)
    x))
(define graph2
  (let ([x (make-node "a" (make-node (make-node "a" #f) "b"))])
    (node-right-set! (node-left (node-right x)) (node-right x))
    x))
(define graph3
  (let ([x (make-node "a" (make-node #f "c"))])
    (node-left-set! (node-right x) x)
    x))

(equal? graph1 graph2) ⇒ #t
(equal? graph1 graph3) ⇒ #f
(equal? graph2 graph3) ⇒ #f

(define h (make-hashtable equal-hash equal?))
(hashtable-set! h graph1 #t)
(hashtable-ref h graph1 #f) ⇒ #t
(hashtable-ref h graph2 #f) ⇒ #t
(hashtable-ref h graph3 #f) ⇒ #f
----

[#objects:s156]
[horizontal]
procedure:: `(record-type-equal-procedure _rtd_ _equal-proc_)`
returns:: unspecified
procedure:: `(record-type-equal-procedure _rtd_)`
returns:: equality procedure associated with `_rtd_`, if any, otherwise `#f`
libraries:: `(chezscheme)`

In the first form, `_equal-proc_` must be a procedure or `#f`. If `_equal-proc_` is a procedure, a new association between `_rtd_` and `_equal-proc_` is established, replacing any existing such association. If `_equal-proc_` is `#f`, any existing association between `_rtd_` and an equality procedure is dropped.

In the second form, `record-type-equal-procedure` returns the equality procedure associated with `_rtd_`, if any, otherwise `#f`.

When changing a record type's equality procedure, the record type's hash procedure, if any, should be updated if necessary to maintain the property that it produces the same hash value for any two instances the equality procedure considers equal.

[#objects:s157]
[horizontal]
procedure:: `(record-equal-procedure _record~1~_ _record~2~_)`
returns:: the shared equality procedure for `_record~1~_` and `_record~2~_`, if there is one, otherwise `#f`
libraries:: `(chezscheme)`

`record-equal-procedure` traverses the inheritance chains for both record instances in an attempt to find the most specific type for each that is associated with an equality procedure, if any. If such type is found and is the same for both instances, the equality procedure associated with the type is returned. Otherwise, `#f` is returned.

[#objects:s158]
[horizontal]
procedure:: `(record-type-hash-procedure _rtd_ _hash-proc_)`
returns:: unspecified
procedure:: `(record-type-hash-procedure _rtd_)`
returns:: hash procedure associated with `_rtd_`, if any, otherwise `#f`
libraries:: `(chezscheme)`

In the first form, `_hash-proc_` must be a procedure or `#f`. If `_hash-proc_` is a procedure, a new association between `_rtd_` and `_hash-proc_` is established, replacing any existing such association. If `_hash-proc_` is `#f`, any existing association between `_rtd_` and a hash procedure is dropped.

In the second form, `record-type-hash-procedure` returns the hash procedure associated with `_rtd_`, if any, otherwise `#f`.

The procedure `_hash-proc_` should accept two arguments, the instance for which it should compute a hash value and a hash procedure to use to compute hash values for arbitrary fields of the instance, and it return a nonnegative exact integer. A record type's hash procedure should produce the same hash value for any two instances the record type's equality procedure considers equal.

[#objects:s159]
[horizontal]
procedure:: `(record-hash-procedure _record_)`
returns:: the hash procedure for `_record_`, if there is one, otherwise `#f`
libraries:: `(chezscheme)`

`record-hash-procedure` traverses the inheritance chain for the record instance in an attempt to find the most specific type that is associated with a hash procedure, if any. If such type is found, the hash procedure associated with the type is returned. Otherwise, `#f` is returned.

[#objects:s160]
[horizontal]
thread parameter:: `default-record-equal-procedure`
libraries:: `(chezscheme)`

This parameter determines how two record instances are compared by `equal?` if neither has a type-specific equality procedure. When the parameter has the value `#f` (the default), `equal?` compares the instances with `eq?`, i.e., there is no attempt at determining structural equivalence. Otherwise, the parameter's value must be a procedure, and `equal?` invokes that procedure to compare the instances, passing it three arguments: the two instances and a procedure that should be used to recursively compare arbitrary values within the instances.

[#objects:s161]
[horizontal]
thread parameter:: `default-record-hash-procedure`
libraries:: `(chezscheme)`

This parameter determines the hash procedure used when `equal-hash` is called on a record instance and the instance does not have a type-specific hash procedure. When the parameter has the value `#f` (the default), `equal-hash` returns a value that is independent of the record type and contents of the instance. Otherwise, the parameter's value must be a procedure, and `equal-hash` invokes the procedure to compute the instance's hash value, passing it the record instance and a procedure to invoke to recursively compute hash values for arbitrary values contained within the record. The procedure should return a nonnegative exact integer, and the return value should be the same for any two instances the default equal procedure considers equivalent.

=== Section 7.15. Legacy Record Types [[section_7.15.]]

[#objects:s164]
In addition to the Revised^6^ Report record-type creation and definition mechanisms, which are described in link:../../the-scheme-programming-language-4th/en/index.html#chp_9[Chapter 9] of _The Scheme Programming Language, 4th Edition_, _Chez Scheme_ continues to support pre-R6RS mechanisms for creating new data types, or _record types_, with fixed sets of named fields. Many of the procedures described in this section are available only when imported from the `(chezscheme csv7)` library.

Code intended to be portable should use the R6RS mechanism instead.

Records may be defined via the `define-record` syntactic form or via the `make-record-type` procedure. The underlying representation of records and record-type descriptors is the same for the Revised^6^ Report mechanism and the alternative mechanism. Record types created by one can be used as parent record types for the other via the procedural mechanisms, though not via the syntactic mechanisms.

The syntactic (`define-record`) interface is the most commonly used interface. Each `define-record` form defines a constructor procedure for records of the new type, a type predicate that returns true only for records of the new type, an access procedure for each field, and an assignment procedure for each mutable field. For example,

[source,scheme,subs="quotes"]
----
(define-record point (x y))
----

creates a new `point` record type with two fields, `x` and `y`, and defines the following procedures:

[%autowidth,grid=none,frame=none]
|===

| `(make-point _x_ _y_)` 	| constructor
| `(point? _obj_)` 	| predicate
| `(point-x _p_)` 	| accessor for field `x`
| `(point-y _p_)` 	| accessor for field `y`
| `(set-point-x! _p_ _obj_)` 	| mutator for field `x`
| `(set-point-y! _p_ _obj_)` 	| mutator for field `y`

|===

The names of these procedures follow a regular naming convention by default, but the programmer can override the defaults if desired. `define-record` allows the programmer to control which fields are arguments to the generated constructor procedure and which are explicitly initialized by the constructor procedure. Fields are mutable by default, but may be declared immutable. Fields can generally contain any Scheme value, but the internal representation of each field may be specified, which places implicit constraints on the type of value that may be stored there. These customization options are covered in the formal description of `define-record` later in this section.

The procedural (`make-record-type`) interface may be used to implement interpreters that must handle `define-record` forms. Each call to `make-record-type` returns a _record-type descriptor_ representing the record type. Using this record-type descriptor, programs may generate constructors, type predicates, field accessors, and field mutators dynamically. The following code demonstrates how the procedural interface might be used to create a similar `point` record type and associated definitions.

[source,scheme,subs="quotes"]
----
(define point (make-record-type "point" '(x y)))
(define make-point (record-constructor point))
(define point? (record-predicate point))
(define point-x (record-field-accessor point 'x))
(define point-y (record-field-accessor point 'y))
(define set-point-x! (record-field-mutator point 'x))
(define set-point-y! (record-field-mutator point 'y))
----

The procedural interface is more flexible than the syntactic interface, but this flexibility can lead to less readable programs and compromises the compiler's ability to generate efficient code. Programmers should use the syntactic interface whenever it suffices.

A record-type descriptor may also be extracted from an instance of a record type, whether the record type was produced by `define-record` or `make-record-type`, and the extracted descriptor may also be used to produce constructors, predicates, accessors, and mutators, with a few limitations noted in the description of `record-type-descriptor` below. This is a powerful feature that permits the coding of portable printers and object inspectors. For example, the printer employs this feature in its default record printer, and the inspector uses it to allow inspection and mutation of system- and user-defined records during debugging.

[#objects:s166]
A parent record may be specified in the `define-record` syntax or as an optional argument to `make-record-type`. A new record inherits the parent record's fields, and each instance of the new record type is considered to be an instance of the parent type as well, so that accessors and mutators for the parent type may be used on instances of the new type.

[#objects:s168]
Record type definitions may be classified as either generative or nongenerative. A new type results for each _generative_ record definition, while only one type results for all occurrences of a given _nongenerative_ record definition. This distinction is important semantically since record accessors and setters are applicable only to objects with the same type.

Syntactic (`define-record`) record definitions are _expand-time generative_ by default, which means that a new record is created when the code is expanded. Expansion happens once for each form prior to compilation or interpretation, as when it is entered interactively, loaded from source, or compiled by `compile-file`. As a result, multiple evaluations of a single `define-record` form, e.g., in the body of a procedure called multiple times, always produce the same record type.

Separate `define-record` forms usually produce different types, even if the forms are textually identical. The only exception occurs when the name of a record is specified as a generated symbol, or _gensym_ (<<desc:gensym,page 152>>). Multiple copies of a record definition whose name is given by a gensym always produce the same record type; i.e., such definitions are nongenerative. Each copy of the record definition must contain the same fields and field modifiers in the same order; an exception is raised with condition-type `&assertion` when two differing record types with the same generated name are loaded into the same Scheme process.

Procedural (`make-record-type`) record definitions are _run-time generative_ by default. That is, each call to `make-record-type` usually produces a new record type. As with the syntactic interface, the only exception occurs when the name of the record is specified as a gensym, in which case the record type is fully nongenerative.

By default, a record is printed with the syntax

[source,scheme,subs="quotes"]
----
#[_type-name_ _field_ ...]
----

where `_field_ \...` are the printed representations of the contents of the fields of the record, and `_type-name_` is a generated symbol, or _gensym_ (<<desc:gensym,page 152>>), that uniquely identifies the record type. For nongenerative records, `_type-name_` is the gensym provided by the program. Otherwise, it is a gensym whose "pretty" name (<<desc:gensym,page 152>>) is the name given to the record by `define-record` or `make-record-type`.

The default printing of records of a given type may be overridden with `record-writer`.

The default syntax may be used as input to the reader as well, as long as the corresponding record type has already been defined in the Scheme session in which the read occurs. The parameter `record-reader` may be used to specify a different name to be recognized by the reader in place of the generated name. Specifying a different name in this manner also changes the name used when the record is printed. This reader extension is disabled in an input stream after `\#!r6rs` has been seen by the reader, unless `#!chezscheme` has been seen more recently.

The mark (`\#_n_=`) and reference (`#_n_#`) syntaxes may be used within the record syntax, with the result of creating shared or cyclic structure as desired. All cycles must be resolvable, however, without mutation of an immutable record field. That is, any cycle must contain at least one pointer through a mutable field, whether it is a mutable record field or a mutable field of a built-in object type such as a pair or vector.

When the parameter `print-record` is set to `#f`, records are printed using the simpler syntax

[source,scheme,subs="quotes"]
----
#&lt;record of type _name_&gt;
----

where `_name_` is the "pretty" name of the record (not the full gensym) or the reader name first assigned to the record type.

[#objects:s172]
[horizontal]
syntax:: `(define-record _name_ (_fld~1~_ \...) \((_fld~2~_ _init_) \...) (_opt_ \...))`
syntax:: `(define-record _name_ _parent_ (_fld~1~_ \...) \((_fld~2~_ _init_) \...) (_opt_ \...))`
returns:: unspecified
libraries:: `(chezscheme)`

A `define-record` form is a definition and may appear anywhere and only where other definitions may appear.

`define-record` creates a new record type containing a specified set of named fields and defines a set of procedures for creating and manipulating instances of the record type.

`_name_` must be an identifier. If `_name_` is a generated symbol (gensym), the record definition is _nongenerative_, otherwise it is _expand-time generative_. (See the discussion of generativity earlier in this section.)

Each `_fld_` must be an identifier `_field-name_`, or it must take the form

[source,scheme,subs="quotes"]
----
(_class_ _type_ _field-name_)
----

where `_class_` and `_type_` are optional and `_field-name_` is an identifier. `_class_`, if present, must be the keyword `immutable` or the keyword `mutable`. If the `immutable` class specifier is present, the field is immutable; otherwise, the field is mutable. `_type_`, if present, specifies how the field is represented, as described below.

[#record-field-types]
[%autowidth,grid=none,frame=none]
|===

| `ptr` 	| any Scheme object
| `scheme-object` 	| same as `ptr`
| `int` 	| a C `int`
| `unsigned` 	| a C `unsigned int`
| `short` 	| a C `short`
| `unsigned-short` 	| a C `unsigned short`
| `long` 	| a C `long`
| `unsigned-long` 	| a C `unsigned long`
| `iptr` 	| a signed integer the size of a `ptr`
| `uptr` 	| an unsigned integer the size of a `ptr`
| `float` 	| a C `float`
| `double` 	| a C `double`
| `integer-8` 	| an eight-bit signed integer
| `unsigned-8` 	| an eight-bit unsigned integer
| `integer-16` 	| a 16-bit signed integer
| `unsigned-16` 	| a 16-bit unsigned integer
| `integer-32` 	| a 32-bit signed integer
| `unsigned-32` 	| a 32-bit unsigned integer
| `integer-64` 	| a 64-bit signed integer
| `unsigned-64` 	| a 64-bit unsigned integer
| `single-float` 	| a 32-bit single floating point number
| `double-float` 	| a 64-bit double floating point number

|===

If a type is specified, the field can contain objects only of the specified type. If no type is specified, the field is of type `ptr`, meaning that it can contain any Scheme object.

The field identifiers name the fields of the record. The values of the _n_ fields described by `_fld~1~_ \...` are specified by the _n_ arguments to the generated constructor procedure. The values of the remaining fields, `_fld~2~_ \...`, are given by the corresponding expressions, `_init_ \...`. Each `_init_` is evaluated within the scope of the set of field names given by `_fld~1~_ \...` and each field in `_fld~2~_ \...` that precedes it, as if within a `let*` expression. Each of these field names is bound to the value of the corresponding field during initialization.

[#objects:s174]
If `_parent_` is present, the record type named by `_parent_` is the parent of the record. The new record type inherits each of the parent record's fields, and records of the new type are considered records of the parent type. If `_parent_` is not present, the parent record type is a base record type with no fields.

The following procedures are defined by `define-record`:

- a constructor procedure whose name is `make-_name_`,

- a type predicate whose name is `_name_?`,

- an access procedure whose name is `_name_-_fieldname_` for each noninherited field, and

- an assignment procedure whose name is `set-_name_-_fieldname_!` for each noninherited mutable field.

If no parent record type is specified, the constructor behaves as if defined as

[source,scheme,subs="quotes"]
----
(define make-_name_
  (lambda (_id~1~_ ...)
    (let* ([_id~2~_ _init_] ...)
      _body_)))
----

where `_id~1~_ \...` are the names of the fields defined by `_fld~1~_ \...`, `_id~2~_ \...` are the names of the fields defined by `_fld~2~_ \...`, and `_body_` builds the record from the values of the identifiers `_id~1~_ \...` and `_id~2~_ \...`.

If a parent record type is specified, the parent arguments appear first, and the parent fields are inserted into the record before the child fields.

The options `_opt_ \...` control the selection of names of the generated constructor, predicate, accessors, and mutators.

[source,scheme,subs="quotes"]
----
(constructor _id_)
(predicate _id_)
(prefix _string_)
----

The option `(constructor _id_)` causes the generated constructor's name to be `_id_` rather than `make-_name_`. The option `(predicate _id_)` likewise causes the generated predicate's name to be `_id_` rather than `_name_?`. The option `(prefix _string_)` determines the prefix to be used in the generated accessor and mutator names in place of `_name_-`.

If no options are needed, the third subexpression, `(_opt_ \...)`, may be omitted. If no options and no fields other than those initialized by the arguments to the constructor procedure are needed, both the second and third subexpressions may be omitted. If options are specified, the second subexpression must be present, even if it contains no field specifiers.

Here is a simple example with no inheritance and no options.

[source,scheme,subs="quotes"]
----
(define-record marble (color quality))
(define x (make-marble 'blue 'medium))
(marble? x) ⇒ #t
(pair? x) ⇒ #f
(vector? x) ⇒ #f
(marble-color x) ⇒ blue
(marble-quality x) ⇒ medium
(set-marble-quality! x 'low)
(marble-quality x) ⇒ low

(define-record marble ((immutable color) (mutable quality))
  (((mutable shape) (if (eq? quality 'high) 'round 'unknown))))
(marble-shape (make-marble 'blue 'high)) ⇒ round
(marble-shape (make-marble 'blue 'low)) ⇒ unknown
(define x (make-marble 'blue 'high))
(set-marble-quality! x 'low)
(marble-shape x) ⇒ round
(set-marble-shape! x 'half-round)
(marble-shape x) ⇒ half-round
----

The following example illustrates inheritance.

[source,scheme,subs="quotes"]
----
(define-record shape (x y))
(define-record point shape ())
(define-record circle shape (radius))

(define a (make-point 7 -3))
(shape? a) ⇒ #t
(point? a) ⇒ #t
(circle? a) ⇒ #f

(shape-x a) ⇒ 7
(set-shape-y! a (- (shape-y a) 1))
(shape-y a) ⇒ -4

(define b (make-circle 7 -3 1))
(shape? b) ⇒ #t
(point? b) ⇒ #f
(circle? b) ⇒ #t

(circle-radius b) ⇒ 1
(circle-radius a) ⇒ _exception: not of type circle_

(define c (make-shape 0 0))
(shape? c) ⇒ #t
(point? c) ⇒ #f
(circle? c) ⇒ #f
----

This example demonstrates the use of options:

[source,scheme,subs="quotes"]
----
(define-record pair (car cdr)
  ()
  ((constructor cons)
   (prefix "")))

(define x (cons 'a 'b))
(car x) ⇒ a
(cdr x) ⇒ b
(pair? x) ⇒ \#t

(pair? '(a b c)) ⇒ #f
x ⇒ #[#{pair bdhavk1bwafxyss1-a} a b]
----

This example illustrates the use a specified reader name, immutable fields, and the graph mark and reference syntax.

[source,scheme,subs="quotes"]
----
(define-record triple ((immutable x1) (mutable x2) (immutable x3)))
(record-reader 'triple (type-descriptor triple))

(let ([t '\#[triple #1=(1 2) (3 4) #1#]])
  (eq? (triple-x1 t) (triple-x3 t))) ⇒ \#t
(let ([x '(#1=(1 2) . #[triple #1# b c])])
  (eq? (car x) (triple-x1 (cdr x)))) ⇒ \#t
(let ([t #[triple #1# (3 4) \#1=(1 2)]])
  (eq? (triple-x1 t) (triple-x3 t))) ⇒ #t
(let ([t '#1=#[triple a \#1# c]])
  (eq? t (triple-x2 t))) ⇒ \#t
(let ([t '#1=(#[triple \#1# b \#1#])])
  (and (eq? t (triple-x1 (car t)))
       (eq? t (triple-x1 (car t))))) ⇒ #t
----

Cycles established with the mark and reference syntax can be resolved only if a mutable record field or mutable location of some other object is involved the cycle, as in the last two examples above. An exception is raised with condition type `&lexical` if only immutable fields are involved.

[source,scheme,subs="quotes"]
----
'\#1=#[triple \#1# (3 4) \#1#] ⇒ _exception_
----

[#objects:s175]
The following example demonstrates the use of nongenerative record definitions.

[source,scheme,subs="quotes"]
----
(module A (point-disp)
  (define-record #{point bdhavk1bwafxyss1-b} (x y))
  (define square (lambda (x) (* x x)))
  (define point-disp
    (lambda (p1 p2)
      (sqrt (+ (square (- (point-x p1) (point-x p2)))
               (square (- (point-y p1) (point-y p2))))))))

(module B (base-disp)
  (define-record #{point bdhavk1bwafxyss1-b} (x y))
  (import A)
  (define base-disp
    (lambda (p)
      (point-disp (make-point 0 0) p))))

(let ()
  (import B)
  (define-record #{point bdhavk1bwafxyss1-b} (x y))
  (base-disp (make-point 3 4))) ⇒ 5
----

This works even if the different program components are loaded from different source files or are compiled separately and loaded from different object files.

[#objects:s176]
[horizontal]
syntax:: `predicate`
syntax:: `prefix`
syntax:: `constructor`
libraries:: `(chezscheme)`

[#objects:s177]
[#objects:s178]
These identifiers are auxiliary keywords for `define-record`. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords. `mutable` and `immutable` are also auxiliary keywords for `define-record`, shared with the Revised^6^ Report `define-record-type`.

[#objects:s179]
[horizontal]
syntax:: `(type-descriptor _name_)`
returns:: the record-type descriptor associated with `_name_`
libraries:: `(chezscheme)`

`_name_` must name a record type defined by `define-record` or `define-record-type`.

This form is equivalent to the Revised^6^ Report `record-type-descriptor` form.

The record-type descriptor is useful for overriding the default read and write syntax using `record-reader` and `record-writer` and may also be used with the procedural interface routines described later in this section.

[source,scheme,subs="quotes"]
----
(define-record frob ())
(type-descriptor frob) ⇒ #&lt;record type frob&gt;
----

[#objects:s180]
[horizontal]
procedure:: `(record-reader _name_)`
returns:: the record-type descriptor associated with `_name_`
procedure:: `(record-reader _rtd_)`
returns:: the first name associated with `_rtd_`
procedure:: `(record-reader _name_ _rtd_)`
returns:: unspecified
procedure:: `(record-reader _name_ #f)`
returns:: unspecified
procedure:: `(record-reader _rtd_ #f)`
returns:: unspecified
libraries:: `(chezscheme)`

`_name_` must be a symbol, and `_rtd_` must be a record-type descriptor.

With one argument, `record-reader` is used to retrieve the record type associated with a name or name associated with a record type. If no association has been created, `record-reader` returns `#f`

With arguments `_name_` and `_rtd_`, `record-reader` registers `_rtd_` as the record-type descriptor to be used whenever the `read` procedure encounters a record named by `_name_` and printed in the default record syntax.

With arguments `_name_` and `#f`, `record-reader` removes any association for `_name_` to a record-type descriptor. Similarly, with arguments `_rtd_` and `#f`, `record-reader` removes any association for `_rtd_` to a name.

[source,scheme,subs="quotes"]
----
(define-record marble (color quality))
(define m (make-marble 'blue 'perfect))
m ⇒ \#[#{marble bdhavk1bwafxyss1-c} blue perfect]

(record-reader (type-descriptor marble)) ⇒ \#f
(record-reader 'marble) ⇒ #f

(record-reader 'marble (type-descriptor marble))
(marble-color '#[marble red miserable]) ⇒ red

(record-reader (type-descriptor marble)) ⇒ marble
(record-reader 'marble) ⇒ #&lt;record type marble&gt;

(record-reader (type-descriptor marble) #f)
(record-reader (type-descriptor marble)) ⇒ #f
(record-reader 'marble) ⇒ #f

(record-reader 'marble (type-descriptor marble))
(record-reader 'marble #f)
(record-reader (type-descriptor marble)) ⇒ #f
(record-reader 'marble) ⇒ #f
----

The introduction of a record reader also changes the default printing of records. The printer always chooses the reader name first assigned to the record, if any, in place of the unique record name, as this continuation of the example above demonstrates.

[source,scheme,subs="quotes"]
----
(record-reader 'marble (type-descriptor marble))
(make-marble 'pink 'splendid) ⇒ #[marble pink splendid]
----

[#objects:s181]
[horizontal]
procedure:: `(record-writer _rtd_)`
returns:: the record writer associated with `_rtd_`
procedure:: `(record-writer _rtd_ _procedure_)`
returns:: unspecified
libraries:: `(chezscheme)`

`_rtd_` must be a record-type descriptor, and `_procedure_` should accept three arguments, as described below.

When passed only one argument, `record-writer` returns the record writer associated with `_rtd_`, which is initially the default record writer for all records. The default print method prints all records in a uniform syntax that includes the generated name for the record and the values of each of the fields, as described in the introduction to this section.

When passed two arguments, `record-writer` establishes a new association between `_rtd_` and `_procedure_` so that `_procedure_` will be used by the printer in place of the default printer for records of the given type. The printer passes `_procedure_` three arguments: the record `_r_`, a port `_p_`, and a procedure `_wr_` that should be used to write out the values of arbitrary Scheme objects that the print method chooses to include in the printed representation of the record, e.g., values of the record's fields.

[source,scheme,subs="quotes"]
----
(define-record marble (color quality))
(define m (make-marble 'blue 'medium))

m ⇒ \#[#{marble bdhavk1bwafxyss1-d} blue medium]

(record-writer (type-descriptor marble)
  (lambda (r p wr)
    (display "#<" p)
    (wr (marble-quality r) p)
    (display " quality " p)
    (wr (marble-color r) p)
    (display " marble>" p)))

m ⇒ #&lt;medium quality blue marble&gt;
----

The record writer is used only when `print-record` is true (the default). When the parameter `print-record` is set to `#f`, records are printed using a compressed syntax that identifies only the type of record.

[source,scheme,subs="quotes"]
----
(parameterize ([print-record \#f])
  (format "~s" m)) ⇒ "#&lt;record of type marble&gt;"
----

A print method may be called more than once during the printing of a single record to support cycle detection and graph printing (see `print-graph`), so print methods that perform side effects other than printing to the given port are discouraged. Whenever a print method is called more than once during the printing of a single record, in all but one call, a generic "bit sink" port is used to suppress output automatically so that only one copy of the object appears on the actual port. In order to avoid confusing the cycle detection and graph printing algorithms, a print method should always produce the same printed representation for each object. Furthermore, a print method should normally use the supplied procedure `_wr_` to print subobjects, though atomic values, such as strings or numbers, may be printed by direct calls to `display` or `write` or by other means.

[source,scheme,subs="quotes"]
----
(let ()
  (define-record ref () ((contents 'nothing)))
  (record-writer (type-descriptor ref)
    (lambda (r p wr)
      (display "<" p)
      (wr (ref-contents r) p)
      (display ">" p)))
  (let ([ref-lexive (make-ref)])
    (set-ref-contents! ref-lexive ref-lexive)
    ref-lexive)) ⇒ \#0=&lt;#0#&gt;
----

Print methods need not be concerned with handling nonfalse values of the parameters `print-level`. The printer handles `print-level` automatically even when user-defined print procedures are used. Since records typically contain a small, fixed number of fields, it is usually possible to ignore nonfalse values of `print-length` as well.

[source,scheme,subs="quotes"]
----
(print-level 3)
(let ()
  (define-record ref () ((contents 'nothing)))
  (record-writer (type-descriptor ref)
    (lambda (r p wr)
      (display "<" p)
      (wr (ref-contents r) p)
      (display ">" p)))
  (let ([ref-lexive (make-ref)])
    (set-ref-contents! ref-lexive ref-lexive)
    ref-lexive)) ⇒ &lt;&lt;&lt;&lt;#[...]&gt;&gt;&gt;&gt;
----

[#objects:s185]
[horizontal]
thread parameter:: `print-record`
libraries:: `(chezscheme)`

This parameter controls the printing of records. If set to true (the default) the record writer associated with a record type is used to print records of that type. If set to false, all records are printed with the syntax `#<record of type _name_>`, where `_name_` is the name of the record type as returned by `record-type-name`.

[#objects:s186]
[horizontal]
procedure:: `(make-record-type _type-name_ _fields_)`
procedure:: `(make-record-type _parent-rtd_ _type-name_ _fields_)`
returns:: a record-type descriptor for a new record type
libraries:: `(chezscheme)`

`make-record-type` creates a new data type and returns a record-type descriptor, a value representing the new data type. The new type is disjoint from all others.

If present, `_parent-rtd_` must be a record-type descriptor.

`_type-name_` must be a string or gensym. If `_type-name_` is a string, a new record type is generated. If `_type-name_` is a gensym, a new record type is generated only if one with the same gensym has not already been defined. If one has already been defined, the parent and fields must be identical to those of the existing record type, and the existing record type is used. If the parent and fields are not identical, an exception is raised with condition-type `&assertion`.

`_fields_` must be a list of field descriptors, each of which describes one field of instances of the new record type. A field descriptor is either a symbol or a list in the following form:

[source,scheme,subs="quotes"]
----
(_class_ _type_ _field-name_)
----

where `_class_` and `_type_` are optional. `_field-name_` must be a symbol. `_class_`, if present, must be the symbol `immutable` or the symbol `mutable`. If the `immutable` class-specifier is present, the field is immutable; otherwise, the field is mutable. `_type_`, if present, specifies how the field is represented. The types are the same as those given in the description of `define-record` on <<record-field-types,page 175>>.

If a type is specified, the field can contain objects only of the specified type. If no type is specified, the field is of type `ptr`, meaning that it can contain any Scheme object.

The behavior of a program that modifies the string `_type-name_` or the list `_fields_` or any of its sublists is unspecified.

The record-type descriptor may be passed as an argument to any of the Revised^6^ Report procedures

- `record-constructor`,
- `record-predicate`,
- `record-accessor`, and
- `record-mutator`,

or to the _Chez Scheme_ variants

- `record-constructor`,
- `record-field-accessor`, and
- `record-field-mutator`

to obtain procedures for creating and manipulating records of the new type.

[source,scheme,subs="quotes"]
----
(define marble
  (make-record-type "marble"
    '(color quality)
    (lambda (r p wr)
      (display "#<" p)
      (wr (marble-quality r) p)
      (display " quality " p)
      (wr (marble-color r) p)
      (display " marble>" p))))
(define make-marble
  (record-constructor marble))
(define marble?
  (record-predicate marble))
(define marble-color
  (record-field-accessor marble 'color))
(define marble-quality
  (record-field-accessor marble 'quality))
(define set-marble-quality!
  (record-field-mutator marble 'quality))
(define x (make-marble 'blue 'high))
(marble? x) ⇒ #t
(marble-quality x) ⇒ high
(set-marble-quality! x 'low)
(marble-quality x) ⇒ low
x ⇒ #&lt;low quality blue marble&gt;
----

The order in which the fields appear in `_fields_` is important. While field names are generally distinct, it is permissible for one field name to be the same as another in the list of fields or the same as an inherited name. In this case, field ordinals must be used to select fields in calls to `record-field-accessor` and `record-field-mutator`. Ordinals range from zero through one less than the number of fields. Parent fields come first, if any, followed by the fields in `_fields_`, in the order given.

[source,scheme,subs="quotes"]
----
(define r1 (make-record-type "r1" '(t t)))
(define r2 (make-record-type r1 "r2" '(t)))
(define r3 (make-record-type r2 "r3" '(t t t)))

(define x ((record-constructor r3) 'a 'b 'c 'd 'e 'f))
((record-field-accessor r3 0) x) ⇒ a
((record-field-accessor r3 2) x) ⇒ c
((record-field-accessor r3 4) x) ⇒ e
((record-field-accessor r3 't) x) ⇒ _unspecified_
----

[#objects:s189]
[horizontal]
procedure:: `(record-constructor _rcd_)`
procedure:: `(record-constructor _rtd_)`
returns:: a constructor for records of the type represented by `_rtd_`
libraries:: `(chezscheme)`

Like the Revised^6^ Report version of this procedure, this procedure may be passed a record-constructor descriptor, `_rcd_`, which determines the behavior of the constructor. It may also be passed a record-type descriptor, `_rtd_`, in which case the constructor accepts as many arguments as there are fields in the record; these arguments are the initial values of the fields in the order given when the record-type descriptor was created.

[#objects:s190]
[horizontal]
procedure:: `(record-field-accessor _rtd_ _field-id_)`
returns:: an accessor for the identified field
libraries:: `(chezscheme csv7)`

`_rtd_` must be a record-type descriptor, `_field-id_` must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type. The specified field must be accessible.

The generated accessor expects one argument, which must be a record of the type represented by `_rtd_`. It returns the contents of the specified field of the record.

[#objects:s191]
[horizontal]
procedure:: `(record-field-accessible? _rtd_ _field-id_)`
returns:: `#t` if the specified field is accessible, otherwise `#f`
libraries:: `(chezscheme csv7)`

`_rtd_` must be a record-type descriptor, `_field-id_` must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type.

The compiler is free to eliminate a record field if it can prove that the field is not accessed. In making this determination, the compiler is free to ignore the possibility that an accessor might be created from a record-type descriptor obtained by calling `record-type-descriptor` on an instance of the record type.

[#objects:s192]
[horizontal]
procedure:: `(record-field-mutator _rtd_ _field-id_)`
returns:: a mutator for the identified field
libraries:: `(chezscheme csv7)`

`_rtd_` must be a record-type descriptor, `_field-id_` must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type. The specified field must be mutable.

The mutator expects two arguments, `_r_` and `_obj_`. `_r_` must be a record of the type represented by `_rtd_`. `_obj_` must be a value that is compatible with the type declared for the specified field when the record-type descriptor was created. `_obj_` is stored in the specified field of the record.

[#objects:s193]
[horizontal]
procedure:: `(record-field-mutable? _rtd_ _field-id_)`
returns:: `#t` if the specified field is mutable, otherwise `#f`
libraries:: `(chezscheme csv7)`

`_rtd_` must be a record-type descriptor, `_field-id_` must be a symbol or field ordinal, i.e., a nonnegative exact integer less than the number of fields of the given record type.

Any field declared immutable is immutable. In addition, the compiler is free to treat a field as immutable if it can prove that the field is never assigned. In making this determination, the compiler is free to ignore the possibility that a mutator might be created from a record-type descriptor obtained by calling `record-type-descriptor` on an instance of the record type.

[#objects:s194]
[horizontal]
procedure:: `(record-type-name _rtd_)`
returns:: the name of the record-type represented by `_rtd_`
libraries:: `(chezscheme csv7)`

`_rtd_` must be a record-type descriptor.

The name is a always a string. If a gensym is provided as the record-type name in a `define-record` form or `make-record-type` call, the result is the "pretty" name of the gensym (see <<section_7.9.,Section 7.9>>).

[source,scheme,subs="quotes"]
----
(record-type-name (make-record-type "empty" '())) ⇒ "empty"

(define-record #{point bdhavk1bwafxyss1-b} (x y))
(define p (type-descriptor #{point bdhavk1bwafxyss1-b}))
(record-type-name p) ⇒ "point"
----

[#objects:s195]
[horizontal]
procedure:: `(record-type-symbol _rtd_)`
returns:: the generated symbol associated with `_rtd_`
libraries:: `(chezscheme csv7)`

`_rtd_` must be a record-type descriptor.

[source,scheme,subs="quotes"]
----
(define e (make-record-type "empty" '()))
(record-type-symbol e) ⇒ #{empty bdhavk1bwafxyss1-e}

(define-record #{point bdhavk1bwafxyss1-b} (x y))
(define p (type-descriptor #{point bdhavk1bwafxyss1-b}))
(record-type-symbol p) ⇒ #{point bdhavk1bwafxyss1-b}
----

[#objects:s196]
[horizontal]
procedure:: `(record-type-field-names _rtd_)`
returns:: a list of field names of the type represented by `_rtd_`
libraries:: `(chezscheme csv7)`

`_rtd_` must be a record-type descriptor. The field names are symbols.

[source,scheme,subs="quotes"]
----
(define-record triple ((immutable x1) (mutable x2) (immutable x3)))
(record-type-field-names (type-descriptor triple)) ⇒ (x1 x2 x3)
----

[#objects:s197]
[horizontal]
procedure:: `(record-type-field-decls _rtd_)`
returns:: a list of field declarations of the type represented by `_rtd_`
libraries:: `(chezscheme csv7)`

`_rtd_` must be a record-type descriptor. Each field declaration has the following form:

[source,scheme,subs="quotes"]
----
(_class_ _type_ _field-name_)
----

where `_class_`, `_type_`, and `_field-name_` are as described under `make-record-type`.

[source,scheme,subs="quotes"]
----
(define-record shape (x y))
(define-record circle shape (radius))

(record-type-field-decls
  (type-descriptor circle)) ⇒ ((mutable ptr x)
                                (mutable ptr y)
                                (mutable ptr radius))
----

[#objects:s198]
[horizontal]
procedure:: `(record? _obj_)`
returns:: `#t` if `_obj_` is a record, otherwise `#f`
procedure:: `(record? _obj_ _rtd_)`
returns:: `#t` if `_obj_` is a record of the given type, otherwise `#f`
libraries:: `(chezscheme)`

If present, `_rtd_` must be a record-type descriptor.

A record is "of the given type" if it is an instance of the record type or one of its ancestors. The predicate generated by `record-predicate` for a record-type descriptor `_rtd_` is equivalent to the following.

[source,scheme,subs="quotes"]
----
(lambda (x) (record? x _rtd_))
----

[#objects:s199]
[horizontal]
procedure:: `(record-type-descriptor _rec_)`
returns:: the record-type descriptor of `_rec_`
libraries:: `(chezscheme csv7)`

`_rec_` must be a record. This procedure is intended for use in the definition of portable printers and debuggers. For records created with `make-record-type`, it may not be the same as the descriptor returned by `make-record-type`. See the comments about field accessibility and mutability under `record-field-accessible?` and `record-field-mutable?` above.

This procedure is equivalent to the Revised^6^ Report `record-rtd` procedure.

[source,scheme,subs="quotes"]
----
(define rtd (make-record-type "frob" '(blit blat)))
rtd ⇒ #&lt;record type frob&gt;
(define x ((record-constructor rtd) 1 2))
(record-type-descriptor x) ⇒ #&lt;record type frob&gt;
(eq? (record-type-descriptor x) rtd) ⇒ _unspecified_
----

=== Section 7.16. Procedures [[section_7.16.]]

[#objects:s200]
[horizontal]
procedure:: `(procedure-arity-mask _proc_)`
returns:: an exact integer bitmask identifying the accepted argument counts of `_proc_`
libraries:: `(chezscheme)`

The bitmask is represented as two's complement number with the bit at each index `_n_` set if and only if `_proc_` accepts `_n_` arguments.

The two's complement encoding implies that if `_proc_` accepts `_n_` or more arguments, the encoding is a negative number, since all the bits from `_n_` and up are set. For example, if `_proc_` accepts any number of arguments, the two's complement encoding of all bits set is `-1`.

[source,scheme,subs="quotes"]
----
(procedure-arity-mask (lambda () 'none)) ⇒ 1
(procedure-arity-mask car) ⇒ 2
(procedure-arity-mask (case-lambda [() 'none] [(x) x])) ⇒ 3
(procedure-arity-mask (lambda x x)) ⇒ -1
(procedure-arity-mask (case-lambda [() 'none] [(x y . z) x])) ⇒ -3
(procedure-arity-mask (case-lambda)) ⇒ 0
(logbit? 1 (procedure-arity-mask pair?)) ⇒ #t
(logbit? 2 (procedure-arity-mask pair?)) ⇒ #f
(logbit? 2 (procedure-arity-mask cons)) ⇒ #t
----
