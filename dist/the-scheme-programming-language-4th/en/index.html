<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="author" content="R. Kent Dybvig">
<link rel="icon" type="image/png" href="images/icon.png">
<title>The Scheme Programming Language, Fourth Edition</title>
<link rel="stylesheet" href="../../theme/default/asciidoctor.css">
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>The Scheme Programming Language, Fourth Edition</h1>
<div class="details">
<span id="author" class="author">R. Kent Dybvig</span><br>
<span id="revdate">Illustrations by Jean-Pierre Hébert</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_preface">Preface</a></li>
<li><a href="#chp_introduction">Chapter 1. Introduction</a>
<ul class="sectlevel2">
<li><a href="#section_1.1.">Section 1.1. Scheme Syntax</a></li>
<li><a href="#section_1.2.">Section 1.2. Scheme Naming Conventions</a></li>
<li><a href="#section_1.3.">Section 1.3. Typographical and Notational Conventions</a></li>
</ul>
</li>
<li><a href="#chp_getting_started">Chapter 2. Getting Started</a>
<ul class="sectlevel2">
<li><a href="#section_2.1.">Section 2.1. Interacting with Scheme</a></li>
<li><a href="#section_2.2.">Section 2.2. Simple Expressions</a></li>
<li><a href="#section_2.3.">Section 2.3. Evaluating Scheme Expressions</a></li>
<li><a href="#section_2.4.">Section 2.4. Variables and Let Expressions</a></li>
<li><a href="#section_2.5.">Section 2.5. Lambda Expressions</a></li>
<li><a href="#section_2.6.">Section 2.6. Top-Level Definitions</a></li>
<li><a href="#section_2.7.">Section 2.7. Conditional Expressions</a></li>
<li><a href="#section_2.8.">Section 2.8. Simple Recursion</a></li>
<li><a href="#section_2.9.">Section 2.9. Assignment</a></li>
</ul>
</li>
<li><a href="#chp_going_further">Chapter 3. Going Further</a>
<ul class="sectlevel2">
<li><a href="#section_3.1.">Section 3.1. Syntactic Extension</a></li>
<li><a href="#section_3.2.">Section 3.2. More Recursion</a></li>
<li><a href="#section_3.3.">Section 3.3. Continuations</a></li>
<li><a href="#section_3.4.">Section 3.4. Continuation Passing Style</a></li>
<li><a href="#section_3.5.">Section 3.5. Internal Definitions</a></li>
<li><a href="#section_3.6.">Section 3.6. Libraries</a></li>
</ul>
</li>
<li><a href="#chp_procedures_and_variable_bindings">Chapter 4. Procedures and Variable Bindings</a>
<ul class="sectlevel2">
<li><a href="#section_4.1.">Section 4.1. Variable References</a></li>
<li><a href="#section_4.2.">Section 4.2. Lambda</a></li>
<li><a href="#section_4.3.">Section 4.3. Case-Lambda</a></li>
<li><a href="#section_4.4.">Section 4.4. Local Binding</a></li>
<li><a href="#section_4.5.">Section 4.5. Multiple Values</a></li>
<li><a href="#section_4.6.">Section 4.6. Variable Definitions</a></li>
<li><a href="#section_4.7.">Section 4.7. Assignment</a></li>
</ul>
</li>
<li><a href="#chp_control_operations">Chapter 5. Control Operations</a>
<ul class="sectlevel2">
<li><a href="#section_5.1.">Section 5.1. Procedure Application</a></li>
<li><a href="#section_5.2.">Section 5.2. Sequencing</a></li>
<li><a href="#section_5.3.">Section 5.3. Conditionals</a></li>
<li><a href="#section_5.4.">Section 5.4. Recursion and Iteration</a></li>
<li><a href="#section_5.5.">Section 5.5. Mapping and Folding</a></li>
<li><a href="#section_5.6.">Section 5.6. Continuations</a></li>
<li><a href="#section_5.7.">Section 5.7. Delayed Evaluation</a></li>
<li><a href="#section_5.8.">Section 5.8. Multiple Values</a></li>
<li><a href="#section_5.9.">Section 5.9. Eval</a></li>
</ul>
</li>
<li><a href="#chp_operations_on_objects">Chapter 6. Operations on Objects</a>
<ul class="sectlevel2">
<li><a href="#section_6.1.">Section 6.1. Constants and Quotation</a></li>
<li><a href="#section_6.2.">Section 6.2. Generic Equivalence and Type Predicates</a></li>
<li><a href="#section_6.3.">Section 6.3. Lists and Pairs</a></li>
<li><a href="#section_6.4.">Section 6.4. Numbers</a></li>
<li><a href="#section_6.5.">Section 6.5. Fixnums</a></li>
<li><a href="#section_6.6.">Section 6.6. Flonums</a></li>
<li><a href="#section_6.7.">Section 6.7. Characters</a></li>
<li><a href="#section_6.8.">Section 6.8. Strings</a></li>
<li><a href="#section_6.9.">Section 6.9. Vectors</a></li>
<li><a href="#section_6.10.">Section 6.10. Bytevectors</a></li>
<li><a href="#section_6.11.">Section 6.11. Symbols</a></li>
<li><a href="#section_6.12.">Section 6.12. Booleans</a></li>
<li><a href="#section_6.13.">Section 6.13. Hashtables</a></li>
<li><a href="#section_6.14.">Section 6.14. Enumerations</a></li>
</ul>
</li>
<li><a href="#chp_input_and_output">Chapter 7. Input and Output</a>
<ul class="sectlevel2">
<li><a href="#section_7.1.">Section 7.1. Transcoders</a></li>
<li><a href="#section_7.2.">Section 7.2. Opening Files</a></li>
<li><a href="#section_7.3.">Section 7.3. Standard Ports</a></li>
<li><a href="#section_7.4.">Section 7.4. String and Bytevector Ports</a></li>
<li><a href="#section_7.5.">Section 7.5. Opening Custom Ports</a></li>
<li><a href="#section_7.6.">Section 7.6. Port Operations</a></li>
<li><a href="#section_7.7.">Section 7.7. Input Operations</a></li>
<li><a href="#section_7.8.">Section 7.8. Output Operations</a></li>
<li><a href="#section_7.9.">Section 7.9. Convenience I/O</a></li>
<li><a href="#section_7.10.">Section 7.10. Filesystem Operations</a></li>
<li><a href="#section_7.11.">Section 7.11. Bytevector/String Conversions</a></li>
</ul>
</li>
<li><a href="#chp_syntactic_extension">Chapter 8. Syntactic Extension</a>
<ul class="sectlevel2">
<li><a href="#section_8.1.">Section 8.1. Keyword Bindings</a></li>
<li><a href="#section_8.2.">Section 8.2. Syntax-Rules Transformers</a></li>
<li><a href="#section_8.3.">Section 8.3. Syntax-Case Transformers</a></li>
<li><a href="#section_8.4.">Section 8.4. Examples</a></li>
</ul>
</li>
<li><a href="#chp_records">Chapter 9. Records</a>
<ul class="sectlevel2">
<li><a href="#section_9.1.">Section 9.1. Defining Records</a></li>
<li><a href="#section_9.2.">Section 9.2. Procedural Interface</a></li>
<li><a href="#section_9.3.">Section 9.3. Inspection</a></li>
</ul>
</li>
<li><a href="#chp_libraries_and_top_level_programs">Chapter 10. Libraries and Top-Level Programs</a>
<ul class="sectlevel2">
<li><a href="#section_10.1.">Section 10.1. Standard Libraries</a></li>
<li><a href="#section_10.2.">Section 10.2. Defining New Libraries</a></li>
<li><a href="#section_10.3.">Section 10.3. Top-Level Programs</a></li>
<li><a href="#section_10.4.">Section 10.4. Examples</a></li>
</ul>
</li>
<li><a href="#chp_exceptions_and_conditions">Chapter 11. Exceptions and Conditions</a>
<ul class="sectlevel2">
<li><a href="#section_11.1.">Section 11.1. Raising and Handling Exceptions</a></li>
<li><a href="#section_11.2.">Section 11.2. Defining Condition Types</a></li>
<li><a href="#section_11.3.">Section 11.3. Standard Condition Types</a></li>
</ul>
</li>
<li><a href="#chp_extended_examples">Chapter 12. Extended Examples</a>
<ul class="sectlevel2">
<li><a href="#section_12.1.">Section 12.1. Matrix and Vector Multiplication</a></li>
<li><a href="#section_12.2.">Section 12.2. Sorting</a></li>
<li><a href="#section_12.3.">Section 12.3. A Set Constructor</a></li>
<li><a href="#section_12.4.">Section 12.4. Word Frequency Counting</a></li>
<li><a href="#section_12.5.">Section 12.5. Scheme Printer</a></li>
<li><a href="#section_12.6.">Section 12.6. Formatted Output</a></li>
<li><a href="#section_12.7.">Section 12.7. A Meta-Circular Interpreter for Scheme</a></li>
<li><a href="#section_12.8.">Section 12.8. Defining Abstract Objects</a></li>
<li><a href="#section_12.9.">Section 12.9. Fast Fourier Transform</a></li>
<li><a href="#section_12.10.">Section 12.10. A Unification Algorithm</a></li>
<li><a href="#section_12.11.">Section 12.11. Multitasking with Engines</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
<li><a href="#answers_to_selected_exercises">Answers to Selected Exercises</a></li>
<li><a href="#formal_syntax">Formal Syntax</a></li>
<li><a href="#summary_of_forms">Summary of Forms</a></li>
<li><a href="#index">Index</a></li>
<li><a href="#_book_converting_tools">Appendix A: Book Converting Tools</a></li>
<li><a href="#_format_javascript_and_replacement_regex_for_the_original_book">Appendix B: Format Javascript and Replacement Regex for The Original Book</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="imageblock text-center">
<div class="content">
<img src="images/cover.png" alt="cover">
</div>
</div>
<div class="paragraph">
<p>R. Kent Dybvig / The Scheme Programming Language, Fourth Edition<br>
Copyright &#169; 2009 <a href="https://mitpress.mit.edu/books/scheme-programming-language-fourth-edition">The MIT Press</a>. Electronically reproduced by permission.<br>
Illustrations &#169; 2009 <a href="http://hebert.kitp.ucsb.edu/">Jean-Pierre Hébert</a><br>
ISBN 978-0-262-51298-5 / LOC QA76.73.S34D93<br>
<a href="https://mitpress.mit.edu/books/scheme-programming-language-fourth-edition">to order this book</a> / <a href="https://www.scheme.com/tspl4/canned/about.html">about this book</a><br>
&nbsp;<br>
<a href="https://www.scheme.com" class="bare">https://www.scheme.com</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_preface">Preface</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Scheme was introduced in 1975 by Gerald J. Sussman and Guy L. Steele Jr. (<a href="#ref28">[28]</a>,<a href="#ref29">[29]</a>), and was the first dialect of Lisp to fully support lexical scoping, first-class procedures, and continuations. In its earliest form it was a small language intended primarily for research and teaching, supporting only a handful of predefined syntactic forms and procedures. Scheme is now a complete general-purpose programming language, though it still derives its power from a small set of key concepts. Early implementations of the language were interpreter-based and slow, but some current Scheme implementations boast sophisticated compilers that generate code on par with code generated by the best optimizing compilers for lower-level languages such as C and Fortran.</p>
</div>
<div class="paragraph">
<p>This book is intended to provide an introduction to the Scheme programming language but not an introduction to programming in general. The reader is expected to have had some experience programming and to be familiar with terms commonly associated with computers and programming languages. Readers unfamiliar with Scheme or Lisp should also consider reading <em>The Little Schemer</em> <a href="#ref13">[13]</a> to become familiar with the concepts of list processing and recursion. Readers new to programming should begin with an introductory text on programming.</p>
</div>
<div class="paragraph">
<p>Scheme has been standardized both formally and informally. The <em>IEEE Standard for the Scheme Programming Language</em> <a href="#ref18">[18]</a>, describes a formal ANSI/IEEE Standard for Scheme but dates back to 1991. A related series of reports, the "Revised Reports on the Algorithmic Language Scheme," document an evolving informal standard that most implementations support. The current report in this series is the "Revised<sup>6</sup> Report on the Algorithmic Language Scheme" <a href="#ref24">[24]</a>, which was completed in 2007.</p>
</div>
<div class="paragraph">
<p>This book covers the language of the Revised<sup>6</sup> Report. It is not intended to supplant the Revised<sup>6</sup> Report but rather to provide a more comprehensive introduction and reference manual for the language, with more explanatory text and examples, suitable more for users than for implementors. Features specific to particular implementations of Scheme are not included. In particular, features specific to the author&#8217;s Chez Scheme and Petite Chez Scheme implementations are described separately in the <em>Chez Scheme User&#8217;s Guide</em> <a href="#ref9">[9]</a>. On the other hand, no book on Scheme would be complete without some coverage of the interactive top level, since nearly every Scheme system supports interactive use in one form or another, even though the behavior is not standardized by the Revised<sup>6</sup> Report. Chapters <a href="#chp_getting_started">2</a> and <a href="#chp_going_further">3</a> are thus written assuming that the reader has available a Scheme implementation that supports an interactive top level, with behavior consistent with the description of the top-level environment in earlier reports and the IEEE/ANSI standard.</p>
</div>
<div class="paragraph">
<p>A large number of small- to medium-sized examples are spread throughout the text, and one entire chapter is dedicated to the presentation of a set of longer examples. Many of the examples show how a standard Scheme syntactic form or procedure might be implemented; others implement useful extensions. All of the examples can be entered directly from the keyboard into an interactive Scheme session.</p>
</div>
<div class="paragraph">
<p>This book is organized into twelve chapters, plus back matter. <a href="#chp_introduction">Chapter 1</a> describes the properties and features of Scheme that make it a useful and enjoyable language to use. <a href="#chp_introduction">Chapter 1</a> also describes Scheme&#8217;s notational conventions and the typographical conventions employed in this book.</p>
</div>
<div class="paragraph">
<p><a href="#chp_getting_started">Chapter 2</a> is an introduction to Scheme programming for the novice Scheme programmer that leads the reader through a series of examples, beginning with simple Scheme expressions and working toward progressively more difficult ones. Each section of <a href="#chp_getting_started">Chapter 2</a> introduces a small set of related features, and the end of each section contains a set of exercises for further practice. The reader will learn the most from <a href="#chp_getting_started">Chapter 2</a> by sitting at the keyboard and typing in the examples and trying the exercises.</p>
</div>
<div class="paragraph">
<p><a href="#chp_going_further">Chapter 3</a> continues the introduction but covers more advanced features and concepts. Even readers with prior Scheme experience may wish to work through the examples and exercises found there.</p>
</div>
<div class="paragraph">
<p><a href="#chp_procedures_and_variable_bindings">Chapter 4</a> through <a href="#chp_exceptions_and_conditions">11</a> make up the reference portion of the text. They present each of Scheme&#8217;s primitive procedures and syntactic forms in turn, grouping them into short sections of related procedures and forms. <a href="#chp_procedures_and_variable_bindings">Chapter 4</a> describes operations for creating procedures and variable bindings; <a href="#chp_control_operations">Chapter 5</a>, program control operations; <a href="#chp_operations_on_objects">Chapter 6</a>, operations on the various object types (including lists, numbers, and strings); <a href="#chp_input_and_output">Chapter 7</a>, input and output operations; <a href="#chp_syntactic_extension">Chapter 8</a>, syntactic extension; <a href="#chp_records">Chapter 9</a>, record-type definitions; <a href="#chp_libraries_and_top_level_programs">Chapter 10</a>, libraries and top-level programs; and <a href="#chp_exceptions_and_conditions">Chapter 11</a>, exceptions and conditions.</p>
</div>
<div class="paragraph">
<p><a href="#chp_extended_examples">Chapter 12</a> contains a collection of example procedures, libraries, and programs, each with a short overview, some examples of its use, the implementation with brief explanation, and a set of exercises for further work. Each of these programs demonstrates a particular set of features, and together they illustrate an appropriate style for programming in Scheme.</p>
</div>
<div class="paragraph">
<p>Following <a href="#chp_extended_examples">Chapter 12</a> are bibliographical references, answers to selected exercises, a detailed description of the formal syntax of Scheme programs and data, a concise summary of Scheme syntactic forms and procedures, and the index. The summary of forms and procedures is a useful first stop for programmers unsure of the structure of a syntactic form or the arguments expected by a primitive procedure. The page numbers appearing in the summary of forms and procedures and the italicized page numbers appearing in the index indicate the locations in the text where forms and procedures are defined.</p>
</div>
<div class="paragraph">
<p>Because the reference portion describes a number of aspects of the language not covered by the introductory chapters along with a number of interesting short examples, most readers will find it profitable to read through most of the material to become familiar with each feature and how it relates to other features. <a href="#chp_operations_on_objects">Chapter 6</a> is lengthy, however, and may be skimmed and later referenced as needed.</p>
</div>
<div class="paragraph">
<p>An online version of this book is available at <a href="http://www.scheme.com/tspl/" class="bare">http://www.scheme.com/tspl/</a>. The summary of forms and index in the online edition include page numbers for the printed version and are thus useful as searchable indexes.</p>
</div>
<div class="paragraph">
<p><em>About the illustrations</em>: The cover illustration and the illustration at the front of each chapter are algorithmic line fields created by artist Jean-Pierre Hébert, based on an idea inspired by the writings of John Cage. Each line field is created by the composition of any number of grids of parallel lines. The grids are regular, but they are not. For instance, the lines are of irregular length, which creates ragged edges. Their tone and thickness vary slightly. They are not exactly equidistant. They intersect with each other at a certain angle. When this angle is small, patterns of interference develop. The lines are first steeped into various scalar fields that perturb their original straight shape, then projected on the plane of the paper. Masks introduce holes in some layers. For the cover illustration, the grids are colored in different hues.</p>
</div>
<div class="paragraph">
<p>All the images are created by a single Scheme program that makes most of the decisions, based heavily on chance. The artist controls only canvas size, aspect ratio, the overall palette of colors, and levels of chance and fuzziness. The task of the artist is to introduce just enough chance at the right place so that the results are at the same time surprising, interesting, and in line with the artist&#8217;s sense of aesthetics. This is a game of uncertainty, chaos, and harmony.</p>
</div>
<div class="paragraph">
<p><em>Acknowledgments</em>: Many individuals contributed in one way or another to the preparation of one or more editions of this book, including Bruce Smith, Eugene Kohlbecker, Matthias Felleisen, Dan Friedman, Bruce Duba, Phil Dybvig, Guy Steele, Bob Hieb, Chris Haynes, Dave Plaisted, Joan Curry, Frank Silbermann, Pavel Curtis, John Wait, Carl Bruggeman, Sam Daniel, Oscar Waddell, Mike Ashley, John LaLonde, John Zuckerman, John Simmons, Bob Prior, Bob Burger, and Aziz Ghuloum. Many others have offered minor corrections and suggestions. Oscar Waddell helped create the typesetting system used to format the printed and online versions of this book. A small amount of text and a few examples have been adapted from the Revised<sup>6</sup> Report for this book, for which credit goes to the editors of that report and many others who contributed to it. Finally and most importantly, my wife, Susan Dybvig, suggested that I write this book in the first place and lent her expertise and assistance to the production and publication of this and the previous editions.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chp_introduction">Chapter 1. Introduction</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/ch1.png" alt="ch1">
</div>
</div>
<div class="paragraph">
<p>Scheme is a general-purpose computer programming language. It is a high-level language, supporting operations on structured data such as strings, lists, and vectors, as well as operations on more traditional data such as numbers and characters. While Scheme is often identified with symbolic applications, its rich set of data types and flexible control structures make it a truly versatile language. Scheme has been employed to write text editors, optimizing compilers, operating systems, graphics packages, expert systems, numerical applications, financial analysis packages, virtual reality systems, and practically every other type of application imaginable. Scheme is a fairly simple language to learn, since it is based on a handful of syntactic forms and semantic concepts and since the interactive nature of most implementations encourages experimentation. Scheme is a challenging language to understand fully, however; developing the ability to use its full potential requires careful study and practice.</p>
</div>
<div class="paragraph">
<p>Scheme programs are highly portable across versions of the same Scheme implementation on different machines, because machine dependencies are almost completely hidden from the programmer. They are also portable across different implementations because of the efforts of a group of Scheme language designers who have published a series of reports, the "Revised Reports" on Scheme. The most recent, the "Revised<sup>6</sup> Report" <a href="#ref24">[24]</a>, emphasizes portability through a set of standard libraries and a standard mechanism for defining new portable libraries and top-level programs.</p>
</div>
<div class="paragraph">
<p>Although some early Scheme systems were inefficient and slow, many newer compiler-based implementations are fast, with programs running on par with equivalent programs written in lower-level languages. The relative inefficiency that sometimes remains results from run-time checks that support generic arithmetic and help programmers detect and correct various common programming errors. These checks may be disabled in many implementations.</p>
</div>
<div class="paragraph">
<p>Scheme supports many types of data values, or <em>objects</em>, including characters, strings, symbols, lists or vectors of objects, and a full set of numeric data types, including complex, real, and arbitrary-precision rational numbers.</p>
</div>
<div class="paragraph">
<p>The storage required to hold the contents of an object is dynamically allocated as necessary and retained until no longer needed, then automatically deallocated, typically by a <em>garbage collector</em> that periodically recovers the storage used by inaccessible objects. Simple atomic values, such as small integers, characters, booleans, and the empty list, are typically represented as immediate values and thus incur no allocation or deallocation overhead.</p>
</div>
<div class="paragraph">
<p>Regardless of representation, all objects are <em>first-class</em> data values; because they are retained indefinitely, they may be passed freely as arguments to procedures, returned as values from procedures, and combined to form new objects. This is in contrast with many other languages where composite data values such as arrays are either statically allocated and never deallocated, allocated on entry to a block of code and unconditionally deallocated on exit from the block, or explicitly allocated <em>and</em> deallocated by the programmer.</p>
</div>
<div class="paragraph">
<p>Scheme is a call-by-value language, but for at least mutable objects (objects that can be modified), the values are pointers to the actual storage. These pointers remain behind the scenes, however, and programmers need not be conscious of them except to understand that the storage for an object is not copied when an object is passed to or returned from a procedure.</p>
</div>
<div id="intro:s6" class="paragraph">
<p>At the heart of the Scheme language is a small core of syntactic forms from which all other forms are built. These core forms, a set of extended syntactic forms derived from them, and a set of primitive procedures make up the full Scheme language. An interpreter or compiler for Scheme can be quite small and potentially fast and highly reliable. The extended syntactic forms and many primitive procedures can be defined in Scheme itself, simplifying the implementation and increasing reliability.</p>
</div>
<div class="paragraph">
<p>Scheme programs share a common printed representation with Scheme data structures. As a result, any Scheme program has a natural and obvious internal representation as a Scheme object. For example, variables and syntactic keywords correspond to symbols, while structured syntactic forms correspond to lists. This representation is the basis for the syntactic extension facilities provided by Scheme for the definition of new syntactic forms in terms of existing syntactic forms and procedures. It also facilitates the implementation of interpreters, compilers, and other program transformation tools for Scheme directly in Scheme, as well as program transformation tools for other languages in Scheme.</p>
</div>
<div class="paragraph">
<p>Scheme variables and keywords are <em>lexically scoped</em>, and Scheme programs are <em>block-structured</em>. Identifiers may be imported into a program or library or bound locally within a given block of code such as a library, program, or procedure body. A local binding is visible only lexically, i.e., within the program text that makes up the particular block of code. An occurrence of an identifier of the same name outside this block refers to a different binding; if no binding for the identifier exists outside the block, then the reference is invalid. Blocks may be nested, and a binding in one block may <em>shadow</em> a binding for an identifier of the same name in a surrounding block. The <em>scope</em> of a binding is the block in which the bound identifier is visible minus any portions of the block in which the identifier is shadowed. Block structure and lexical scoping help create programs that are modular, easy to read, easy to maintain, and reliable. Efficient code for lexical scoping is possible because a compiler can determine before program evaluation the scope of all bindings and the binding to which each identifier reference resolves. This does not mean, of course, that a compiler can determine the values of all variables, since the actual values are not computed in most cases until the program executes.</p>
</div>
<div class="paragraph">
<p>In most languages, a procedure definition is simply the association of a name with a block of code. Certain variables local to the block are the parameters of the procedure. In some languages, a procedure definition may appear within another block or procedure so long as the procedure is invoked only during execution of the enclosing block. In others, procedures can be defined only at top level. In Scheme, a procedure definition may appear within another block or procedure, and the procedure may be invoked at any time thereafter, even if the enclosing block has completed its execution. To support lexical scoping, a procedure carries the lexical context (environment) along with its code.</p>
</div>
<div class="paragraph">
<p>Furthermore, Scheme procedures are not always named. Instead, procedures are first-class data objects like strings or numbers, and variables are bound to procedures in the same way they are bound to other objects.</p>
</div>
<div class="paragraph">
<p>As with procedures in most other languages, Scheme procedures may be recursive. That is, any procedure may invoke itself directly or indirectly. Many algorithms are most elegantly or efficiently specified recursively. A special case of recursion, called tail recursion, is used to express iteration, or looping. A <em>tail call</em> occurs when one procedure directly returns the result of invoking another procedure; <em>tail recursion</em> occurs when a procedure recursively tail-calls itself, directly or indirectly. Scheme implementations are required to implement tail calls as jumps (gotos), so the storage overhead normally associated with recursion is avoided. As a result, Scheme programmers need master only simple procedure calls and recursion and need not be burdened with the usual assortment of looping constructs.</p>
</div>
<div class="paragraph">
<p>Scheme supports the definition of arbitrary control structures with <em>continuations</em>. A continuation is a procedure that embodies the remainder of a program at a given point in the program. A continuation may be obtained at any time during the execution of a program. As with other procedures, a continuation is a first-class object and may be invoked at any time after its creation. Whenever it is invoked, the program immediately continues from the point where the continuation was obtained. Continuations allow the implementation of complex control mechanisms including explicit backtracking, multithreading, and coroutines.</p>
</div>
<div id="intro:s25" class="paragraph">
<p>Scheme also allows programmers to define new syntactic forms, or <em>syntactic extensions</em>, by writing transformation procedures that determine how each new syntactic form maps to existing syntactic forms. These transformation procedures are themselves expressed in Scheme with the help of a convenient high-level pattern language that automates syntax checking, input deconstruction, and output reconstruction. By default, lexical scoping is maintained through the transformation process, but the programmer can exercise control over the scope of all identifiers appearing in the output of a transformer. Syntactic extensions are useful for defining new language constructs, for emulating language constructs found in other languages, for achieving the effects of in-line code expansion, and even for emulating entire languages in Scheme. Most large Scheme programs are built from a mix of syntactic extensions and procedure definitions.</p>
</div>
<div class="paragraph">
<p>Scheme evolved from the Lisp language and is considered to be a dialect of Lisp. Scheme inherited from Lisp the treatment of values as first-class objects, several important data types, including symbols and lists, and the representation of programs as objects, among other things. Lexical scoping and block structure are features taken from Algol 60 <a href="#ref21">[21]</a>. Scheme was the first Lisp dialect to adopt lexical scoping and block structure, first-class procedures, the treatment of tail calls as jumps, continuations, and lexically scoped syntactic extensions.</p>
</div>
<div id="intro:s28" class="paragraph">
<p>Common Lisp <a href="#ref27">[27]</a> and Scheme are both contemporary Lisp languages, and the development of each has been influenced by the other. Like Scheme but unlike earlier Lisp languages, Common Lisp adopted lexical scoping and first-class procedures, although Common Lisp&#8217;s syntactic extension facility does not respect lexical scoping. Common Lisp&#8217;s evaluation rules for procedures are different from the evaluation rules for other objects, however, and it maintains a separate namespace for procedure variables, thereby inhibiting the use of procedures as first-class objects. Also, Common Lisp does not support continuations or require proper treatment of tail calls, but it does support several less general control structures not found in Scheme. While the two languages are similar, Common Lisp includes more specialized constructs, while Scheme includes more general-purpose building blocks out of which such constructs (and others) may be built.</p>
</div>
<div class="paragraph">
<p>The remainder of this chapter describes Scheme&#8217;s syntax and naming conventions and the typographical conventions used throughout this book.</p>
</div>
<div class="sect2">
<h3 id="section_1.1.">Section 1.1. Scheme Syntax</h3>
<div class="paragraph">
<p>Scheme programs are made up of keywords, variables, structured forms, constant data (numbers, characters, strings, quoted vectors, quoted lists, quoted symbols, etc.), whitespace, and comments.</p>
</div>
<div class="paragraph">
<p>Keywords, variables, and symbols are collectively called identifiers. Identifiers may be formed from letters, digits, and certain special characters, including <code>?</code>, <code>!</code>, <code>.</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&lt;</code>, <code>=</code>, <code>&gt;</code>, <code>:</code>, <code>$</code>, <code>%</code>, <code>^</code>, <code>&amp;</code>, <code>_</code>, <code>~</code>, and <code>@</code>, as well as a set of additional Unicode characters. Identifiers cannot start with an at sign ( <code>@</code> ) and normally cannot start with any character that can start a number, i.e., a digit, plus sign ( <code>+</code> ), minus sign ( <code>-</code> ), or decimal point ( <code>.</code> ). Exceptions are <code>+</code>, <code>-</code>, and <code>...</code>, which are valid identifiers, and any identifier starting with <code>-&gt;</code>. For example, <code>hi</code>, <code>Hello</code>, <code>n</code>, <code>x</code>, <code>x3</code>, <code>x+2</code>, and <code>?$&amp;*!!!</code> are all identifiers. Identifiers are delimited by whitespace, comments, parentheses, brackets, string (double) quotes ( <code>"</code> ), and hash marks( <code>#</code> ). A delimiter or any other Unicode character may be included anywhere within the name of an identifier as an escape of the form <code>\x<em>sv</em>;</code>, where <code><em>sv</em></code> is the scalar value of the character in hexadecimal notation.</p>
</div>
<div class="paragraph">
<p>There is no inherent limit on the length of a Scheme identifier; programmers may use as many characters as necessary. Long identifiers are no substitute for comments, however, and frequent use of long identifiers can make a program difficult to format and consequently difficult to read. A good rule is to use short identifiers when the scope of the identifier is small and longer identifiers when the scope is larger.</p>
</div>
<div class="paragraph">
<p>Identifiers may be written in any mix of upper- and lower-case letters, and case is significant, i.e., two identifiers are different even if they differ only in case. For example, <code>abcde</code>, <code>Abcde</code>, <code>AbCdE</code>, and <code>ABCDE</code> all refer to different identifiers. This is a change from previous versions of the Revised Report.</p>
</div>
<div class="paragraph">
<p>Structured forms and list constants are enclosed within parentheses, e.g., <code>(a b c)</code> or <code>(* (- x 2) y)</code>. The empty list is written <code>()</code>. Matched sets of brackets ( <code>[</code> <code>]</code> ) may be used in place of parentheses and are often used to set off the subexpressions of certain standard syntactic forms for readability, as shown in examples throughout this book. Vectors are written similarly to lists, except that they are preceded by <code>#(</code> and terminated by <code>)</code>, e.g., <code>#(this is a vector of symbols)</code>. Bytevectors are written as sequences of unsigned byte values (exact integers in the range 0 through 255) bracketed by <code>#vu8(</code> and <code>)</code>, e.g., <code>#vu8(3 250 45 73)</code>.</p>
</div>
<div class="paragraph">
<p>Strings are enclosed in double quotation marks, e.g., <code>"I am a string"</code>. Characters are preceded by <code>#\</code>, e.g., <code>#\a</code>. Case is important within character and string constants, as within identifiers. Numbers may be written as integers, e.g., -123, as ratios, e.g., 1/2, in floating-point or scientific notation, e.g., 1.3 or 1e23, or as complex numbers in rectangular or polar notation, e.g., 1.3-2.7i or -1.2@73. Case is not important in the syntax of a number. The boolean values representing <em>true</em> and <em>false</em> are written <code>#t</code> and <code>#f</code>. Scheme conditional expressions actually treat <code>#f</code> as false and all other objects as true, so <code>3</code>, <code>0</code>, <code>()</code>, <code>"false"</code>, and <code>nil</code> all count as true.</p>
</div>
<div class="paragraph">
<p>Details of the syntax for each type of constant data are given in the individual sections of <a href="#chp_operations_on_objects">Chapter 6</a> and in the formal syntax of Scheme starting on page <a href="#formal_syntax">455</a>.</p>
</div>
<div class="paragraph">
<p>Scheme expressions may span several lines, and no explicit terminator is required. Since the number of whitespace characters (spaces and newlines) between expressions is not significant, Scheme programs should be indented to show the structure of the code in a way that makes the code as readable as possible. Comments may appear on any line of a Scheme program, between a semicolon ( <code>;</code> ) and the end of the line. Comments explaining a particular Scheme expression are normally placed at the same indentation level as the expression, on the line before the expression. Comments explaining a procedure or group of procedures are normally placed before the procedures, without indentation. Multiple comment characters are often used to set off the latter kind of comment, e.g., <code>;;; The following procedures ...</code>.</p>
</div>
<div class="paragraph">
<p>Two other forms of comments are supported: block comments and datum comments. Block comments are delimited by <code>#|</code> and <code>|#</code> pairs, and may be nested. A datum comment consists of a <code>#;</code> prefix and the datum (printed data value) that follows it. Datum comments are typically used to comment out individual definitions or expressions. For example, <code>(three #;(not four) element list)</code> is just what it says. Datum comments may also be nested, though <code>#;#;(a)(b)</code> has the somewhat nonobvious effect of commenting out both <code>(a)</code> and <code>(b)</code>.</p>
</div>
<div class="paragraph">
<p>Some Scheme values, such as procedures and ports, do not have standard printed representations and can thus never appear as a constant in the printed syntax of a program. This book uses the notation <code>#&lt;<em>description</em>&gt;</code> when showing the output of an operation that returns such a value, e.g., <code>#&lt;procedure&gt;</code> or <code>#&lt;port&gt;</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_1.2.">Section 1.2. Scheme Naming Conventions</h3>
<div class="paragraph">
<p>Scheme&#8217;s naming conventions are designed to provide a high degree of regularity. The following is a list of these naming conventions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Predicate names end in a question mark ( <code>?</code> ). Predicates are procedures that return a true or false answer, such as <code>eq?</code>, <code>zero?</code>, and <code>string=?</code>. The common numeric comparators <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> are exceptions to this naming convention.</p>
</li>
<li>
<p>Type predicates, such as <code>pair?</code>, are created from the name of the type, in this case <code>pair</code>, and the question mark.</p>
</li>
<li>
<p>The names of most character, string, and vector procedures start with the prefix <code>char-</code>, <code>string-</code>, and <code>vector-</code>, e.g., <code>string-append</code>. (The names of some list procedures start with <code>list-</code>, but most do not.)</p>
</li>
<li>
<p>The names of procedures that convert an object of one type into an object of another type are written as <code><em>type<sub>1</sub></em>-&gt;<em>type<sub>2</sub></em></code>, e.g., <code>vector-&gt;list</code>.</p>
</li>
<li>
<p>The names of procedures and syntactic forms that cause side effects end with an exclamation point ( <code>!</code> ). These include <code>set!</code> and <code>vector-set!</code>. Procedures that perform input or output technically cause side effects, but their names are exceptions to this rule.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Programmers should employ these same conventions in their own code whenever possible.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_1.3.">Section 1.3. Typographical and Notational Conventions</h3>
<div class="paragraph">
<p>A standard procedure or syntactic form whose sole purpose is to perform some side effect is said to return <em>unspecified</em>. This means that an implementation is free to return any number of values, each of which can be any Scheme object, as the value of the procedure or syntactic form. Do not count on these values being the same across implementations, the same across versions of the same implementation, or even the same across two uses of the procedure or syntactic form. Some Scheme systems routinely use a special object to represent unspecified values. Printing of this object is often suppressed by interactive Scheme systems, so that the values of expressions returning unspecified values are not printed.</p>
</div>
<div id="intro:s54" class="paragraph">
<p>While most standard procedures return a single value, the language supports procedures that return zero, one, more than one, or even a variable number of values via the mechanisms described in <a href="#section_5.8.">Section 5.8</a>. Some standard expressions can evaluate to multiple values if one of their subexpressions evaluates to multiple values, e.g., by calling a procedure that returns multiple values. When this situation can occur, an expression is said to return "the values" rather than simply "the value" of its subexpression. Similarly, a standard procedure that returns the values resulting from a call to a procedure argument is said to return the values returned by the procedure argument.</p>
</div>
<div id="intro:s55" class="paragraph">
<p>This book uses the words "must" and "should" to describe program requirements, such as the requirement to provide an index that is less than the length of the vector in a call to <code>vector-ref</code>. If the word "must" is used, it means that the requirement is enforced by the implementation, i.e., an exception is raised, usually with condition type <code>&amp;assertion</code>. If the word "should" is used, an exception may or may not be raised, and if not, the behavior of the program is undefined.</p>
</div>
<div id="intro:s56" class="paragraph">
<p>The phrase "syntax violation" is used to describe a situation in which a program is malformed. Syntax violations are detected prior to program execution. When a syntax violation is detected, an exception of type <code>&amp;syntax</code> is raised and the program is not executed.</p>
</div>
<div class="paragraph">
<p>The typographical conventions used in this book are straightforward. All Scheme objects are printed in a <code>typewriter</code> typeface, just as they are to be typed at the keyboard. This includes syntactic keywords, variables, constant objects, Scheme expressions, and example programs. An <em>italic</em> typeface is used to set off syntax variables in the descriptions of syntactic forms and arguments in the descriptions of procedures. Italics are also used to set off technical terms the first time they appear. In general, names of syntactic forms and procedures are never capitalized, even at the beginning of a sentence. The same is true for syntax variables written in italics.</p>
</div>
<div class="paragraph">
<p>In the description of a syntactic form or procedure, one or more prototype patterns show the syntactic form or forms or the correct number or numbers of arguments for an application of the procedure. The keyword or procedure name is given in typewriter font, as are parentheses. The remaining pieces of the syntax or arguments are shown in italics, using a name that implies the type of expression or argument expected by the syntactic form or procedure. Ellipses are used to specify zero or more occurrences of a subexpression or argument. For example, <code>(or <em>expr</em> ...)</code> describes the <code>or</code> syntactic form, which has zero or more subexpressions, and <code>(member <em>obj</em> <em>list</em>)</code> describes the <code>member</code> procedure, which expects two arguments, an object and a list.</p>
</div>
<div class="paragraph">
<p>A syntax violation occurs if the structure of a syntactic form does not match its prototype. Similarly, an exception with condition type <code>&amp;assertion</code> is raised if the number of arguments passed to a standard procedure does not match what it is specified to receive. An exception with condition type <code>&amp;assertion</code> is also raised if a standard procedure receives an argument whose type is not the type implied by its name or does not meet other criteria given in the description of the procedure. For example, the prototype for <code>vector-set!</code> is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(vector-set! <em>vector</em> <em>n</em> <em>obj</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>and the description says that <code><em>n</em></code> must be an exact nonnegative integer strictly less than the length of <code><em>vector</em></code>. Thus, <code>vector-set!</code> must receive three arguments, the first of which must be a vector, the second of which must be an exact nonnegative integer less than the length of the vector, and the third of which may be any Scheme value. Otherwise, an exception with condition type <code>&amp;assertion</code> is raised.</p>
</div>
<div class="paragraph">
<p>In most cases, the type of argument required is obvious, as with <code><em>vector</em></code>, <code><em>obj</em></code>, or <code><em>binary-input-port</em></code>. In others, primarily within the descriptions of numeric routines, abbreviations are used, such as <code><em>int</em></code> for integer, <code><em>exint</em></code> for exact integer, and <code><em>fx</em></code> for fixnum. These abbreviations are explained at the start of the sections containing the affected entries.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chp_getting_started">Chapter 2. Getting Started</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/ch2.png" alt="ch2">
</div>
</div>
<div class="paragraph">
<p>This chapter is an introduction to Scheme for programmers who are new to the language. You will get more from this chapter if you are sitting in front of an interactive Scheme system, trying out the examples as you go.</p>
</div>
<div class="paragraph">
<p>After reading this chapter and working the exercises, you should be able to start using Scheme. You will have learned the syntax of Scheme programs and how they are executed, along with how to use simple data structures and control mechanisms.</p>
</div>
<div class="sect2">
<h3 id="section_2.1.">Section 2.1. Interacting with Scheme</h3>
<div class="paragraph">
<p>Most Scheme systems provide an interactive programming environment that simplifies program development and experimentation. The simplest interaction with Scheme follows a "read-evaluate-print" cycle. A program (often called a <em>read-evaluate-print loop</em>, or REPL) reads each expression you type at the keyboard, evaluates it, and prints its value.</p>
</div>
<div class="paragraph">
<p>With an interactive Scheme system, you can type an expression at the keyboard and see its value immediately. You can define a procedure and apply it to arguments to see how it works. You can even type in an entire program consisting of a set of procedure definitions and test it without leaving the system. When your program starts getting longer, it will be more convenient to type it into a file (using a text editor), load the file and test it interactively. In most Scheme systems, a file may be loaded with the nonstandard procedure <code>load</code>, which takes a string argument naming the file. Preparing your program in a file has several advantages: you have a chance to compose your program more carefully, you can correct errors without retyping the program, and you can retain a copy for later use. Most Scheme implementations treat expressions loaded from a file the same as expressions typed at the keyboard.</p>
</div>
<div class="paragraph">
<p>While Scheme provides various input and output procedures, the REPL takes care of reading expressions and printing their values. This frees you to concentrate on writing your program without worrying about how its results will be displayed.</p>
</div>
<div class="paragraph">
<p>The examples in this chapter and in the rest of the book follow a regular format. An expression you might type from your keyboard is given first, possibly spanning several lines. The value of the expression is given after the ⇒, to be read as "evaluates to." The ⇒ is omitted for definitions and when the value of an expression is unspecified.</p>
</div>
<div class="paragraph">
<p>The example programs are formatted in a style that "looks nice" and conveys the structure of the program. The code is easy to read because the relationship between each expression and its subexpressions is clearly shown. Scheme ignores indentation and line breaks, however, so there is no need to follow a particular style. The important thing is to establish one style and keep to it. Scheme sees each program as if it were on a single line, with its subexpressions ordered from left to right.</p>
</div>
<div class="paragraph">
<p>If you have access to an interactive Scheme system, it might be a good idea to start it up now and type in the examples as you read. One of the simplest Scheme expressions is a string constant. Try typing <code>"Hi Mom!"</code> (including the double quotes) in response to the prompt. The system should respond with <code>"Hi Mom!"</code>; the value of any constant is the constant itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">"Hi Mom!" ⇒ "Hi Mom!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a set of expressions, each with Scheme&#8217;s response. They are explained in later sections of this chapter, but for now use them to practice interacting with Scheme.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">"hello" ⇒ "hello"
42 ⇒ 42
22/7 ⇒ 22/7
3.141592653 ⇒ 3.141592653
+ ⇒ #&lt;procedure&gt;
(+ 76 31) ⇒ 107
(* -12 10) ⇒ -120
'(a b c d) ⇒ (a b c d)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Be careful not to miss any single quotes ( <code>'</code> ), double quotes, or parentheses. If you left off a single quote in the last expression, you probably received a message indicating that an exception has occurred. Just try again. If you left off a closing parenthesis or double quote, the system might still be waiting for it.</p>
</div>
<div class="paragraph">
<p>Here are a few more expressions to try. You can try to figure out on your own what they mean or wait to find out later in the chapter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(car '(a b c)) ⇒ a
(cdr '(a b c)) ⇒ (b c)
(cons 'a '(b c)) ⇒ (a b c)
(cons (car '(a b c))
      (cdr '(d e f))) ⇒ (a e f)</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, Scheme expressions may span more than one line. The Scheme system knows when it has an entire expression by matching double quotes and parentheses.</p>
</div>
<div class="paragraph">
<p>Next, let&#8217;s try defining a procedure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define square
  (lambda (n)
    (* n n)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The procedure <code>square</code> computes the square \(n^2\) of any number \(n\). We say more about the expressions that make up this definition later in this chapter. For now it suffices to say that <code>define</code> establishes variable bindings, <code>lambda</code> creates procedures, and <code>*</code> names the multiplication procedure. Note the form of these expressions. All structured forms are enclosed in parentheses and written in <em>prefix notation</em>, i.e., the operator precedes the arguments. As you can see, this is true even for simple arithmetic operations such as <code>*</code>.</p>
</div>
<div class="paragraph">
<p>Try using <code>square</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(square 5) ⇒ 25
(square -200) ⇒ 40000
(square 0.5) ⇒ 0.25
(square -1/2) ⇒ 1/4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even though the next definition is short, you might enter it into a file. Let&#8217;s assume you call the file "reciprocal.ss."</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define reciprocal
  (lambda (n)
    (if (= n 0)
        "oops!"
        (/ 1 n))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This procedure, <code>reciprocal</code>, computes the quantity \(1/n\) for any number \(n \neq 0\). For \(n = 0\), <code>reciprocal</code> returns the string <code>"oops!"</code>. Return to Scheme and try loading your file with the procedure <code>load</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(load "reciprocal.ss")</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, try using the procedure we have just defined.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(reciprocal 10) ⇒ 1/10
(reciprocal 1/10) ⇒ 10
(reciprocal 0) ⇒ "oops!"
(reciprocal (reciprocal 1/10)) ⇒ 1/10</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the next section we will discuss Scheme expressions in more detail. Throughout this chapter, keep in mind that your Scheme system is one of the most useful tools for learning Scheme. Whenever you try one of the examples in the text, follow it up with your own examples. In an interactive Scheme system, the cost of trying something out is relatively small---usually just the time to type it in.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_2.2.">Section 2.2. Simple Expressions</h3>
<div class="paragraph">
<p>The simplest Scheme expressions are constant data objects, such as strings, numbers, symbols, and lists. Scheme supports other object types, but these four are enough for many programs. We saw some examples of strings and numbers in the preceding section.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s discuss numbers in a little more detail. Numbers are constants. If you enter a number, Scheme echoes it back to you. The following examples show that Scheme supports several types of numbers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">123456789987654321 ⇒ 123456789987654321
3/4 ⇒ 3/4
2.718281828 ⇒ 2.718281828
2.2+1.1i ⇒ 2.2+1.1i</code></pre>
</div>
</div>
<div class="paragraph">
<p>Scheme numbers include exact and inexact integer, rational, real, and complex numbers. Exact integers and rational numbers have arbitrary precision, i.e., they can be of arbitrary size. Inexact numbers are usually represented internally using IEEE standard floating-point representations.</p>
</div>
<div class="paragraph">
<p>Scheme provides the names <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> for the corresponding arithmetic procedures. Each procedure accepts two numeric arguments. The expressions below are called <em>procedure applications</em>, because they specify the application of a procedure to a set of arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(+ 1/2 1/2) ⇒ 1
(- 1.5 1/2) ⇒ 1.0

(* 3 1/2) ⇒ 3/2
(/ 1.5 3/4) ⇒ 2.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Scheme employs prefix notation even for common arithmetic operations. Any procedure application, whether the procedure takes zero, one, two, or more arguments, is written as <code>(<em>procedure</em> <em>arg</em> ...)</code>. This regularity simplifies the syntax of expressions; one notation is employed regardless of the operation, and there are no complicated rules regarding the precedence or associativity of operators.</p>
</div>
<div class="paragraph">
<p>Procedure applications may be nested, in which case the innermost values are computed first. We can thus nest applications of the arithmetic procedures given above to evaluate more complicated formulas.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(+ (+ 2 2) (+ 2 2)) ⇒ 8
(- 2 (* 4 1/3)) ⇒ 2/3
(* 2 (* 2 (* 2 (* 2 2)))) ⇒ 32
(/ (* 6/7 7/2) (- 4.5 1.5)) ⇒ 1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>These examples demonstrate everything you need to use Scheme as a four-function desk calculator. While we will not discuss them in this chapter, Scheme supports many other arithmetic procedures. Now might be a good time to turn to <a href="#section_6.4.">Section 6.4</a> and experiment with some of them.</p>
</div>
<div id="start:s13" class="paragraph">
<p>Simple numeric objects are sufficient for many tasks, but sometimes aggregate data structures containing two or more values are needed. In many languages, the basic aggregate data structure is the array. In Scheme, it is the <em>list</em>. Lists are written as sequences of objects surrounded by parentheses. For instance, <code>(1 2 3 4 5)</code> is a list of numbers, and <code>("this" "is" "a" "list")</code> is a list of strings. Lists need not contain only one type of object, so <code>(4.2 "hi")</code> is a valid list containing a number and a string. Lists may be nested (may contain other lists), so <code>1 2) (3 4</code> is a valid list with two elements, each of which is a list of two elements.</p>
</div>
<div class="paragraph">
<p>You might notice that lists look just like procedure applications and wonder how Scheme tells them apart. That is, how does Scheme distinguish between a list of objects, <code>(<em>obj<sub>1</sub></em> <em>obj<sub>2</sub></em> ...)</code>, and a procedure application, <code>(<em>procedure</em> <em>arg</em> ...)</code>?</p>
</div>
<div class="paragraph">
<p>In some cases, the distinction might seem obvious. The list of numbers <code>(1 2 3 4 5)</code> could hardly be confused with a procedure application, since 1 is a number, not a procedure. So, the answer might be that Scheme looks at the first element of the list or procedure application and makes its decision based on whether that first element is a procedure or not. This answer is not good enough, since we might even want to treat a valid procedure application such as <code>(+ 3 4)</code> as a list. The answer is that we must tell Scheme explicitly to treat a list as data rather than as a procedure application. We do this with <code>quote</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(quote (1 2 3 4 5)) ⇒ (1 2 3 4 5)
(quote ("this" "is" "a" "list")) ⇒ ("this" "is" "a" "list")
(quote (+ 3 4)) ⇒ (+ 3 4)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>quote</code> forces the list to be treated as data. Try entering the above expressions without the quote; you will likely receive a message indicating that an exception has occurred for the first two and an incorrect answer (<code>7</code>) for the third.</p>
</div>
<div class="paragraph">
<p>Because <code>quote</code> is required fairly frequently in Scheme code, Scheme recognizes a single quotation mark ( <code>'</code> ) preceding an expression as an abbreviation for <code>quote</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">'(1 2 3 4) ⇒ (1 2 3 4)
'((1 2) (3 4)) ⇒ ((1 2) (3 4))
'(/ (* 2 -1) 3) ⇒ (/ (* 2 -1) 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Both forms are referred to as <code>quote</code> expressions. We often say an object is <em>quoted</em> when it is enclosed in a <code>quote</code> expression.</p>
</div>
<div class="paragraph">
<p>A <code>quote</code> expression is <em>not</em> a procedure application, since it inhibits the evaluation of its subexpression. It is an entirely different syntactic form. Scheme supports several other syntactic forms in addition to procedure applications and <code>quote</code> expressions. Each syntactic form is evaluated differently. Fortunately, the number of different syntactic forms is small. We will see more of them later in this chapter.</p>
</div>
<div class="paragraph">
<p>Not all <code>quote</code> expressions involve lists. Try the following expression with and without the <code>quote</code> wrapper.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(quote hello) ⇒ hello</code></pre>
</div>
</div>
<div class="paragraph">
<p>The symbol <code>hello</code> must be quoted in order to prevent Scheme from treating <code>hello</code> as a <em>variable</em>. Symbols and variables in Scheme are similar to symbols and variables in mathematical expressions and equations. When we evaluate the mathematical expression \(1 - x\) for some value of \(x\), we think of \(x\) as a variable. On the other hand, when we consider the algebraic equation \(x^2 - 1 = (x - 1)(x + 1)\), we think of \(x\) as a symbol (in fact, we think of the whole equation symbolically). Just as quoting a list tells Scheme to treat a parenthesized form as a list rather than as a procedure application, quoting an identifier tells Scheme to treat the identifier as a symbol rather than as a variable. While symbols are commonly used to represent variables in symbolic representations of equations or programs, symbols may also be used, for example, as words in the representation of natural language sentences.</p>
</div>
<div class="paragraph">
<p>You might wonder why applications and variables share notations with lists and symbols. The shared notation allows Scheme programs to be represented as Scheme data, simplifying the writing of interpreters, compilers, editors, and other tools in Scheme. This is demonstrated by the Scheme interpreter given in <a href="#section_12.7.">Section 12.7</a>, which is itself written in Scheme. Many people believe this to be one of the most important features of Scheme.</p>
</div>
<div class="paragraph">
<p>Numbers and strings may be quoted, too.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">'2 ⇒ 2
'2/3 ⇒ 2/3
(quote "Hi Mom!") ⇒ "Hi Mom!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Numbers and strings are treated as constants in any case, however, so quoting them is unnecessary.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s discuss some Scheme procedures for manipulating lists. There are two basic procedures for taking lists apart: <code>car</code> and <code>cdr</code> (pronounced <em>could-er</em>). <code>car</code> returns the first element of a list, and <code>cdr</code> returns the remainder of the list. (The names "car" and "cdr" are derived from operations supported by the first computer on which a Lisp language was implemented, the IBM 704.) Each requires a nonempty list as its argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(car '(a b c)) ⇒ a
(cdr '(a b c)) ⇒ (b c)
(cdr '(a)) ⇒ ()

(car (cdr '(a b c))) ⇒ b
(cdr (cdr '(a b c))) ⇒ (c)

(car '((a b) (c d))) ⇒ (a b)
(cdr '((a b) (c d))) ⇒ ((c d))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first element of a list is often called the "car" of the list, and the rest of the list is often called the "cdr" of the list. The cdr of a list with one element is <code>()</code>, the <em>empty list</em>.</p>
</div>
<div class="paragraph">
<p>The procedure <code>cons</code> constructs lists. It takes two arguments. The second argument is usually a list, and in that case <code>cons</code> returns a list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(cons 'a '()) ⇒ (a)
(cons 'a '(b c)) ⇒ (a b c)
(cons 'a (cons 'b (cons 'c '()))) ⇒ (a b c)
(cons '(a b) '(c d)) ⇒ ((a b) c d)

(car (cons 'a '(b c))) ⇒ a
(cdr (cons 'a '(b c))) ⇒ (b c)
(cons (car '(a b c))
      (cdr '(d e f))) ⇒ (a e f)
(cons (car '(a b c))
      (cdr '(a b c))) ⇒ (a b c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just as "car" and "cdr" are often used as nouns, "cons" is often used as a verb. Creating a new list by adding an element to the beginning of a list is referred to as <em>consing</em> the element onto the list.</p>
</div>
<div class="paragraph">
<p>Notice the word "usually" in the description of <code>cons</code>'s second argument. The procedure <code>cons</code> actually builds <em>pairs</em>, and there is no reason that the cdr of a pair must be a list. A list is a sequence of pairs; each pair&#8217;s cdr is the next pair in the sequence.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/1.gif" alt="1">
</div>
</div>
<div class="paragraph">
<p>The cdr of the last pair in a <em>proper list</em> is the empty list. Otherwise, the sequence of pairs forms an <em>improper list</em>. More formally, the empty list is a proper list, and any pair whose cdr is a proper list is a proper list.</p>
</div>
<div class="paragraph">
<p>An improper list is printed in <em>dotted-pair notation</em>, with a period, or <em>dot</em>, preceding the final element of the list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(cons 'a 'b) ⇒ (a . b)
(cdr '(a . b)) ⇒ b
(cons 'a '(b . c)) ⇒ (a b . c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because of its printed notation, a pair whose cdr is not a list is often called a <em>dotted pair</em>. Even pairs whose cdrs are lists can be written in dotted-pair notation, however, although the printer always chooses to write proper lists without dots.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">'(a . (b . (c . ()))) ⇒ (a b c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The procedure <code>list</code> is similar to <code>cons</code>, except that it takes an arbitrary number of arguments and always builds a proper list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(list 'a 'b 'c) ⇒ (a b c)
(list 'a) ⇒ (a)
(list) ⇒ ()</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#section_6.3.">Section 6.3</a> provides more information on lists and the Scheme procedures for manipulating them. This might be a good time to turn to that section and familiarize yourself with the other procedures given there.</p>
</div>
<div class="sect3">
<h4 id="exercise_2.2.1">Exercise 2.2.1</h4>
<div class="paragraph">
<p>Convert the following arithmetic expressions into Scheme expressions and evaluate them.</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>\(1.2 × (2 - 1/3) + -8.7\)</p>
</li>
<li>
<p>\((2/3 + 4/9) ÷ (5/11 - 4/3)\)</p>
</li>
<li>
<p>\(1 + 1 ÷ (2 + 1 ÷ (1 + 1/2))\)</p>
</li>
<li>
<p>\(1 × -2 × 3 × -4 × 5 × -6 × 7\)</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.2.2">Exercise 2.2.2</h4>
<div id="start:s35" class="paragraph">
<p>Experiment with the procedures <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code> to determine Scheme&#8217;s rules for the type of value returned by each when given different types of numeric arguments.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.2.3">Exercise 2.2.3</h4>
<div class="paragraph">
<p>Determine the values of the following expressions. Use your Scheme system to verify your answers.</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(cons 'car 'cdr)</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(list 'this '(is silly))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(cons 'is '(this silly?))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(quote (+ 2 3))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(cons '+ '(2 3))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(car '(+ 2 3))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(cdr '(+ 2 3))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">cons</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(quote cons)</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(quote (quote cons))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">car (quote (quote cons)))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(+ 2 3)</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(+ '2 '3)</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(+ (car '(2 3)) (car (cdr '(2 3))))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">((car (list + - * /)) 2 3)</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.2.4">Exercise 2.2.4</h4>
<div class="paragraph">
<p><code>(car (car 'a b) (c d))</code> yields <code>a</code>. Determine which compositions of <code>car</code> and <code>cdr</code> applied to <code>a b) (c d</code> yield <code>b</code>, <code>c</code>, and <code>d</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.2.5">Exercise 2.2.5</h4>
<div id="start:s38" class="paragraph">
<p>Write a Scheme expression that evaluates to the following internal list structure.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/2.gif" alt="2">
</div>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.2.6">Exercise 2.2.6</h4>
<div class="paragraph">
<p>Draw the internal list structure produced by the expression below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(cons 1 (cons '(2 . ((3) . ())) (cons '(()) (cons 4 5))))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.2.7">Exercise 2.2.7</h4>
<div class="paragraph">
<p>The behavior of <code>(car (car (car 'a b) (c d)))</code> is undefined because <code>(car 'a b) (c d)</code> is <code>(a b)</code>, <code>(car '(a b))</code> is <code>a</code>, and <code>(car 'a)</code> is undefined. Determine all legal compositions of <code>car</code> and <code>cdr</code> applied to <code>a b) (c d</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.2.8">Exercise 2.2.8</h4>
<div id="start:s41" class="paragraph">
<p>Try to explain how Scheme expressions are evaluated. Does your explanation cover the last example in <a href="#exercise_2.2.3">Exercise 2.2.3</a>?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_2.3.">Section 2.3. Evaluating Scheme Expressions</h3>
<div class="paragraph">
<p>Let&#8217;s turn to a discussion of how Scheme evaluates the expressions you type. We have already established the rules for constant objects such as strings and numbers: the object itself is the value. You have probably also worked out in your mind a rule for evaluating procedure applications of the form <code>(<em>procedure</em> <em>arg<sub>1</sub></em> ... <em>arg<sub>n</sub></em>)</code>. Here, <code><em>procedure</em></code> is an expression representing a Scheme procedure, and <code><em>arg<sub>1</sub></em> ... <em>arg<sub>n</sub></em></code> are expressions representing its arguments. One possibility is the following.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Find the value of <code><em>procedure</em></code>.</p>
</li>
<li>
<p>Find the value of <code><em>arg<sub>1</sub></em></code>.<br>
&#8230;&#8203;</p>
</li>
<li>
<p>Find the value of <code><em>arg<sub>n</sub></em></code>.</p>
</li>
<li>
<p>Apply the value of <code><em>procedure</em></code> to the values of <code><em>arg<sub>1</sub></em> ... <em>arg<sub>n</sub></em></code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For example, consider the simple procedure application <code>(+ 3 4)</code>. The value of <code>+</code> is the addition procedure, the value of 3 is the number 3, and the value of 4 is the number 4. Applying the addition procedure to 3 and 4 yields 7, so our value is the object 7.</p>
</div>
<div class="paragraph">
<p>By applying this process at each level, we can find the value of the nested expression <code>(* (+ 3 4) 2)</code>. The value of <code>*</code> is the multiplication procedure, the value of <code>(+ 3 4)</code> we can determine to be the number 7, and the value of 2 is the number 2. Multiplying 7 by 2 we get 14, so our answer is 14.</p>
</div>
<div class="paragraph">
<p>This rule works for procedure applications but not for <code>quote</code> expressions because the subexpressions of a procedure application are evaluated, whereas the subexpression of a <code>quote</code> expression is not. The evaluation of a <code>quote</code> expression is more similar to the evaluation of constant objects. The value of a <code>quote</code> expression of the form <code>(quote <em>object</em>)</code> is simply <code><em>object</em></code>.</p>
</div>
<div class="paragraph">
<p>Constant objects, procedure applications, and <code>quote</code> expressions are only three of the many syntactic forms provided by Scheme. Fortunately, only a few of the other syntactic forms need to be understood directly by a Scheme programmer; these are referred to as <em>core</em> syntactic forms. The remaining syntactic forms are <em>syntactic extensions</em> defined, ultimately, in terms of the core syntactic forms. We will discuss the remaining core syntactic forms and a few syntactic extensions in the remaining sections of this chapter. <a href="#section_3.1.">Section 3.1</a> summarizes the core syntactic forms and introduces the syntactic extension mechanism.</p>
</div>
<div class="paragraph">
<p>Before we go on to more syntactic forms and procedures, two points related to the evaluation of procedure applications are worthy of note. First, the process given above is overspecified, in that it requires the subexpressions to be evaluated from left to right. That is, <code><em>procedure</em></code> is evaluated before <code><em>arg<sub>1</sub></em></code>, <code><em>arg<sub>1</sub></em></code> is evaluated before <code><em>arg<sub>2</sub></em></code>, and so on. This need not be the case. A Scheme evaluator is free to evaluate the expressions in any order---left to right, right to left, or any other sequential order. In fact, the subexpressions may be evaluated in different orders for different applications, even in the same implementation.</p>
</div>
<div class="paragraph">
<p>The second point is that <code><em>procedure</em></code> is evaluated in the same way as <code><em>arg<sub>1</sub></em> ... <em>arg<sub>n</sub></em></code>. While <code><em>procedure</em></code> is often a variable that names a particular procedure, this need not be the case. <a href="#exercise_2.2.3">Exercise 2.2.3</a> had you determine the value of the expression <code>car (list + - * / 2 3)</code>. Here, <code><em>procedure</em></code> is <code>(car (list + - * /))</code>. The value of <code>(car (list + - * /))</code> is the addition procedure, just as if <code><em>procedure</em></code> were simply the variable <code>+</code>.</p>
</div>
<div class="sect3">
<h4 id="exercise_2.3.1">Exercise 2.3.1</h4>
<div class="paragraph">
<p>Write down the steps necessary to evaluate the expression below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">((car (cdr (list + - * /))) 17 5)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_2.4.">Section 2.4. Variables and Let Expressions</h3>
<div class="paragraph">
<p>Suppose <code><em>expr</em></code> is a Scheme expression that contains a variable <code><em>var</em></code>. Suppose, additionally, that we would like <code><em>var</em></code> to have the value <code><em>val</em></code> when we evaluate <code><em>expr</em></code>. For example, we might like <code>x</code> to have the value 2 when we evaluate <code>(+ x 3)</code>. Or, we might want <code>y</code> to have the value 3 when we evaluate <code>(+ 2 y)</code>. The following examples demonstrate how to do this using Scheme&#8217;s <code>let</code> syntactic form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ((x 2))
  (+ x 3)) ⇒ 5

(let ((y 3))
  (+ 2 y)) ⇒ 5

(let ((x 2) (y 3))
  (+ x y)) ⇒ 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>let</code> syntactic form includes a list of variable-expression pairs, along with a sequence of expressions referred to as the <em>body</em> of the <code>let</code>. The general form of a <code>let</code> expression is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We say the variables are <em>bound</em> to the values by the <code>let</code>. We refer to variables bound by <code>let</code> as <code>let</code>-<em>bound</em> variables.</p>
</div>
<div class="paragraph">
<p>A <code>let</code> expression is often used to simplify an expression that would contain two identical subexpressions. Doing so also ensures that the value of the common subexpression is computed only once.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(+ (* 4 4) (* 4 4)) ⇒ 32

(let ((a (* 4 4))) (+ a a)) ⇒ 32</code></pre>
</div>
</div>
<div class="paragraph">
<p>Brackets are often used in place of parentheses to delimit the bindings of a <code>let</code> expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([list1 '(a b c)] [list2 '(d e f)])
  (cons (cons (car list1)
              (car list2))
        (cons (car (cdr list1))
              (car (cdr list2))))) ⇒ ((a . d) b . e)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Scheme treats forms enclosed in brackets just like forms enclosed in parentheses. An open bracket must be matched by a close bracket, and an open parenthesis must be matched by a close parenthesis. We use brackets for <code>let</code> (and, as we&#8217;ll see, several other standard syntactic forms) to improve readability, especially when we might otherwise have two or more consecutive open parentheses.</p>
</div>
<div class="paragraph">
<p>Since expressions in the first position of a procedure application are evaluated no differently from other expressions, a <code>let</code>-bound variable may be used there as well.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([f +])
  (f 2 3)) ⇒ 5

(let ([f +] [x 2])
  (f x 3)) ⇒ 5

(let ([f +] [x 2] [y 3])
  (f x y)) ⇒ 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>The variables bound by <code>let</code> are visible only within the body of the <code>let</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([+ *])
  (+ 2 3)) ⇒ 6

(+ 2 3) ⇒ 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is fortunate, because we would not want the value of <code>+</code> to be the multiplication procedure everywhere.</p>
</div>
<div class="paragraph">
<p>It is possible to nest <code>let</code> expressions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([a 4] [b -3])
  (let ([a-squared (* a a)]
        [b-squared (* b b)])
    (+ a-squared b-squared))) ⇒ 25</code></pre>
</div>
</div>
<div class="paragraph">
<p>When nested <code>let</code> expressions bind the same variable, only the binding created by the inner <code>let</code> is visible within its body.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 1])
  (let ([x (+ x 1)])
    (+ x x))) ⇒ 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>The outer <code>let</code> expression binds <code>x</code> to 1 within its body, which is the second <code>let</code> expression. The inner <code>let</code> expression binds <code>x</code> to <code>(+ x 1)</code> within its body, which is the expression <code>(+ x x)</code>. What is the value of <code>(+ x 1)</code>? Since <code>(+ x 1)</code> appears within the body of the outer <code>let</code> but not within the body of the inner <code>let</code>, the value of <code>x</code> must be 1 and hence the value of <code>(+ x 1)</code> is 2. What about <code>(+ x x)</code>? It appears within the body of both <code>let</code> expressions. Only the inner binding for <code>x</code> is visible, so <code>x</code> is 2 and <code>(+ x x)</code> is 4.</p>
</div>
<div class="paragraph">
<p>The inner binding for <code>x</code> is said to <em>shadow</em> the outer binding. A <code>let</code>-bound variable is visible everywhere within the body of its <code>let</code> expression except where it is shadowed. The region where a variable binding is visible is called its <em>scope</em>. The scope of the first <code>x</code> in the example above is the body of the outer <code>let</code> expression minus the body of the inner <code>let</code> expression, where it is shadowed by the second <code>x</code>. This form of scoping is referred to as <em>lexical scoping</em>, since the scope of each binding can be determined by a straightforward textual analysis of the program.</p>
</div>
<div class="paragraph">
<p>Shadowing may be avoided by choosing different names for variables. The expression above could be rewritten so that the variable bound by the inner <code>let</code> is <code>new-x</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 1])
  (let ([new-x (+ x 1)])
    (+ new-x new-x))) ⇒ 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although choosing different names can sometimes prevent confusion, shadowing can help prevent the accidental use of an "old" value. For example, with the original version of the preceding example, it would be impossible for us to mistakenly refer to the outer <code>x</code> within the body of the inner <code>let</code>.</p>
</div>
<div class="sect3">
<h4 id="exercise_2.4.1">Exercise 2.4.1</h4>
<div id="start:s57" class="paragraph">
<p>Rewrite the following expressions, using <code>let</code> to remove common subexpressions and to improve the structure of the code. Do not perform any algebraic simplifications.</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(+ (- (* 3 a) b) (+ (* 3 a) b))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(cons (car (list a b c)) (cdr (list a b c)))</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.4.2">Exercise 2.4.2</h4>
<div class="paragraph">
<p>Determine the value of the following expression. Explain how you derived this value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 9])
  (* x
     (let ([x (/ x 3)])
       (+ x x))))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.4.3">Exercise 2.4.3</h4>
<div id="start:s59" class="paragraph">
<p>Rewrite the following expressions to give unique names to each different <code>let</code>-bound variable so that none of the variables is shadowed. Verify that the value of your expression is the same as that of the original expression.</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 'a] [y 'b])
  (list (let ([x 'c]) (cons x y))
        (let ([y 'd]) (cons x y))))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x '((a b) c)])
  (cons (let ([x (cdr x)])
          (car x))
        (let ([x (car x)])
          (cons (let ([x (cdr x)])
                  (car x))
                (cons (let ([x (car x)])
                        x)
                      (cdr x))))))</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_2.5.">Section 2.5. Lambda Expressions</h3>
<div class="paragraph">
<p>In the expression <code>(let ([x (* 3 4)]) (+ x x))</code>, the variable <code>x</code> is bound to the value of <code>(* 3 4)</code>. What if we would like the value of <code>(+ x x)</code> where <code>x</code> is bound to the value of <code>(/ 99 11)</code>? Where <code>x</code> is bound to the value of <code>(- 2 7)</code>? In each case we need a different <code>let</code> expression. When the body of the <code>let</code> is complicated, however, having to repeat it can be inconvenient.</p>
</div>
<div class="paragraph">
<p>Instead, we can use the syntactic form <code>lambda</code> to create a new procedure that has <code>x</code> as a parameter and has the same body as the <code>let</code> expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (x) (+ x x)) ⇒ #&lt;procedure&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The general form of a <code>lambda</code> expression is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (<em>var</em> ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The variables <code><em>var</em> ...</code> are the <em>formal parameters</em> of the procedure, and the sequence of expressions <code><em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...</code> is its body. (Actually, the true general form is somewhat more general than this, as you will see later.)</p>
</div>
<div class="paragraph">
<p>A procedure is just as much an object as a number, string, symbol, or pair. It does not have any meaningful printed representation as far as Scheme is concerned, however, so this book uses the notation <code>#&lt;procedure&gt;</code> to show that the value of an expression is a procedure.</p>
</div>
<div class="paragraph">
<p>The most common operation to perform on a procedure is to apply it to one or more values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">((lambda (x) (+ x x)) (* 3 4)) ⇒ 24</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is no different from any other procedure application. The procedure is the value of <code>(lambda (x) (+ x x))</code>, and the only argument is the value of <code>(* 3 4)</code>, or 12. The argument values, or <em>actual parameters</em>, are bound to the formal parameters within the body of the <code>lambda</code> expression in the same way as <code>let</code>-bound variables are bound to their values. In this case, <code>x</code> is bound to 12, and the value of <code>(+ x x)</code> is 24. Thus, the result of applying the procedure to the value 12 is 24.</p>
</div>
<div class="paragraph">
<p>Because procedures are objects, we can establish a procedure as the value of a variable and use the procedure more than once.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([double (lambda (x) (+ x x))])
  (list (double (* 3 4))
        (double (/ 99 11))
        (double (- 2 7)))) ⇒ (24 18 -10)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, we establish a binding for <code>double</code> to a procedure, then use this procedure to double three different values.</p>
</div>
<div class="paragraph">
<p>The procedure expects its actual parameter to be a number, since it passes the actual parameter on to <code>+</code>. In general, the actual parameter may be any sort of object. Consider, for example, a similar procedure that uses <code>cons</code> instead of <code>+</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([double-cons (lambda (x) (cons x x))])
  (double-cons 'a)) ⇒ (a . a)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Noting the similarity between <code>double</code> and <code>double-cons</code>, you should not be surprised to learn that they may be collapsed into a single procedure by adding an additional argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([double-any (lambda (f x) (f x x))])
  (list (double-any + 13)
        (double-any cons 'a))) ⇒ (26 (a . a))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This demonstrates that procedures may accept more than one argument and that arguments passed to a procedure may themselves be procedures.</p>
</div>
<div class="paragraph">
<p>As with <code>let</code> expressions, <code>lambda</code> expressions become somewhat more interesting when they are nested within other <code>lambda</code> or <code>let</code> expressions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 'a])
  (let ([f (lambda (y) (list x y))])
    (f 'b))) ⇒ (a b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The occurrence of <code>x</code> within the <code>lambda</code> expression refers to the <code>x</code> outside the <code>lambda</code> that is bound by the outer <code>let</code> expression. The variable <code>x</code> is said to <em>occur free</em> in the <code>lambda</code> expression or to be a <em>free variable</em> of the <code>lambda</code> expression. The variable <code>y</code> does not occur free in the <code>lambda</code> expression since it is bound by the <code>lambda</code> expression. A variable that occurs free in a <code>lambda</code> expression should be bound, e.g., by an enclosing <code>lambda</code> or <code>let</code> expression, unless the variable is (like the names of primitive procedures) bound outside of the expression, as we discuss in the following section.</p>
</div>
<div class="paragraph">
<p>What happens when the procedure is applied somewhere outside the scope of the bindings for variables that occur free within the procedure, as in the following expression?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([f (let ([x 'sam])
           (lambda (y z) (list x y z)))])
  (f 'i 'am)) ⇒ (sam i am)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The answer is that the same bindings that were in effect when the procedure was created are in effect again when the procedure is applied. This is true even if another binding for <code>x</code> is visible where the procedure is applied.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([f (let ([x 'sam])
           (lambda (y z) (list x y z)))])
  (let ([x 'not-sam])
    (f 'i 'am))) ⇒ (sam i am)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In both cases, the value of <code>x</code> within the procedure named <code>f</code> is <code>sam</code>.</p>
</div>
<div class="paragraph">
<p>Incidentally, a <code>let</code> expression is nothing more than the direct application of a <code>lambda</code> expression to a set of argument expressions. For example, the two expressions below are equivalent.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 'a]) (cons x x)) ≡ ((lambda (x) (cons x x)) 'a)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In fact, a <code>let</code> expression is a syntactic extension defined in terms of <code>lambda</code> and procedure application, which are both core syntactic forms. In general, any expression of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to the following.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">((lambda (<em>var</em> ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)
 <em>expr</em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#section_3.1.">Section 3.1</a> for more about core forms and syntactic extensions.</p>
</div>
<div class="paragraph">
<p>As mentioned above, the general form of <code>lambda</code> is a bit more complicated than the form we saw earlier, in that the formal parameter specification, <code>(<em>var</em> &#8230;&#8203;)</code>, need not be a proper list, or indeed even a list at all. The formal parameter specification can be in any of the following three forms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a proper list of variables, <code>(<em>var<sub>1</sub></em> ... <em>var<sub>n</sub></em>)</code>, such as we have already seen,</p>
</li>
<li>
<p>a single variable, <code><em>var<sub>r</sub></em></code>, or</p>
</li>
<li>
<p>an improper list of variables, <code>(<em>var<sub>1</sub></em> ... <em>var<sub>n</sub></em> . <em>var<sub>r</sub></em>)</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the first case, exactly <em>n</em> actual parameters must be supplied, and each variable is bound to the corresponding actual parameter. In the second, any number of actual parameters is valid; all of the actual parameters are put into a single list and the single variable is bound to this list. The third case is a hybrid of the first two cases. At least <em>n</em> actual parameters must be supplied. The variables <code><em>var<sub>1</sub></em> ... <em>var<sub>n</sub></em></code> are bound to the corresponding actual parameters, and the variable <code><em>var<sub>r</sub></em></code> is bound to a list containing the remaining actual parameters. In the second and third cases, <code><em>var<sub>r</sub></em></code> is sometimes referred to as a "rest" parameter because it holds the rest of the actual parameters beyond those that are individually named.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider a few examples to help clarify the more general syntax of <code>lambda</code> expressions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([f (lambda x x)])
  (f 1 2 3 4)) ⇒ (1 2 3 4)

(let ([f (lambda x x)])
  (f)) ⇒ ()

(let ([g (lambda (x . y) (list x y))])
  (g 1 2 3 4)) ⇒ (1 (2 3 4))

(let ([h (lambda (x y . z) (list x y z))])
  (h 'a 'b 'c 'd)) ⇒ (a b (c d))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the first two examples, the procedure named <code>f</code> accepts any number of arguments. These arguments are automatically formed into a list to which the variable <code>x</code> is bound; the value of <code>f</code> is this list. In the first example, the arguments are 1, 2, 3, and 4, so the answer is <code>(1 2 3 4)</code>. In the second, there are no arguments, so the answer is the empty list <code>()</code>. The value of the procedure named <code>g</code> in the third example is a list whose first element is the first argument and whose second element is a list containing the remaining arguments. The procedure named <code>h</code> is similar but separates out the second argument. While <code>f</code> accepts any number of arguments, <code>g</code> must receive at least one and <code>h</code> must receive at least two.</p>
</div>
<div class="sect3">
<h4 id="exercise_2.5.1">Exercise 2.5.1</h4>
<div class="paragraph">
<p>Determine the values of the expressions below.</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([f (lambda (x) x)])
  (f 'a))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([f (lambda x x)])
  (f 'a))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([f (lambda (x . y) x)])
  (f 'a))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([f (lambda (x . y) y)])
  (f 'a))</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.5.2">Exercise 2.5.2</h4>
<div id="start:s73" class="paragraph">
<p>How might the primitive procedure <code>list</code> be defined?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.5.3">Exercise 2.5.3</h4>
<div class="paragraph">
<p>List the variables that occur free in each of the <code>lambda</code> expressions below. Do not omit variables that name primitive procedures such as <code>+</code> or <code>cons</code>.</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (f x) (f x))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (x) (+ x x))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (x y) (f x y))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (x)
  (cons x (f x y)))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (x)
  (let ([z (cons x y)])
    (x y z)))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (x)
  (let ([y (cons x y)])
    (x y z)))</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_2.6.">Section 2.6. Top-Level Definitions</h3>
<div class="paragraph">
<p>The variables bound by <code>let</code> and <code>lambda</code> expressions are not visible outside the bodies of these expressions. Suppose you have created an object, perhaps a procedure, that must be accessible anywhere, like <code>+</code> or <code>cons</code>. What you need is a <em>top-level definition</em>, which may be established with <code>define</code>. Top-level definitions, which are supported by most interactive Scheme systems, are visible in every expression you enter, except where shadowed by another binding.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s establish a top-level definition of the <code>double-any</code> procedure of the last section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define double-any
  (lambda (f x)
    (f x x)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The variable <code>double-any</code> now has the same status as <code>cons</code> or the name of any other primitive procedure. We can use <code>double-any</code> as if it were a primitive procedure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(double-any + 10) ⇒ 20
(double-any cons 'a) ⇒ (a . a)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A top-level definition may be established for any object, not just for procedures.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define sandwich "peanut-butter-and-jelly")

sandwich ⇒ "peanut-butter-and-jelly"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most often, though, top-level definitions are used for procedures.</p>
</div>
<div class="paragraph">
<p>As suggested above, top-level definitions may be shadowed by <code>let</code> or <code>lambda</code> bindings.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define xyz '(x y z))
(let ([xyz '(z y x)])
  xyz) ⇒ (z y x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Variables with top-level definitions act almost as if they were bound by a <code>let</code> expression enclosing all of the expressions you type.</p>
</div>
<div id="defn:list" class="paragraph">
<p>Given only the simple tools you have read about up to this point, it is already possible to define some of the primitive procedures provided by Scheme and described later in this book. If you completed the exercises from the last section, you should already know how to define <code>list</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define list (lambda x x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Also, Scheme provides the abbreviations <code>cadr</code> and <code>cddr</code> for the compositions of <code>car</code> with <code>cdr</code> and <code>cdr</code> with <code>cdr</code>. That is, <code>(cadr <em>list</em>)</code> is equivalent to <code>(car (cdr <em>list</em>))</code>, and, similarly, <code>(cddr <em>list</em>)</code> is equivalent to <code>(cdr (cdr <em>list</em>))</code>. They are easily defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define cadr
  (lambda (x)
    (car (cdr x))))

(define cddr
  (lambda (x)
    (cdr (cdr x))))

(cadr '(a b c)) ⇒ b
(cddr '(a b c)) ⇒ (c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any definition <code>(define <em>var</em> <em>expr</em>)</code> where <code><em>expr</em></code> is a <code>lambda</code> expression can be written in a shorter form that suppresses the <code>lambda</code>. The exact syntax depends upon the format of the <code>lambda</code> expression&#8217;s formal parameter specifier, i.e., whether it is a proper list of variables, a single variable, or an improper list of variables. A definition of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define <em>var<sub>0</sub></em>
  (lambda (<em>var<sub>1</sub></em> ... <em>var<sub>n</sub></em>)
    <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>may be abbreviated</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define (<em>var<sub>0</sub></em> <em>var<sub>1</sub></em> ... <em>var<sub>n</sub></em>)
  <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>while</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define <em>var<sub>0</sub></em>
  (lambda <em>var<sub>r</sub></em>
    <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>may be abbreviated</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define (<em>var<sub>0</sub></em> . <em>var<sub>r</sub></em>)
  <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>and</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define <em>var<sub>0</sub></em>
  (lambda (<em>var<sub>1</sub></em> ... <em>var<sub>n</sub></em> . <em>var<sub>r</sub></em>)
    <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>may be abbreviated</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define (<em>var<sub>0</sub></em> <em>var<sub>1</sub></em> ... <em>var<sub>n</sub></em> . <em>var<sub>r</sub></em>)
  <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, the definitions of <code>cadr</code> and <code>list</code> might be written as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define (cadr x)
  (car (cdr x)))

(define (list . x) x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This book does not often employ this alternative syntax. Although it is shorter, it tends to mask the reality that procedures are not intimately tied to variables, or names, as they are in many other languages. This syntax is often referred to, somewhat pejoratively, as the "defun" syntax for <code>define</code>, after the <code>defun</code> form provided by Lisp languages in which procedures are more closely tied to their names.</p>
</div>
<div class="paragraph">
<p>Top-level definitions make it easier for us to experiment with a procedure interactively because we need not retype the procedure each time it is used. Let&#8217;s try defining a somewhat more complicated variation of <code>double-any</code>, one that turns an "ordinary" two-argument procedure into a "doubling" one-argument procedure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define doubler
  (lambda (f)
    (lambda (x) (f x x))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>doubler</code> accepts one argument, <code>f</code>, which must be a procedure that accepts two arguments. The procedure returned by <code>doubler</code> accepts one argument, which it uses for both arguments in an application of <code>f</code>. We can define, with <code>doubler</code>, the simple <code>double</code> and <code>double-cons</code> procedures of the last section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define double (doubler +))
(double 13/2) ⇒ 13

(define double-cons (doubler cons))
(double-cons 'a) ⇒ (a . a)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also define <code>double-any</code> with <code>doubler</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define double-any
  (lambda (f x)
    ((doubler f) x)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Within <code>double</code> and <code>double-cons</code>, <code>f</code> has the appropriate value, i.e., <code>+</code> or <code>cons</code>, even though the procedures are clearly applied outside the scope of <code>f</code>.</p>
</div>
<div class="paragraph">
<p>What happens if you attempt to use a variable that is not bound by a <code>let</code> or <code>lambda</code> expression and that does not have a top-level definition? Try using the variable <code>i-am-not-defined</code> to see what happens.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(i-am-not-defined 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Most Scheme systems print a message indicating that an unbound- or undefined-variable exception has occurred.</p>
</div>
<div class="paragraph">
<p>The system should not, however, complain about the appearance of an undefined variable within a <code>lambda</code> expression, until and unless the resulting procedure is applied. The following should <em>not</em> cause an exception, even though we have not yet established a top-level definition of <code>proc2</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define proc1
  (lambda (x y)
    (proc2 y x)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you try to apply <code>proc1</code> before defining <code>proc2</code>, you should get a undefined exception message. Let&#8217;s give <code>proc2</code> a top-level definition and try <code>proc1</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define proc2 cons)
(proc1 'a 'b) ⇒ (b . a)</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you define <code>proc1</code>, the system accepts your promise to define <code>proc2</code>, and does not complain unless you use <code>proc1</code> before defining <code>proc2</code>. This allows you to define procedures in any order you please. This is especially useful when you are trying to organize a file full of procedure definitions in a way that makes your program more readable. It is necessary when two procedures defined at top level depend upon each other; we will see some examples of this later.</p>
</div>
<div class="sect3">
<h4 id="exercise_2.6.1">Exercise 2.6.1</h4>
<div class="paragraph">
<p>What would happen if you were to type</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(double-any double-any double-any)</code></pre>
</div>
</div>
<div class="paragraph">
<p>given the definition of <code>double-any</code> from the beginning of this section?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.6.2">Exercise 2.6.2</h4>
<div class="paragraph">
<p>A more elegant (though possibly less efficient) way to define <code>cadr</code> and <code>cddr</code> than given in this section is to define a procedure that composes two procedures to create a third. Write the procedure <code>compose</code>, such that <code>(compose <em>p<sub>1</sub></em> <em>p<sub>2</sub></em>)</code> is the composition of <code><em>p<sub>1</sub></em></code> and <code><em>p<sub>2</sub></em></code> (assuming both take one argument). That is, <code>(compose <em>p<sub>1</sub></em> <em>p<sub>2</sub></em>)</code> should return a new procedure of one argument that applies <code><em>p<sub>1</sub></em></code> to the result of applying <code><em>p<sub>2</sub></em></code> to the argument. Use <code>compose</code> to define <code>cadr</code> and <code>cddr</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.6.3">Exercise 2.6.3</h4>
<div id="start:s96" class="paragraph">
<p>Scheme also provides <code>caar</code>, <code>cdar</code>, <code>caaar</code>, <code>caadr</code>, and so on, with any combination of up to four <code>a</code>'s (representing <code>car</code>) and <code>d</code>'s (representing <code>cdr</code>) between the <code>c</code> and the <code>r</code> (see <a href="#section_6.3.">Section 6.3</a>). Define each of these with the <code>compose</code> procedure of the preceding exercise.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_2.7.">Section 2.7. Conditional Expressions</h3>
<div class="paragraph">
<p>So far we have considered expressions that perform a given task unconditionally. Suppose that we wish to write the procedure <code>abs</code>. If its argument <em>x</em> is negative, <code>abs</code> returns -<em>x</em>; otherwise, it returns <em>x</em>. The most straightforward way to write <code>abs</code> is to determine whether the argument is negative and if so negate it, using the <code>if</code> syntactic form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define abs
  (lambda (n)
    (if (< n 0)
        (- 0 n)
        n)))

(abs 77) ⇒ 77
(abs -77) ⇒ 77</code></pre>
</div>
</div>
<div class="paragraph">
<p>An <code>if</code> expression has the form <code>(if <em>test</em> <em>consequent</em> <em>alternative</em>)</code>, where <code><em>consequent</em></code> is the expression to evaluate if <code><em>test</em></code> is true and <code><em>alternative</em></code> is the expression to evaluate if <code><em>test</em></code> is false. In the expression above, <code><em>test</em></code> is <code>(&lt; n 0)</code>, <code><em>consequent</em></code> is <code>(- 0 n)</code>, and <code><em>alternative</em></code> is <code>n</code>.</p>
</div>
<div class="paragraph">
<p>The procedure <code>abs</code> could be written in a variety of other ways. Any of the following are valid definitions of <code>abs</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define abs
  (lambda (n)
    (if (>= n 0)
        n
        (- 0 n))))

(define abs
  (lambda (n)
    (if (not (< n 0))
        n
        (- 0 n))))

(define abs
  (lambda (n)
    (if (or (> n 0) (= n 0))
        n
        (- 0 n))))

(define abs
  (lambda (n)
    (if (= n 0)
        0
        (if (< n 0)
            (- 0 n)
            n))))

(define abs
  (lambda (n)
    ((if (>= n 0) + -)
     0
     n)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first of these definitions asks if <code>n</code> is greater than or equal to zero, inverting the test. The second asks if <code>n</code> is not less than zero, using the procedure <code>not</code> with <code>&lt;</code>. The third asks if <code>n</code> is greater than zero or <code>n</code> is equal to zero, using the syntactic form <code>or</code>. The fourth treats zero separately, though there is no benefit in doing so. The fifth is somewhat tricky; <code>n</code> is either added to or subtracted from zero, depending upon whether <code>n</code> is greater than or equal to zero.</p>
</div>
<div class="paragraph">
<p>Why is <code>if</code> a syntactic form and not a procedure? In order to answer this, let&#8217;s revisit the definition of <code>reciprocal</code> from the first section of this chapter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define reciprocal
  (lambda (n)
    (if (= n 0)
        "oops!"
        (/ 1 n))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second argument to the division procedure should not be zero, since the result is mathematically undefined. Our definition of <code>reciprocal</code> avoids this problem by testing for zero before dividing. Were <code>if</code> a procedure, its arguments (including <code>(/ 1 n)</code>) would be evaluated before it had a chance to choose between the consequent and alternative. Like <code>quote</code>, which does not evaluate its only subexpression, <code>if</code> does not evaluate all of its subexpressions and so cannot be a procedure.</p>
</div>
<div class="paragraph">
<p>The syntactic form <code>or</code> operates in a manner similar to <code>if</code>. The general form of an <code>or</code> expression is <code>(or <em>expr</em> ...)</code>. If there are no subexpressions, i.e., the expression is simply <code>(or)</code>, the value is false. Otherwise, each <code><em>expr</em></code> is evaluated in turn until either (a) one of the expressions evaluates to true or (b) no more expressions are left. In case (a), the value is true; in case (b), the value is false.</p>
</div>
<div class="paragraph">
<p>To be more precise, in case (a), the value of the <code>or</code> expression is the value of the last subexpression evaluated. This clarification is necessary because there are many possible true values. Usually, the value of a test expression is one of the two objects <code>#t</code>, for true, or <code>#f</code>, for false.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(< -1 0) ⇒ #t
(> -1 0) ⇒ #f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Every Scheme object, however, is considered to be either true or false by conditional expressions and by the procedure <code>not</code>. Only <code>#f</code> is considered false; all other objects are considered true.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(if #t 'true 'false) ⇒ true
(if #f 'true 'false) ⇒ false
(if '() 'true 'false) ⇒ true
(if 1 'true 'false) ⇒ true
(if '(a b c) 'true 'false) ⇒ true

(not #t) ⇒ #f
(not "false") ⇒ #f
(not #f) ⇒ #t

(or) ⇒ #f
(or #f) ⇒ #f
(or #f #t) ⇒ #t
(or #f 'a #f) ⇒ a</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>and</code> syntactic form is similar in form to <code>or</code>, but an <code>and</code> expression is true if all its subexpressions are true, and false otherwise. In the case where there are no subexpressions, i.e., the expression is simply <code>(and)</code>, the value is true. Otherwise, the subexpressions are evaluated in turn until either no more subexpressions are left or the value of a subexpression is false. The value of the <code>and</code> expression is the value of the last subexpression evaluated.</p>
</div>
<div class="paragraph">
<p>Using <code>and</code>, we can define a slightly different version of <code>reciprocal</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define reciprocal
  (lambda (n)
    (and (not (= n 0))
         (/ 1 n))))

(reciprocal 3) ⇒ 1/3
(reciprocal 0.5) ⇒ 2.0
(reciprocal 0) ⇒ #f</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this version, the value is <code>#f</code> if <code>n</code> is zero and <code>1/n</code> otherwise.</p>
</div>
<div class="paragraph">
<p>The procedures <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code> are called <em>predicates</em>. A predicate is a procedure that answers a specific question about its arguments and returns one of the two values <code>#t</code> or <code>#f</code>. The names of most predicates end with a question mark ( <code>?</code> ); the common numeric procedures listed above are exceptions to this rule. Not all predicates require numeric arguments, of course. The predicate <code>null?</code> returns true if its argument is the empty list <code>()</code> and false otherwise.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(null? '()) ⇒ #t
(null? 'abc) ⇒ #f
(null? '(x y z)) ⇒ #f
(null? (cdddr '(x y z))) ⇒ #t</code></pre>
</div>
</div>
<div class="paragraph">
<p>The procedure <code>cdr</code> must not be passed anything other than a pair, and an exception is raised when this happens. Common Lisp, however, defines <code>(cdr '())</code> to be <code>()</code>. The following procedure, <code>lisp-cdr</code>, is defined using <code>null?</code> to return <code>()</code> if its argument is <code>()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define lisp-cdr
  (lambda (x)
    (if (null? x)
        '()
        (cdr x))))

(lisp-cdr '(a b c)) ⇒ (b c)
(lisp-cdr '(c)) ⇒ ()
(lisp-cdr '()) ⇒ ()</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another useful predicate is <code>eqv?</code>, which requires two arguments. If the two arguments are equivalent, <code>eqv?</code> returns true. Otherwise, <code>eqv?</code> returns false.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(eqv? 'a 'a) ⇒ #t
(eqv? 'a 'b) ⇒ #f
(eqv? #f #f) ⇒ #t
(eqv? #t #t) ⇒ #t
(eqv? #f #t) ⇒ #f
(eqv? 3 3) ⇒ #t
(eqv? 3 2) ⇒ #f
(let ([x "Hi Mom!"])
  (eqv? x x)) ⇒ #t
(let ([x (cons 'a 'b)])
  (eqv? x x)) ⇒ #t
(eqv? (cons 'a 'b) (cons 'a 'b)) ⇒ #f</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, <code>eqv?</code> returns true if the arguments are the same symbol, boolean, number, pair, or string. Two pairs are not the same by <code>eqv?</code> if they are created by different calls to <code>cons</code>, even if they have the same contents. Detailed equivalence rules for <code>eqv?</code> are given in <a href="#section_6.2.">Section 6.2</a>.</p>
</div>
<div class="paragraph">
<p>Scheme also provides a set of <em>type predicates</em> that return true or false depending on the type of the object, e.g., <code>pair?</code>, <code>symbol?</code>, <code>number?</code>, and <code>string?</code>. The predicate <code>pair?</code>, for example, returns true only if its argument is a pair.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(pair? '(a . c)) ⇒ #t
(pair? '(a b c)) ⇒ #t
(pair? '()) ⇒ #f
(pair? 'abc) ⇒ #f
(pair? "Hi Mom!") ⇒ #f
(pair? 1234567890) ⇒ #f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Type predicates are useful for deciding if the argument passed to a procedure is of the appropriate type. For example, the following version of <code>reciprocal</code> checks first to see that its argument is a number before testing against zero or performing the division.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define reciprocal
  (lambda (n)
    (if (and (number? n) (not (= n 0)))
        (/ 1 n)
        "oops!")))

(reciprocal 2/3) ⇒ 3/2
(reciprocal 'a) ⇒ "oops!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>By the way, the code that uses <code>reciprocal</code> must check to see that the returned value is a number and not a string. To relieve the caller of this obligation, it is usually preferable to report the error, using <code>assertion-violation</code>, as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define reciprocal
  (lambda (n)
    (if (and (number? n) (not (= n 0)))
        (/ 1 n)
        (assertion-violation 'reciprocal
          "improper argument"
          n))))

(reciprocal .25) ⇒ 4.0
(reciprocal 0) ⇒ <em>exception in reciprocal: improper argument 0</em>
(reciprocal 'a) ⇒ <em>exception in reciprocal: improper argument a</em></code></pre>
</div>
</div>
<div class="paragraph">
<p>The first argument to <code>assertion-violation</code> is a symbol identifying where the message originates, the second is a string describing the error, and the third and subsequent arguments are "irritants" to be included with the error message.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at one more conditional expression, <code>cond</code>, that is often useful in place of <code>if</code>. <code>cond</code> is similar to <code>if</code> except that it allows multiple test and alternative expressions. Consider the following definition of <code>sign</code>, which returns <code>-1</code> for negative inputs, <code>+1</code> for positive inputs, and <code>0</code> for zero.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define sign
  (lambda (n)
    (if (< n 0)
        -1
        (if (> n 0)
            +1
            0))))

(sign -88.3) ⇒ -1
(sign 0) ⇒ 0
(sign 333333333333) ⇒ 1
(* (sign -88.3) (abs -88.3)) ⇒ -88.3</code></pre>
</div>
</div>
<div class="paragraph">
<p>The two <code>if</code> expressions may be replaced by a single <code>cond</code> expression as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define sign
  (lambda (n)
    (cond
      [(< n 0) -1]
      [(> n 0) +1]
      [else 0])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>cond</code> expression usually takes the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(cond (<em>test</em> <em>expr</em>) ... (else <em>expr</em>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>though the <code>else</code> clause may be omitted. This should be done only when there is no possibility that all the tests will fail, as in the new version of <code>sign</code> below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define sign
  (lambda (n)
    (cond
      [(< n 0) -1]
      [(> n 0) +1]
      [(= n 0) 0])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>These definitions of <code>sign</code> do not depend on the order in which the tests are performed, since only one of the tests can be true for any value of <code>n</code>. The following procedure computes the tax on a given amount of income in a progressive tax system with breakpoints at 10,000, 20,000, and 30,000 dollars.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define income-tax
  (lambda (income)
    (cond
      [(<= income 10000) (* income .05)]
      [(<= income 20000) (+ (* (- income 10000) .08) 500.00)]
      [(<= income 30000) (+ (* (- income 20000) .13) 1300.00)]
      [else (+ (* (- income 30000) .21) 2600.00)])))

(income-tax 5000) ⇒ 250.0
(income-tax 15000) ⇒ 900.0
(income-tax 25000) ⇒ 1950.0
(income-tax 50000) ⇒ 6800.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this example, the order in which the tests are performed, left to right (top to bottom), is significant.</p>
</div>
<div class="sect3">
<h4 id="exercise_2.7.1">Exercise 2.7.1</h4>
<div class="paragraph">
<p>Define the predicate <code>atom?</code>, which returns true if its argument is not a pair and false if it is.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.7.2">Exercise 2.7.2</h4>
<div id="start:s128" class="paragraph">
<p>The procedure <code>length</code> returns the length of its argument, which must be a list. For example, <code>(length '(a b c))</code> is 3. Using <code>length</code>, define the procedure <code>shorter</code>, which returns the shorter of two list arguments. Have it return the first list if they have the same length.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(shorter '(a b) '(c d e)) ⇒ (a b)
(shorter '(a b) '(c d)) ⇒ (a b)
(shorter '(a b) '(c)) ⇒ (c)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_2.8.">Section 2.8. Simple Recursion</h3>
<div class="paragraph">
<p>We have seen how we can control whether or not expressions are evaluated with <code>if</code>, <code>and</code>, <code>or</code>, and <code>cond</code>. We can also perform an expression more than once by creating a procedure containing the expression and invoking the procedure more than once. What if we need to perform some expression repeatedly, say for all the elements of a list or all the numbers from one to ten? We can do so via recursion. Recursion is a simple concept: the application of a procedure from within that procedure. It can be tricky to master recursion at first, but once mastered it provides expressive power far beyond ordinary looping constructs.</p>
</div>
<div class="paragraph">
<p>A <em>recursive procedure</em> is a procedure that applies itself. Perhaps the simplest recursive procedure is the following, which we will call <code>goodbye</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define goodbye
  (lambda ()
    (goodbye)))

(goodbye) ⇒</code></pre>
</div>
</div>
<div class="paragraph">
<p>This procedure takes no arguments and simply applies itself immediately. There is no value after the ⇒ because <code>goodbye</code> never returns.</p>
</div>
<div class="paragraph">
<p>Obviously, to make practical use out of a recursive procedure, we must have some way to terminate the recursion. Most recursive procedures should have at least two basic elements, a <em>base case</em> and a <em>recursion step</em>. The base case terminates the recursion, giving the value of the procedure for some base argument. The recursion step gives the value in terms of the value of the procedure applied to a different argument. In order for the recursion to terminate, the different argument must be closer to the base argument in some way.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the problem of finding the length of a proper list recursively. We need a base case and a recursion step. The logical base argument for recursion on lists is nearly always the empty list. The length of the empty list is zero, so the base case should give the value zero for the empty list. In order to become closer to the empty list, the natural recursion step involves the cdr of the argument. A nonempty list is one element longer than its cdr, so the recursion step gives the value as one more than the length of the cdr of the list.<a id="defn:simplelength"></a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define length
  (lambda (ls)
    (if (null? ls)
        0
        (+ (length (cdr ls)) 1))))

(length '()) ⇒ 0
(length '(a)) ⇒ 1
(length '(a b)) ⇒ 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>if</code> expression asks if the list is empty. If so, the value is zero. This is the base case. If not, the value is one more than the length of the cdr of the list. This is the recursion step.</p>
</div>
<div class="paragraph">
<p>Many Scheme implementations allow you to trace the execution of a procedure to see how it operates. In Chez Scheme, for example, one way to trace a procedure is to type <code>(trace <em>name</em>)</code>, where <code><em>name</em></code> is the name of a procedure you have defined at top level. If you trace <code>length</code> as defined above and pass it the argument <code>'(a b c d)</code>, you should see something like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">|(length (a b c d))
| (length (b c d))
| |(length (c d))
| | (length (d))
| | |(length ())
| | |0
| | 1
| |2
| 3
|4</code></pre>
</div>
</div>
<div class="paragraph">
<p>The indentation shows the nesting level of the recursion; the vertical lines associate applications visually with their values. Notice that on each application of <code>length</code> the list gets smaller until it finally reaches <code>()</code>. The value at <code>()</code> is 0, and each outer level adds 1 to arrive at the final value.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s write a procedure, <code>list-copy</code>, that returns a copy of its argument, which must be a list. That is, <code>list-copy</code> returns a new list consisting of the elements (but not the pairs) of the old list. Making a copy might be useful if either the original list or the copy might be altered via <code>set-car!</code> or <code>set-cdr!</code>, which we discuss later.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(list-copy '()) ⇒ ()
(list-copy '(a b c)) ⇒ (a b c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>See if you can define <code>list-copy</code> before studying the definition below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define list-copy
  (lambda (ls)
    (if (null? ls)
        '()
        (cons (car ls)
              (list-copy (cdr ls))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The definition of <code>list-copy</code> is similar to the definition of <code>length</code>. The test in the base case is the same, <code>(null? ls)</code>. The value in the base case is <code>()</code>, however, not 0, because we are building up a list, not a number. The recursive call is the same, but instead of adding one, <code>list-copy</code> conses the car of the list onto the value of the recursive call.</p>
</div>
<div class="paragraph">
<p>There is no reason why there cannot be more than one base case. The procedure <code>memv</code> takes two arguments, an object and a list. It returns the first sublist, or <em>tail</em>, of the list whose car is equal to the object, or <code>#f</code> if the object is not found in the list. The value of <code>memv</code> may be used as a list or as a truth value in a conditional expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define memv
  (lambda (x ls)
    (cond
      [(null? ls) #f]
      [(eqv? (car ls) x) ls]
      [else (memv x (cdr ls))])))

(memv 'a '(a b b d)) ⇒ (a b b d)
(memv 'b '(a b b d)) ⇒ (b b d)
(memv 'c '(a b b d)) ⇒ #f
(memv 'd '(a b b d)) ⇒ (d)
(if (memv 'b '(a b b d))
    "yes"
    "no") ⇒ "yes"</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here there are two conditions to check, hence the use of <code>cond</code>. The first cond clause checks for the base value of <code>()</code>; no object is a member of <code>()</code>, so the answer is <code>#f</code>. The second clause asks if the car of the list is the object, in which case the list is returned, being the first tail whose car contains the object. The recursion step just continues down the list.</p>
</div>
<div class="paragraph">
<p>There may also be more than one recursion case. Like <code>memv</code>, the procedure <code>remv</code> defined below takes two arguments, an object and a list. It returns a new list with all occurrences of the object removed from the list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define remv
  (lambda (x ls)
    (cond
      [(null? ls) '()]
      [(eqv? (car ls) x) (remv x (cdr ls))]
      [else (cons (car ls) (remv x (cdr ls)))])))

(remv 'a '(a b b d)) ⇒ (b b d)
(remv 'b '(a b b d)) ⇒ (a d)
(remv 'c '(a b b d)) ⇒ (a b b d)
(remv 'd '(a b b d)) ⇒ (a b b)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This definition is similar to the definition of <code>memv</code> above, except <code>remv</code> does not quit once it finds the element in the car of the list. Rather, it continues, simply ignoring the element. If the element is not found in the car of the list, <code>remv</code> does the same thing as <code>list-copy</code> above: it conses the car of the list onto the recursive value.</p>
</div>
<div class="paragraph">
<p>Up to now, the recursion has been only on the cdr of a list. It is sometimes useful, however, for a procedure to recur on the car as well as the cdr of the list. The procedure <code>tree-copy</code> defined below treats the structure of pairs as a tree rather than as a list, with the left subtree being the car of the pair and the right subtree being the cdr of the pair. It performs a similar operation to <code>list-copy</code>, building new pairs while leaving the elements (leaves) alone.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define tree-copy
  (lambda (tr)
    (if (not (pair? tr))
        tr
        (cons (tree-copy (car tr))
              (tree-copy (cdr tr))))))

(tree-copy '((a . b) . c)) ⇒ ((a . b) . c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The natural base argument for a tree structure is anything that is not a pair, since the recursion traverses pairs rather than lists. The recursive step in this case is <em>doubly recursive</em>, finding the value recursively for the car as well as the cdr of the argument.</p>
</div>
<div class="paragraph">
<p>At this point, readers who are familiar with other languages that provide special iteration constructs, e.g., <em>while</em> or <em>for</em> loops, might wonder whether similar constructs are required in Scheme. Such constructs are unnecessary; iteration in Scheme is expressed more clearly and succinctly via recursion. Recursion is more general and eliminates the need for the variable assignments required by many other languages' iteration constructs, resulting in code that is more reliable and easier to follow. Some recursion is essentially iteration and executes as such; <a href="#section_3.2.">Section 3.2</a> has more to say about this. Often, there is no need to make a distinction, however. Concentrate instead on writing clear, concise, and correct programs.</p>
</div>
<div class="paragraph">
<p>Before we leave the topic of recursion, let&#8217;s consider a special form of repetition called <em>mapping</em>. Consider the following procedure, <code>abs-all</code>, that takes a list of numbers as input and returns a list of their absolute values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define abs-all
  (lambda (ls)
    (if (null? ls)
        '()
        (cons (abs (car ls))
              (abs-all (cdr ls))))))

(abs-all '(1 -2 3 -4 5 -6)) ⇒ (1 2 3 4 5 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This procedure forms a new list from the input list by applying the procedure <code>abs</code> to each element. We say that <code>abs-all</code> <em>maps</em> <code>abs</code> over the input list to produce the output list. Mapping a procedure over a list is a fairly common thing to do, so Scheme provides the procedure <code>map</code>, which maps its first argument, a procedure, over its second, a list. We can use <code>map</code> to define <code>abs-all</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define abs-all
  (lambda (ls)
    (map abs ls)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We really do not need <code>abs-all</code>, however, since the corresponding direct application of <code>map</code> is just as short and perhaps clearer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(map abs '(1 -2 3 -4 5 -6)) ⇒ (1 2 3 4 5 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course, we can use <code>lambda</code> to create the procedure argument to <code>map</code>, e.g., to square the elements of a list of numbers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(map (lambda (x) (* x x))
     '(1 -3 -5 7)) ⇒ (1 9 25 49)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can map a multiple-argument procedure over multiple lists, as in the following example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(map cons '(a b c) '(1 2 3)) ⇒ ((a . 1) (b . 2) (c . 3))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The lists must be of the same length, and the procedure should accept as many arguments as there are lists. Each element of the output list is the result of applying the procedure to corresponding members of the input list.</p>
</div>
<div class="paragraph">
<p>Looking at the first definition of <code>abs-all</code> above, you should be able to derive, before studying it, the following definition of <code>map1</code>, a restricted version of <code>map</code> that maps a one-argument procedure over a single list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define map1
  (lambda (p ls)
    (if (null? ls)
        '()
        (cons (p (car ls))
              (map1 p (cdr ls))))))

(map1 abs '(1 -2 3 -4 5 -6)) ⇒ (1 2 3 4 5 6)</code></pre>
</div>
</div>
<div class="paragraph">
<p>All we have done is to replace the call to <code>abs</code> in <code>abs-all</code> with a call to the new parameter <code>p</code>. A definition of the more general <code>map</code> is given in <a href="#section_5.4.">Section 5.4</a>.</p>
</div>
<div class="sect3">
<h4 id="exercise_2.8.1">Exercise 2.8.1</h4>
<div id="start:s149" class="paragraph">
<p>Describe what would happen if you switched the order of the arguments to <code>cons</code> in the definition of <code>tree-copy</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.8.2">Exercise 2.8.2</h4>
<div class="paragraph">
<p>Consult <a href="#section_6.3.">Section 6.3</a> for the description of <code>append</code> and define a two-argument version of it. What would happen if you switched the order of the arguments in the call to <code>append</code> within your definition of <code>append</code>?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.8.3">Exercise 2.8.3</h4>
<div class="paragraph">
<p>Define the procedure <code>make-list</code>, which takes a nonnegative integer <code><em>n</em></code> and an object and returns a new list, <code><em>n</em></code> long, each element of which is the object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(make-list 7 '()) ⇒ (() () () () () () ())</code></pre>
</div>
</div>
<div class="paragraph">
<p>[<em>Hint</em>: The base test should be <code>(= <em>n</em> 0)</code>, and the recursion step should involve <code>(- <em>n</em> 1)</code>. Whereas <code>()</code> is the natural base case for recursion on lists, 0 is the natural base case for recursion on nonnegative integers. Similarly, subtracting 1 is the natural way to bring a nonnegative integer closer to 0.]</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.8.4">Exercise 2.8.4</h4>
<div class="paragraph">
<p>The procedures <code>list-ref</code> and <code>list-tail</code> return the <em>n</em>th element and <em>n</em>th tail of a list <em>ls</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(list-ref '(1 2 3 4) 0) ⇒ 1
(list-tail '(1 2 3 4) 0) ⇒ (1 2 3 4)
(list-ref '(a short (nested) list) 2) ⇒ (nested)
(list-tail '(a short (nested) list) 2) ⇒ ((nested) list)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Define both procedures.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.8.5">Exercise 2.8.5</h4>
<div id="start:s155" class="paragraph">
<p><a href="#exercise_2.7.2">Exercise 2.7.2</a> had you use <code>length</code> in the definition of <code>shorter</code>, which returns the shorter of its two list arguments, or the first if the two have the same length. Write <code>shorter</code> without using <code>length</code>. [<em>Hint</em>: Define a recursive helper, <code>shorter?</code>, and use it in place of the length comparison.]</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.8.6">Exercise 2.8.6</h4>
<div class="paragraph">
<p>All of the recursive procedures shown so far have been directly recursive. That is, each procedure directly applies itself to a new argument. It is also possible to write two procedures that use each other, resulting in indirect recursion. Define the procedures <code>odd?</code> and <code>even?</code>, each in terms of the other. [<em>Hint</em>: What should each return when its argument is 0?]</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(even? 17) ⇒ #f
(odd? 17) ⇒ #t</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.8.7">Exercise 2.8.7</h4>
<div class="paragraph">
<p>Use <code>map</code> to define a procedure, <code>transpose</code>, that takes a list of pairs and returns a pair of lists as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(transpose '((a . 1) (b . 2) (c . 3))) ⇒ ((a b c) 1 2 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>[<em>Hint</em>: <code>((a b c) 1 2 3)</code> is the same as <code>((a b c) . (1 2 3))</code>.]</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_2.9.">Section 2.9. Assignment</h3>
<div class="paragraph">
<p>Although many programs can be written without them, assignments to top-level variables or <code>let</code>-bound and <code>lambda</code>-bound variables are sometimes useful. Assignments do not create new bindings, as with <code>let</code> or <code>lambda</code>, but rather change the values of existing bindings. Assignments are performed with <code>set!</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define abcde '(a b c d e))
abcde ⇒ (a b c d e)
(set! abcde (cdr abcde))
abcde ⇒ (b c d e)
(let ([abcde '(a b c d e)])
  (set! abcde (reverse abcde))
  abcde) ⇒ (e d c b a)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Many languages require the use of assignments to initialize local variables, separate from the declaration or binding of the variables. In Scheme, all local variables are given a value immediately upon binding. Besides making the separate assignment to initialize local variables unnecessary, it ensures that the programmer cannot forget to initialize them, a common source of errors in most languages.</p>
</div>
<div class="paragraph">
<p>In fact, most of the assignments that are either necessary or convenient in other languages are both unnecessary and inconvenient in Scheme, since there is typically a clearer way to express the same algorithm without assignments. One common practice in some languages is to sequence expression evaluation with a series of assignments, as in the following procedure that finds the roots of a quadratic equation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define quadratic-formula
  (lambda (a b c)
    (let ([root1 0] [root2 0] [minusb 0] [radical 0] [divisor 0])
      (set! minusb (- 0 b))
      (set! radical (sqrt (- (* b b) (* 4 (* a c)))))
      (set! divisor (* 2 a))
      (set! root1 (/ (+ minusb radical) divisor))
      (set! root2 (/ (- minusb radical) divisor))
      (cons root1 root2))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The roots are computed according to the well-known quadratic formula,</p>
</div>
<div class="stemblock">
<div class="content">
\[\frac{-b \pm \sqrt{b^2 - 4ac}}{2a}\]
</div>
</div>
<div class="paragraph">
<p>which yields the solutions to the equation \(0 = ax^2 + bx + c\). The <code>let</code> expression in this definition is employed solely to establish the variable bindings, corresponding to the declarations required in other languages. The first three assignment expressions compute subpieces of the formula, namely \(-b\), \(\sqrt{b^2 - 4ac}\), and \(2a\). The last two assignment expressions compute the two roots in terms of the subpieces. A pair of the two roots is the value of <code>quadratic-formula</code>. For example, the two roots of \(2x^2 - 4x - 6\) are \(x = 3\) and \(x = -1\).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(quadratic-formula 2 -4 -6) ⇒ (3 . -1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The definition above works, but it can be written more clearly without the assignments, as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define quadratic-formula
  (lambda (a b c)
    (let ([minusb (- 0 b)]
          [radical (sqrt (- (* b b) (* 4 (* a c))))]
          [divisor (* 2 a)])
      (let ([root1 (/ (+ minusb radical) divisor)]
            [root2 (/ (- minusb radical) divisor)])
        (cons root1 root2)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this version, the <code>set!</code> expressions are gone, and we are left with essentially the same algorithm. By employing two <code>let</code> expressions, however, the definition makes clear the dependency of <code>root1</code> and <code>root2</code> on the values of <code>minusb</code>, <code>radical</code>, and <code>divisor</code>. Equally important, the <code>let</code> expressions make clear the <em>lack</em> of dependencies among <code>minusb</code>, <code>radical</code>, and <code>divisor</code> and between <code>root1</code> and <code>root2</code>.</p>
</div>
<div class="paragraph">
<p>Assignments do have some uses in Scheme, otherwise the language would not support them. Consider the following version of <code>cons</code> that counts the number of times it is called, storing the count in a variable named <code>cons-count</code>. It uses <code>set!</code> to increment the count; there is no way to achieve the same behavior without assignments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define kons-count 0)
(define kons
  (lambda (x y)
    (set! kons-count (+ kons-count 1))
    (cons x y)))

(kons 'a '(b c)) ⇒ (a b c)
kons-count ⇒ 1
(kons 'a (kons 'b (kons 'c '()))) ⇒ (a b c)
kons-count ⇒ 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assignments are commonly used to implement procedures that must maintain some internal state. For example, suppose we would like to define a procedure that returns 0 the first time it is called, 1 the second time, 2 the third time, and so on indefinitely. We could write something similar to the definition of <code>cons-count</code> above:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define next 0)
(define count
  (lambda ()
    (let ([v next])
      (set! next (+ next 1))
      v)))

(count) ⇒ 0
(count) ⇒ 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>This solution is somewhat undesirable in that the variable <code>next</code> is visible at top level even though it need not be. Since it is visible at top level, any code in the system can change its value, perhaps inadvertently affecting the behavior of <code>count</code> in a subtle way. We can solve this problem by <code>let</code>-binding <code>next</code> outside of the <code>lambda</code> expression:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define count
  (let ([next 0])
    (lambda ()
      (let ([v next])
        (set! next (+ next 1))
        v))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The latter solution also generalizes easily to provide multiple counters, each with its own local counter. The procedure <code>make-counter</code>, defined below, returns a new counting procedure each time it is called.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define make-counter
  (lambda ()
    (let ([next 0])
      (lambda ()
        (let ([v next])
          (set! next (+ next 1))
          v)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since <code>next</code> is bound inside of <code>make-counter</code> but outside of the procedure returned by <code>make-counter</code>, each procedure it returns maintains its own unique counter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define count1 (make-counter))
(define count2 (make-counter))

(count1) ⇒ 0
(count2) ⇒ 0
(count1) ⇒ 1
(count1) ⇒ 2
(count2) ⇒ 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>If a state variable must be shared by more than one procedure defined at top level, but we do not want the state variable to be visible at top level, we can use <code>let</code> to bind the variable and <code>set!</code> to make the procedures visible at top level.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define shhh #f)
(define tell #f)
(let ([secret 0])
  (set! shhh
    (lambda (message)
      (set! secret message)))
  (set! tell
    (lambda ()
      secret)))

(shhh "sally likes harry")
(tell) ⇒ "sally likes harry"
secret ⇒ <em>exception: variable secret is not bound</em></code></pre>
</div>
</div>
<div class="paragraph">
<p>Variables must be defined before they can be assigned, so we define <code>shhh</code> and <code>tell</code> to be <code>#f</code> initially. (Any initial value would do.) We&#8217;ll see this structure again in <a href="#section_3.5.">Section 3.5</a> and a better way to structure code like this as a library in <a href="#section_3.6.">Section 3.6</a>.</p>
</div>
<div class="paragraph">
<p>Local state is sometimes useful for caching computed values or allowing a computation to be evaluated <em>lazily</em>, i.e., only once and only on demand. The procedure <code>lazy</code> below accepts a <em>thunk</em>, or zero-argument procedure, as an argument. Thunks are often used to "freeze" computations that must be delayed for some reason, which is exactly what we need to do in this situation. When passed a thunk <code><em>t</em></code>, <code>lazy</code> returns a new thunk that, when invoked, returns the value of invoking <code><em>t</em></code>. Once computed, the value is saved in a local variable so that the computation need not be performed again. A boolean flag is used to record whether <code><em>t</em></code> has been invoked and its value saved.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define lazy
  (lambda (t)
    (let ([val #f] [flag #f])
      (lambda ()
        (if (not flag)
            (begin (set! val (t))
                   (set! flag #t)))
        val))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The syntactic form <code>begin</code>, used here for the first time, evaluates its subexpressions in sequence from left to right and returns the value of the last subexpression, like the body of a <code>let</code> or <code>lambda</code> expression. We also see that the <code><em>alternative</em></code> subexpression of an <code>if</code> expression can be omitted. This should be done only when the value of the <code>if</code> is discarded, as it is in this case.</p>
</div>
<div class="paragraph">
<p>Lazy evaluation is especially useful for values that require considerable time to compute. By delaying the evaluation, we might avoid computing the value altogether, and by saving the value, we avoid computing it more than once.</p>
</div>
<div class="paragraph">
<p>The operation of <code>lazy</code> can best be illustrated by printing a message from within a thunk passed to <code>lazy</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define p
  (lazy (lambda ()
          (display "Ouch!")
          (newline)
          "got me")))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first time <code>p</code> is invoked, the message <code>Ouch!</code> is printed and the string <code>"got me"</code> is returned. Thereafter, <code>"got me"</code> is returned but the message is not printed. The procedures <code>display</code> and <code>newline</code> are the first examples of explicit input/output we have seen; <code>display</code> prints the string without quotation marks, and <code>newline</code> prints a newline character.</p>
</div>
<div class="paragraph">
<p>To further illustrate the use of <code>set!</code>, let&#8217;s consider the implementation of stack objects whose internal workings are not visible on the outside. A stack object accepts one of four <em>messages</em>: <code>empty?</code>, which returns <code>#t</code> if the stack is empty; <code>push!</code>, which adds an object to the top of the stack; <code>top</code>, which returns the object on the top of the stack; and <code>pop!</code>, which removes the object on top of the stack. The procedure <code>make-stack</code> given below creates a new stack each time it is called in a manner similar to <code>make-counter</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define make-stack
  (lambda ()
    (let ([ls '()])
      (lambda (msg . args)
        (cond
          [(eqv? msg 'empty?) (null? ls)]
          [(eqv? msg 'push!) (set! ls (cons (car args) ls))]
          [(eqv? msg 'top) (car ls)]
          [(eqv? msg 'pop!) (set! ls (cdr ls))]
          [else "oops"])))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each stack is stored as a list bound to the variable <code>ls</code>; <code>set!</code> is used to change this binding for <code>push!</code> and <code>pop!</code>. Notice that the argument list of the inner <code>lambda</code> expression uses the improper list syntax to bind <code>args</code> to a list of all arguments but the first. This is useful here because in the case of <code>empty?</code>, <code>top</code>, and <code>pop!</code> there is only one argument (the message), but in the case of <code>push!</code> there are two (the message and the object to push onto the stack).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define stack1 (make-stack))
(define stack2 (make-stack))
(list (stack1 'empty?) (stack2 'empty?)) ⇒ (#t #t)

(stack1 'push! 'a)
(list (stack1 'empty?) (stack2 'empty?)) ⇒ (#f #t)

(stack1 'push! 'b)
(stack2 'push! 'c)
(stack1 'top) ⇒ b
(stack2 'top) ⇒ c

(stack1 'pop!)
(stack1 'top) ⇒ a
(list (stack1 'empty?) (stack2 'empty?)) ⇒ (#f #f)

(stack1 'pop!)
(list (stack1 'empty?) (stack2 'empty?)) ⇒ (#t #f)</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with the counters created by <code>make-counter</code>, the state maintained by each stack object is directly accessible only within the object. Each reference or change to this state is made explicitly by the object itself. One important benefit is that we can change the internal structure of the stack, perhaps to use a vector (see <a href="#section_6.9.">Section 6.9</a>) instead of a list to hold the elements, without changing its external behavior. Because the behavior of the object is known abstractly (not operationally), it is known as an <em>abstract object</em>. See <a href="#section_12.8.">Section 12.8</a> for more about creating abstract objects.</p>
</div>
<div class="paragraph">
<p>In addition to changing the values of variables, we can also change the values of the car and cdr fields of a pair, using the procedures <code>set-car!</code> and <code>set-cdr!</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define p (list 1 2 3))
(set-car! (cdr p) 'two)
p ⇒ (1 two 3)
(set-cdr! p '())
p ⇒ (1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can use these operators to define a queue data type, which is like a stack except that new elements are added at one end and extracted from the other. The following queue implementation uses a <em>tconc</em> structure. A tconc consists of a nonempty list and a header. The header is a pair whose car points to the first pair (head) of the list and whose cdr points to the last pair (end) of the list.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/6.gif" alt="6">
</div>
</div>
<div class="paragraph">
<p>The last element of the list is a placeholder and not considered part of the queue.</p>
</div>
<div class="paragraph">
<p>Four operations on queues are defined below: <code>make-queue</code>, which constructs a queue; <code>putq!</code>, which adds an element to the end of a queue; <code>getq</code>, which retrieves the element at the front of a queue; and <code>delq!</code>, which removes the element at the front of a queue.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define make-queue
  (lambda ()
    (let ([end (cons 'ignored '())])
      (cons end end))))

(define putq!
  (lambda (q v)
    (let ([end (cons 'ignored '())])
      (set-car! (cdr q) v)
      (set-cdr! (cdr q) end)
      (set-cdr! q end))))

(define getq
  (lambda (q)
    (car (car q))))

(define delq!
  (lambda (q)
    (set-car! q (cdr (car q)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>All are simple operations except for <code>putq!</code>, which modifies the end pair to contain the new value and adds a new end pair.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define myq (make-queue))

(putq! myq 'a)
(putq! myq 'b)
(getq myq) ⇒ a
(delq! myq)
(getq myq) ⇒ b
(delq! myq)
(putq! myq 'c)
(putq! myq 'd)
(getq myq) ⇒ c
(delq! myq)
(getq myq) ⇒ d</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.9.1">Exercise 2.9.1</h4>
<div id="start:s186" class="paragraph">
<p>Modify <code>make-counter</code> to take two arguments: an initial value for the counter to use in place of 0 and an amount to increment the counter by each time.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.9.2">Exercise 2.9.2</h4>
<div id="start:s188" class="paragraph">
<p>Look up the description of <code>case</code> in <a href="#section_5.3.">Section 5.3</a>. Replace the <code>cond</code> expression in <code>make-stack</code> with an equivalent <code>case</code> expression. Add <code>mt?</code> as a second name for the <code>empty?</code> message.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.9.3">Exercise 2.9.3</h4>
<div class="paragraph">
<p>Modify the <code>stack</code> object to allow the two messages <code>ref</code> and <code>set!</code>. <code>(<em>stack</em> 'ref <em>i</em>)</code> should return the <code><em>i</em></code>th element from the top of the stack; <code>(<em>stack</em> 'ref 0)</code> should be equivalent to <code>(<em>stack</em> 'top)</code>. <code>(<em>stack</em> 'set! <em>i</em> <em>v</em>)</code> should change the <code><em>i</em></code>th element from the top of the stack to <code><em>v</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define stack (make-stack))

(stack 'push! 'a)
(stack 'push! 'b)
(stack 'push! 'c)

(stack 'ref 0) ⇒ c
(stack 'ref 2) ⇒ a
(stack 'set! 1 'd)
(stack 'ref 1) ⇒ d
(stack 'top) ⇒ c
(stack 'pop!)
(stack 'top) ⇒ d</code></pre>
</div>
</div>
<div class="paragraph">
<p>[<em>Hint</em>: Use <code>list-ref</code> to implement <code>ref</code> and <code>list-tail</code> with <code>set-car!</code> to implement <code>set!</code>.]</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.9.4">Exercise 2.9.4</h4>
<div class="paragraph">
<p>Scheme supports <em>vectors</em> as well as lists. Like lists, vectors are aggregate objects that contain other objects. Unlike lists, vectors have a fixed size and are laid out in one flat block of memory, typically with a header containing the length of the vector, as in the ten-element vector below.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/7.gif" alt="7">
</div>
</div>
<div class="paragraph">
<p>This makes vectors more suitable for applications needing fast access to any element of the aggregate but less suitable for applications needing data structures that grow and shrink as needed.</p>
</div>
<div class="paragraph">
<p>Look up the basic vector operations in <a href="#section_6.9.">Section 6.9</a> and reimplement the <code>stack</code> object to use a vector instead of a list to hold the stack contents. Include the <code>ref</code> and <code>set!</code> messages of <a href="#exercise_2.9.3">Exercise 2.9.3</a>. Have the new <code>make-stack</code> accept a size argument <em>n</em> and make the vector length <em>n</em>, but do not otherwise change the external (abstract) interface.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.9.5">Exercise 2.9.5</h4>
<div id="start:s194" class="paragraph">
<p>Define a predicate, <code>emptyq?</code>, for determining if a queue is empty. Modify <code>getq</code> and <code>delq!</code> to raise an exception when an empty queue is found, using <code>assertion-violation</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.9.6">Exercise 2.9.6</h4>
<div id="start:s195" class="paragraph">
<p>In the queue implementation, the last pair in the encapsulated list is a placeholder, i.e., it never holds anything useful. Recode the queue operators to avoid this wasted pair. Make sure that the series of queue operations given earlier works with the new implementation. Which implementation do you prefer?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.9.7">Exercise 2.9.7</h4>
<div class="paragraph">
<p>Using <code>set-cdr!</code>, it is possible to create <em>cyclic lists</em>. For example, the following expression evaluates to a list whose car is the symbol <code>a</code> and whose cdr is the list itself.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([ls (cons 'a '())])
  (set-cdr! ls ls)
  ls)</code></pre>
</div>
</div>
<div class="paragraph">
<p>What happens when you enter the above expression during an interactive Scheme session? What will the implementation of <code>length</code> on <a href="#defn:simplelength">page 42</a> do when given a cyclic list? What does the built-in <code>length</code> primitive do?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_2.9.8">Exercise 2.9.8</h4>
<div class="paragraph">
<p>Define the predicate <code>list?</code>, which returns <code>#t</code> if its argument is a proper list and <code>#f</code> otherwise (see <a href="#section_6.3.">Section 6.3</a>). It should return <code>#f</code> for cyclic lists as well as for lists terminated by objects other than <code>()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(list? '()) ⇒ #t
(list? '(1 2 3)) ⇒ #t
(list? '(a . b)) ⇒ #f
(list? (let ([ls (cons 'a '())])
         (set-cdr! ls ls)
         ls)) ⇒ #f</code></pre>
</div>
</div>
<div class="paragraph">
<p>First write a simplified version of <code>list?</code> that does not handle cyclic lists, then extend this to handle cyclic lists correctly. Revise your definition until you are satisfied that it is as clear and concise as possible. [<em>Hint</em>: Use the following "hare and tortoise" algorithm to detect cycles. Define a recursive help procedure of two arguments, the hare and the tortoise. Start both the hare and the tortoise at the beginning of the list. Have the hare advance by two cdrs each time the tortoise advances by one cdr. If the hare catches the tortoise, there must be a cycle.]</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chp_going_further">Chapter 3. Going Further</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/ch3.png" alt="ch3">
</div>
</div>
<div class="paragraph">
<p>The preceding chapter prepared you to write Scheme programs using a small set of the most useful primitive syntactic forms and procedures. This chapter introduces a number of additional features and programming techniques that will allow you to write more sophisticated and efficient programs.</p>
</div>
<div class="sect2">
<h3 id="section_3.1.">Section 3.1. Syntactic Extension</h3>
<div class="paragraph">
<p>As we saw in <a href="#section_2.5.">Section 2.5</a>, the <code>let</code> syntactic form is merely a <em>syntactic extension</em> defined in terms of a <code>lambda</code> expression and a procedure application, both core syntactic forms. At this point, you might be wondering which syntactic forms are core forms and which are syntactic extensions, and how new syntactic extensions may be defined. This section provides some answers to these questions.</p>
</div>
<div class="paragraph">
<p>In truth, it is not necessary for us to draw a distinction between core forms and syntactic extensions, since once defined, a syntactic extension has exactly the same status as a core form. Drawing a distinction, however, makes understanding the language easier, since it allows us to focus attention on the core forms and to understand all others in terms of them.</p>
</div>
<div class="paragraph">
<p>It <em>is</em> necessary for a Scheme implementation to distinguish between core forms and syntactic extensions. A Scheme implementation expands syntactic extensions into core forms as the first step of compilation or interpretation, allowing the rest of the compiler or interpreter to focus only on the core forms. The set of core forms remaining after expansion to be handled directly by the compiler or interpreter is implementation-dependent, however, and may be different from the set of forms described as core here.</p>
</div>
<div class="paragraph">
<p>The exact set of syntactic forms making up the core of the language is thus subject to debate, although it must be possible to derive all other forms from any set of forms declared to be core forms. The set described here is among the simplest for which this constraint is satisfied.</p>
</div>
<div class="paragraph">
<p>The core syntactic forms include top-level <code>define</code> forms, constants, variables, procedure applications, <code>quote</code> expressions, <code>lambda</code> expressions, <code>if</code> expressions, and <code>set!</code> expressions. The grammar below describes the core syntax of Scheme in terms of these definitions and expressions. In the grammar, vertical bars ( | ) separate alternatives, and a form followed by an asterisk ( * ) represents zero or more occurrences of the form. &lt;variable&gt; is any Scheme identifier. &lt;datum&gt; is any Scheme object, such as a number, list, symbol, or vector. &lt;boolean&gt; is either <code>#t</code> or <code>#f</code>, &lt;number&gt; is any number, &lt;character&gt; is any character, and &lt;string&gt; is any string. We have already seen examples of numbers, strings, lists, symbols, and booleans. See <a href="#chp_operations_on_objects">Chapter 6</a> or the formal syntax description starting on <a href="#formal_syntax">page 455</a> for more on the object-level syntax of these and other objects.</p>
</div>
<table class="tableblock frame-none grid-none fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;program&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;form&gt;*</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;form&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;definition&gt; | &lt;expression&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;definition&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;variable definition&gt; | <code>(begin</code> &lt;definition&gt;* <code>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;variable definition&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(define</code> &lt;variable&gt; &lt;expression&gt; <code>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;expression&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;constant&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;variable&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(quote</code> &lt;datum&gt; <code>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(lambda</code> &lt;formals&gt; &lt;expression&gt; &lt;expression&gt;* <code>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(if</code> &lt;expression&gt; &lt;expression&gt; &lt;expression&gt; <code>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(set!</code> &lt;variable&gt; &lt;expression&gt; <code>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;application&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;constant&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;boolean&gt; | &lt;number&gt; | &lt;character&gt; | &lt;string&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;formals&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;variable&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(</code>&lt;variable&gt;* <code>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(</code>&lt;variable&gt; &lt;variable&gt;* <code>.</code> &lt;variable&gt; <code>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;application&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(</code>&lt;expression&gt; &lt;expression&gt;* <code>)</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The grammar is ambiguous in that the syntax for procedure applications conflicts with the syntaxes for <code>quote</code>, <code>lambda</code>, <code>if</code>, and <code>set!</code> expressions. In order to qualify as a procedure application, the first &lt;expression&gt; must not be one of these keywords, unless the keyword has been redefined or locally bound.</p>
</div>
<div class="paragraph">
<p>The "defun" syntax for <code>define</code> given in <a href="#section_2.6.">Section 2.6</a> is not included in the core, since definitions in that form are straightforwardly translated into the simpler <code>define</code> syntax. Similarly, the core syntax for <code>if</code> does not permit the <code><em>alternative</em></code> to be omitted, as did one example in <a href="#section_2.9.">Section 2.9</a>. An <code>if</code> expression lacking an <code><em>alternative</em></code> can be translated into the core syntax for <code>if</code> merely by replacing the missing subexpression with an arbitrary constant, such as <code>#f</code>.</p>
</div>
<div class="paragraph">
<p>A <code>begin</code> that contains only definitions is considered to be a definition in the grammar; this is permitted in order to allow syntactic extensions to expand into more than one definition. <code>begin</code> expressions, i.e., <code>begin</code> forms containing expressions, are not considered core forms. A <code>begin</code> expression of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(begin <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to the <code>lambda</code> application</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">((lambda () <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and hence need not be considered core.</p>
</div>
<div class="paragraph">
<p>Now that we have established a set of core syntactic forms, let&#8217;s turn to a discussion of syntactic extensions. Syntactic extensions are so called because they extend the syntax of Scheme beyond the core syntax. All syntactic extensions in a Scheme program must ultimately be derived from the core forms. One syntactic extension, however, may be defined in terms of another syntactic extension, as long as the latter is in some sense "closer" to the core syntax. Syntactic forms may appear anywhere an expression or definition is expected, as long as the extended form expands into a definition or expression as appropriate.</p>
</div>
<div class="paragraph">
<p>Syntactic extensions are defined with <code>define-syntax</code>. <code>define-syntax</code> is similar to <code>define</code>, except that <code>define-syntax</code> associates a syntactic transformation procedure, or <em>transformer</em>, with a keyword (such as <code>let</code>), rather than associating a value with a variable. Here is how we might define <code>let</code> with <code>define-syntax</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax let
  (syntax-rules ()
    [(_ ((x e) ...) b1 b2 ...)
     ((lambda (x ...) b1 b2 ...) e ...)]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The identifier appearing after <code>define-syntax</code> is the name, or keyword, of the syntactic extension being defined, in this case <code>let</code>. The <code>syntax-rules</code> form is an expression that evaluates to a transformer. The item following <code>syntax-rules</code> is a list of <em>auxiliary keywords</em> and is nearly always <code>()</code>. An example of an auxiliary keyword is the <code>else</code> of <code>cond</code>. (Other examples requiring the use of auxiliary keywords are given in  <a href="#chp_syntactic_extension">Chapter 8</a>.) Following the list of auxiliary keywords is a sequence of one or more <em>rules</em>, or <em>pattern/template</em> pairs. Only one rule appears in our definition of <code>let</code>. The pattern part of a rule specifies the form that the input must take, and the template specifies to what the input should be transformed.</p>
</div>
<div class="paragraph">
<p>The pattern should always be a structured expression whose first element is an underscore ( <code>_</code> ). (As we will see in  <a href="#chp_syntactic_extension">Chapter 8</a>, the use of <code>_</code> is only a convention, but it is a good one to follow.) If more than one rule is present, the appropriate one is chosen by matching the patterns, in order, against the input during expansion. It is a syntax violation if none of the patterns match the input.</p>
</div>
<div class="paragraph">
<p>Identifiers other than an underscore or ellipsis appearing within a pattern are <em>pattern variables</em>, unless they are listed as auxiliary keywords. Pattern variables match any substructure and are bound to that substructure within the corresponding template. The notation <code><em>pat</em> ...</code> in the pattern allows for zero or more expressions matching the ellipsis prototype <code><em>pat</em></code> in the input. Similarly, the notation <code><em>expr</em> ...</code> in the template produces zero or more expressions from the ellipsis prototype <code><em>expr</em></code> in the output. The number of <code><em>pat</em></code>s in the input determines the number of <code><em>expr</em></code>s in the output; in order for this to work, any ellipsis prototype in the template must contain at least one pattern variable from an ellipsis prototype in the pattern.</p>
</div>
<div class="paragraph">
<p>The single rule in our definition of <code>let</code> should be fairly self-explanatory, but a few points are worth mentioning. First, the syntax of <code>let</code> requires that the body contain at least one form; hence, we have specified <code>b1 b2 ...</code> instead of <code>b ...</code>, which might seem more natural. On the other hand, <code>let</code> does not require that there be at least one variable/value pair, so we were able to use, simply, <code>(x e) ...</code>. Second, the pattern variables <code>x</code> and <code>e</code>, though together within the same prototype in the pattern, are separated in the template; any sort of rearrangement or recombination is possible. Finally, the three pattern variables <code>x</code>, <code>e</code>, and <code>b2</code> that appear in ellipsis prototypes in the pattern also appear in ellipsis prototypes in the template. This is not a coincidence; it is a requirement. In general, if a pattern variable appears within an ellipsis prototype in the pattern, it cannot appear outside an ellipsis prototype in the template.</p>
</div>
<div class="paragraph">
<p>The definition of <code>and</code> below is somewhat more complex than the one for <code>let</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax and
  (syntax-rules ()
    [(_) #t]
    [(_ e) e]
    [(_ e1 e2 e3 ...)
     (if e1 (and e2 e3 ...) #f)]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This definition is recursive and involves more than one rule. Recall that <code>(and)</code> evaluates to <code>#t</code>; the first rule takes care of this case. The second and third rules specify the base case and recursion steps of the recursion and together translate <code>and</code> expressions with two or more subexpressions into nested <code>if</code> expressions. For example, <code>(and a b c)</code> expands first into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(if a (and b c) #f)</code></pre>
</div>
</div>
<div class="paragraph">
<p>then</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(if a (if b (and c) #f) #f)</code></pre>
</div>
</div>
<div class="paragraph">
<p>and finally</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(if a (if b c #f) #f)</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this expansion, if <code>a</code> and <code>b</code> evaluate to a true value, then the value is the value of <code>c</code>, otherwise <code>#f</code>, as desired.</p>
</div>
<div class="paragraph">
<p>The version of <code>and</code> below is simpler but, unfortunately, incorrect.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax and ; incorrect!
  (syntax-rules ()
    [(_) #t]
    [(_ e1 e2 ...)
     (if e1 (and e2 ...) #f)]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(and (not (= x 0)) (/ 1 x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>should return the value of <code>(/ 1 x)</code> when <code>x</code> is not zero. With the incorrect version of <code>and</code>, the expression expands as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(if (not (= x 0)) (and (/ 1 x)) #f) →
  (if (not (= x 0)) (if (/ 1 x) (and) #f) #f) →
  (if (not (= x 0)) (if (/ 1 x) #t #f) #f)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The final answer if <code>x</code> is not zero is <code>#t</code>, not the value of <code>(/ 1 x)</code>.</p>
</div>
<div class="paragraph">
<p>The definition of <code>or</code> below is similar to the one for <code>and</code> except that a temporary variable must be introduced for each intermediate value so that we can both test the value and return it if it is a true value. (A temporary variable is not needed for <code>and</code> since there is only one false value, <code>#f</code>.)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax or
  (syntax-rules ()
    [(_) #f]
    [(_ e) e]
    [(_ e1 e2 e3 ...)
     (let ([t e1])
       (if t t (or e2 e3 ...)))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like variables bound by <code>lambda</code> or <code>let</code>, identifiers introduced by a template are lexically scoped, i.e., visible only within expressions introduced by the template. Thus, even if one of the expressions <code>e2 e3 ...</code> contains a reference to <code>t</code>, the introduced binding for <code>t</code> does not "capture" those references. This is typically accomplished via automatic renaming of introduced identifiers.</p>
</div>
<div class="paragraph">
<p>As with the simpler version of <code>and</code> given above, the simpler version of <code>or</code> below is incorrect.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax or ; incorrect!
  (syntax-rules ()
    [(_) #f]
    [(_ e1 e2 ...)
     (let ([t e1])
       (if t t (or e2 ...)))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reason is more subtle, however, and is the subject of <a href="#exercise_3.2.6">Exercise 3.2.6</a>.</p>
</div>
<div class="sect3">
<h4 id="exercise_3.1.1">Exercise 3.1.1</h4>
<div id="further:s25" class="paragraph">
<p>Write out the expansion steps necessary to expand</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x (memv 'a ls)])
  (and x (memv 'b x)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>into core forms.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.1.2">Exercise 3.1.2</h4>
<div class="paragraph">
<p>Write out the expansion steps necessary to expand</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(or (memv x '(a b c)) (list x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>into core forms.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.1.3">Exercise 3.1.3</h4>
<div class="paragraph">
<p><code>let*</code> is similar to <code>let</code> but evaluates its bindings in sequence. Each of the right-hand-side expressions is within the scope of the earlier bindings.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let* ([a 5] [b (+ a a)] [c (+ a b)])
  (list a b c)) ⇒ (5 10 15)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>let*</code> can be implemented as nested <code>let</code> expressions. For example, the <code>let*</code> expression above is equivalent to the nested <code>let</code> expressions below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([a 5])
  (let ([b (+ a a)])
    (let ([c (+ a b)])
      (list a b c)))) ⇒ (5 10 15)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Define <code>let*</code> with <code>define-syntax</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.1.4">Exercise 3.1.4</h4>
<div class="paragraph">
<p>As we saw in <a href="#section_2.9.">Section 2.9</a>, it is legal to omit the third, or <em>alternative</em>, subexpression of an <code>if</code> expression. Doing so, however, often leads to confusion. Scheme provides two syntactic forms, <code>when</code> and <code>unless</code>, that may be used in place of such "one-armed" <code>if</code> expressions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(when <em>test</em> <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)
(unless <em>test</em> <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>With both forms, <code>test</code> is evaluated first. For <code>when</code>, if <code>test</code> evaluates to true, the remaining forms are evaluated in sequence as if enclosed in an implicit <code>begin</code> expression. If <code>test</code> evaluates to false, the remaining forms are not evaluated, and the result is unspecified. <code>unless</code> is similar except that the remaining forms are evaluated only if <code>test</code> evaluates to false.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 3])
  (unless (= x 0) (set! x (+ x 1)))
  (when (= x 4) (set! x (* x 2)))
  x) ⇒ 8</code></pre>
</div>
</div>
<div class="paragraph">
<p>Define <code>when</code> as a syntactic extension in terms of <code>if</code> and <code>begin</code>, and define <code>unless</code> in terms of <code>when</code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_3.2.">Section 3.2. More Recursion</h3>
<div class="paragraph">
<p>In <a href="#section_2.8.">Section 2.8</a>, we saw how to define recursive procedures using top-level definitions. Before that, we saw how to create local bindings for procedures using <code>let</code>. It is natural to wonder whether a <code>let</code>-bound procedure can be recursive. The answer is no, at least not in a straightforward way. If you try to evaluate the expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([sum (lambda (ls)
             (if (null? ls)
                 0
                 (+ (car ls) (sum (cdr ls)))))])
  (sum '(1 2 3 4 5)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>it will probably raise an exception with a message to the effect that <code>sum</code> is undefined. This is because the variable <code>sum</code> is visible only within the body of the <code>let</code> expression and not within the <code>lambda</code> expression whose value is bound to <code>sum</code>. We can get around this problem by passing the procedure <code>sum</code> to itself as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([sum (lambda (sum ls)
             (if (null? ls)
                 0
                 (+ (car ls) (sum sum (cdr ls)))))])
  (sum sum '(1 2 3 4 5))) ⇒ 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works and is a clever solution, but there is an easier way, using <code>letrec</code>. Like <code>let</code>, the <code>letrec</code> syntactic form includes a set of variable-value pairs, along with a sequence of expressions referred to as the <em>body</em> of the <code>letrec</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Unlike <code>let</code>, the variables <code><em>var</em> ...</code> are visible not only within the body of the <code>letrec</code> but also within <code><em>expr</em> ...</code>. Thus, we can rewrite the expression above as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec ([sum (lambda (ls)
                (if (null? ls)
                    0
                    (+ (car ls) (sum (cdr ls)))))])
  (sum '(1 2 3 4 5))) ⇒ 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>letrec</code>, we can also define mutually recursive procedures, such as the procedures <code>even?</code> and <code>odd?</code> that were the subject of <a href="#exercise_2.8.6">Exercise 2.8.6</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec ([even?
          (lambda (x)
            (or (= x 0)
                (odd? (- x 1))))]
         [odd?
          (lambda (x)
            (and (not (= x 0))
                 (even? (- x 1))))])
  (list (even? 20) (odd? 20))) ⇒ (#t #f)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In a <code>letrec</code> expression, <code><em>expr</em> ...</code> are most often <code>lambda</code> expressions, though this need not be the case. One restriction on the expressions must be obeyed, however. It must be possible to evaluate each <code><em>expr</em></code> without evaluating any of the variables <code><em>var</em> ...</code>. This restriction is always satisfied if the expressions are all <code>lambda</code> expressions, since even though the variables may appear within the <code>lambda</code> expressions, they cannot be evaluated until the resulting procedures are invoked in the body of the <code>letrec</code>. The following <code>letrec</code> expression obeys this restriction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec ([f (lambda () (+ x 2))]
         [x 1])
  (f)) ⇒ 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>while the following does not.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec ([y (+ x 2)]
         [x 1])
  y)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, an exception is raised indicating that <code>x</code> is not defined where it is referenced.</p>
</div>
<div class="paragraph">
<p>We can use <code>letrec</code> to hide the definitions of "help" procedures so that they do not clutter the top-level namespace. This is demonstrated by the definition of <code>list?</code> below, which follows the "hare and tortoise" algorithm outlined in <a href="#exercise_2.9.8">Exercise 2.9.8</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define list?
  (lambda (x)
    (letrec ([race
              (lambda (h t)
                (if (pair? h)
                    (let ([h (cdr h)])
                      (if (pair? h)
                          (and (not (eq? h t))
                               (race (cdr h) (cdr t)))
                          (null? h)))
                    (null? h)))])
      (race x x))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>When a recursive procedure is called in only one place outside the procedure, as in the example above, it is often clearer to use a <em>named</em> <code>let</code> expression. Named <code>let</code> expressions take the following form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let <em>name</em> ((<em>var</em> <em>expr</em>) ...)
  <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Named <code>let</code> is similar to unnamed <code>let</code> in that it binds the variables <code><em>var</em> ...</code> to the values of <code><em>expr</em> ...</code> within the body <code><em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...</code>. As with unnamed <code>let</code>, the variables are visible only within the body and not within <code><em>expr</em> ...</code>. In addition, the variable <code><em>name</em></code> is bound within the body to a procedure that may be called to recur; the arguments to the procedure become the new values for the variables <code><em>var</em> ...</code>.</p>
</div>
<div class="paragraph">
<p>The definition of <code>list?</code> has been rewritten below to use named <code>let</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define list?
  (lambda (x)
    (let race ([h x] [t x])
      (if (pair? h)
          (let ([h (cdr h)])
            (if (pair? h)
                (and (not (eq? h t))
                     (race (cdr h) (cdr t)))
                (null? h)))
          (null? h)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Just as <code>let</code> can be expressed as a simple direct application of a <code>lambda</code> expression to arguments, named <code>let</code> can be expressed as the application of a recursive procedure to arguments. A named <code>let</code> of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let <em>name</em> ((<em>var</em> <em>expr</em>) ...)
  <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be rewritten in terms of <code>letrec</code> as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">((letrec ((<em>name</em> (lambda (<em>var</em> ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)))
   <em>name</em>)
 <em>expr</em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, it can be rewritten as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec ((<em>name</em> (lambda (<em>var</em> ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)))
  (<em>name</em> <em>expr</em> ...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>provided that the variable <code><em>name</em></code> does not appear free within <code><em>expr</em> ...</code>.</p>
</div>
<div class="paragraph">
<p>As we discussed in <a href="#section_2.8.">Section 2.8</a>, some recursion is essentially iteration and executes as such. When a procedure call is in tail position (see below) with respect to a <code>lambda</code> expression, it is considered to be a <em>tail call</em>, and Scheme systems must treat it <em>properly</em>, as a "goto" or jump. When a procedure tail-calls itself or calls itself indirectly through a series of tail calls, the result is <em>tail recursion</em>. Because tail calls are treated as jumps, tail recursion can be used for indefinite iteration in place of the more restrictive iteration constructs provided by other programming languages, without fear of overflowing any sort of recursion stack.</p>
</div>
<div class="paragraph">
<p>A call is in tail position with respect to a <code>lambda</code> expression if its value is returned directly from the <code>lambda</code> expression, i.e., if nothing is left to do after the call but to return from the <code>lambda</code> expression. For example, a call is in tail position if it is the last expression in the body of a <code>lambda</code> expression, the <em>consequent</em> or <em>alternative</em> part of an <code>if</code> expression in tail position, the last subexpression of an <code>and</code> or <code>or</code> expression in tail position, the last expression in the body of a <code>let</code> or <code>letrec</code> in tail position, etc. Each of the calls to <code>f</code> in the expressions below are tail calls, but the calls to <code>g</code> are not.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda () (f (g)))
(lambda () (if (g) (f) (f)))
(lambda () (let ([x 4]) (f)))
(lambda () (or (g) (f)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In each case, the values of the calls to <code>f</code> are returned directly, whereas the calls to <code>g</code> are not.</p>
</div>
<div class="paragraph">
<p>Recursion in general and named <code>let</code> in particular provide a natural way to implement many algorithms, whether iterative, recursive, or partly iterative and partly recursive; the programmer is not burdened with two distinct mechanisms.</p>
</div>
<div class="paragraph">
<p>The following two definitions of <code>factorial</code> use named <code>let</code> expressions to compute the factorial, \(n!\), of a nonnegative integer \(n\). The first employs the recursive definition \(n! = n × (n - 1)!\), where \(0!\) is defined to be 1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define factorial
  (lambda (n)
    (let fact ([i n])
      (if (= i 0)
          1
          (* i (fact (- i 1)))))))

(factorial 0) ⇒ 1
(factorial 1) ⇒ 1
(factorial 2) ⇒ 2
(factorial 3) ⇒ 6
(factorial 10) ⇒ 3628800</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second is an iterative version that employs the iterative definition \(n! = n × (n - 1) × (n - 2) × ... × 1\), using an accumulator, <code>a</code>, to hold the intermediate products.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define factorial
  (lambda (n)
    (let fact ([i n] [a 1])
      (if (= i 0)
          a
          (fact (- i 1) (* a i))))))</code></pre>
</div>
</div>
<div id="fibonacci" class="paragraph">
<p>A similar problem is to compute the <em>n</em>th Fibonacci number for a given <em>n</em>. The <em>Fibonacci numbers</em> are an infinite sequence of integers, 0, 1, 1, 2, 3, 5, 8, etc., in which each number is the sum of the two preceding numbers in the sequence. A procedure to compute the <em>n</em>th Fibonacci number is most naturally defined recursively as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define fibonacci
  (lambda (n)
    (let fib ([i n])
      (cond
        [(= i 0) 0]
        [(= i 1) 1]
        [else (+ (fib (- i 1)) (fib (- i 2)))]))))

(fibonacci 0) ⇒ 0
(fibonacci 1) ⇒ 1
(fibonacci 2) ⇒ 1
(fibonacci 3) ⇒ 2
(fibonacci 4) ⇒ 3
(fibonacci 5) ⇒ 5
(fibonacci 6) ⇒ 8
(fibonacci 20) ⇒ 6765
(fibonacci 30) ⇒ 832040</code></pre>
</div>
</div>
<div class="paragraph">
<p>This solution requires the computation of the two preceding Fibonacci numbers at each step and hence is <em>doubly recursive</em>. For example, to compute <code>(fibonacci 4)</code> requires the computation of both <code>(fib 3)</code> and <code>(fib 2)</code>, to compute <code>(fib 3)</code> requires computing both <code>(fib 2)</code> and <code>(fib 1)</code>, and to compute <code>(fib 2)</code> requires computing both <code>(fib 1)</code> and <code>(fib 0)</code>. This is very inefficient, and it becomes more inefficient as <code>n</code> grows. A more efficient solution is to adapt the accumulator solution of the <code>factorial</code> example above to use two accumulators, <code>a1</code> for the current Fibonacci number and <code>a2</code> for the preceding one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define fibonacci
  (lambda (n)
    (if (= n 0)
        0
        (let fib ([i n] [a1 1] [a2 0])
          (if (= i 1)
              a1
              (fib (- i 1) (+ a1 a2) a1))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, zero is treated as a special case, since there is no preceding value. This allows us to use the single base case <code>(= i 1)</code>. The time it takes to compute the<em>n</em>nth Fibonacci number using this iterative solution grows linearly with <em>n</em>, which makes a significant difference when compared to the doubly recursive version. To get a feel for the difference, try computing <code>(fibonacci 35)</code> and <code>(fibonacci 40)</code> using both definitions to see how long each takes.</p>
</div>
<div class="paragraph">
<p>We can also get a feel for the difference by looking at a trace for each on small inputs. The first trace below shows the calls to <code>fib</code> in the non-tail-recursive version of <code>fibonacci</code>, with input 5.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">|(fib 5)
| (fib 4)
| |(fib 3)
| | (fib 2)
| | |(fib 1)
| | |1
| | |(fib 0)
| | |0
| | 1
| | (fib 1)
| | 1
| |2
| |(fib 2)
| | (fib 1)
| | 1
| | (fib 0)
| | 0
| |1
| 3
| (fib 3)
| |(fib 2)
| | (fib 1)
| | 1
| | (fib 0)
| | 0
| |1
| |(fib 1)
| |1
| 2
|5</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how there are several calls to <code>fib</code> with arguments 2, 1, and 0. The second trace shows the calls to <code>fib</code> in the tail-recursive version, again with input 5.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">|(fib 5 1 0)
|(fib 4 1 1)
|(fib 3 2 1)
|(fib 2 3 2)
|(fib 1 5 3)
|5</code></pre>
</div>
</div>
<div class="paragraph">
<p>Clearly, there is quite a difference.</p>
</div>
<div class="paragraph">
<p>The named <code>let</code> examples shown so far are either tail-recursive or not tail-recursive. It often happens that one recursive call within the same expression is tail-recursive while another is not. The definition of <code>factor</code> below computes the prime factors of its nonnegative integer argument. The first call to <code>f</code> is not tail-recursive, but the second one is.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define factor
  (lambda (n)
    (let f ([n n] [i 2])
      (cond
        [(>= i n) (list n)]
        [(integer? (/ n i))
         (cons i (f (/ n i) i))]
        [else (f n (+ i 1))]))))

(factor 0) ⇒ (0)
(factor 1) ⇒ (1)
(factor 12) ⇒ (2 2 3)
(factor 3628800) ⇒ (2 2 2 2 2 2 2 2 3 3 3 3 5 5 7)
(factor 9239) ⇒ (9239)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A trace of the calls to <code>f</code>, produced in Chez Scheme by replacing <code>let</code> with <code>trace-let</code>, in the evaluation of <code>(factor 120)</code> below highlights the difference between the nontail calls and the tail calls.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">|(f 120 2)
| (f 60 2)
| |(f 30 2)
| | (f 15 2)
| | (f 15 3)
| | |(f 5 3)
| | |(f 5 4)
| | |(f 5 5)
| | |(5)
| | (3 5)
| |(2 3 5)
| (2 2 3 5)
|(2 2 2 3 5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A nontail call to <code>f</code> is shown indented relative to its caller, since the caller is still active, whereas tail calls appear at the same level of indentation.</p>
</div>
<div class="sect3">
<h4 id="exercise_3.2.1">Exercise 3.2.1</h4>
<div id="further:s52" class="paragraph">
<p>Which of the recursive procedures defined in <a href="#section_3.2.">Section 3.2</a> are tail-recursive, and which are not?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.2.2">Exercise 3.2.2</h4>
<div class="paragraph">
<p>Rewrite <code>factor</code> using <code>letrec</code> to bind <code>f</code> in place of named <code>let</code>. Which version do you prefer?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.2.3">Exercise 3.2.3</h4>
<div class="paragraph">
<p>Can the <code>letrec</code> expression below be rewritten using named <code>let</code>? If not, why not? If so, do it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec ([even?
          (lambda (x)
            (or (= x 0)
                (odd? (- x 1))))]
         [odd?
          (lambda (x)
            (and (not (= x 0))
                 (even? (- x 1))))])
  (even? 20))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.2.4">Exercise 3.2.4</h4>
<div class="paragraph">
<p>Rewrite both definitions of <code>fibonacci</code> given in this section to count the number of recursive calls to <code>fib</code>, using a counter similar to the one used in the <code>cons-count</code> example of <a href="#section_2.9.">Section 2.9</a>. Count the number of recursive calls made in each case for several input values. What do you notice?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.2.5">Exercise 3.2.5</h4>
<div id="further:s57" class="paragraph">
<p>Augment the definition of <code>let</code> given in <a href="#section_3.1.">Section 3.1</a> to handle named <code>let</code> as well as unnamed <code>let</code>, using two rules.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.2.6">Exercise 3.2.6</h4>
<div class="paragraph">
<p>The following definition of <code>or</code> is simpler than the one given in <a href="#section_3.1.">Section 3.1</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax or ; incorrect!
  (syntax-rules ()
    [(_) #f]
    [(_ e1 e2 ...)
     (let ([t e1])
       (if t t (or e2 ...)))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Say why it is not correct. [<em>Hint</em>: Think about what would happen if this version of <code>or</code> were used in the <code>even?</code> and <code>odd?</code> example given on page 66 for very large inputs.]</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.2.7">Exercise 3.2.7</h4>
<div class="paragraph">
<p>The definition of <code>factor</code> is not the most efficient possible. First, no factors of <em>n</em> besides <em>n</em> itself can possibly be found beyond \(\sqrt{n}\). Second, the division <code>(/ n i)</code> is performed twice when a factor is found. Third, after 2, no even factors can possibly be found. Recode <code>factor</code> to correct all three problems. Which is the most important problem to solve? Are there any additional improvements you can make?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_3.3.">Section 3.3. Continuations</h3>
<div class="paragraph">
<p>During the evaluation of a Scheme expression, the implementation must keep track of two things: (1) what to evaluate and (2) what to do with the value. Consider the evaluation of <code>(null? x)</code> within the expression below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(if (null? x) (quote ()) (cdr x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation must first evaluate <code>(null? x)</code> and, based on its value, evaluate either <code>(quote ())</code> or <code>(cdr x)</code>. "What to evaluate" is <code>(null? x)</code>, and "what to do with the value" is to make the decision which of <code>(quote ())</code> and <code>(cdr x)</code> to evaluate and to do so. We call "what to do with the value" the <em>continuation</em> of a computation.</p>
</div>
<div class="paragraph">
<p>Thus, at any point during the evaluation of any expression, there is a continuation ready to complete, or at least <em>continue</em>, the computation from that point. Let&#8217;s assume that <code>x</code> has the value <code>(a b c)</code>. We can isolate six continuations during the evaluation of <code>(if (null? x) (quote ()) (cdr x))</code>, the continuations waiting for</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>the value of <code>(if (null? x) (quote ()) (cdr x))</code>,</p>
</li>
<li>
<p>the value of <code>(null? x)</code>,</p>
</li>
<li>
<p>the value of <code>null?</code>,</p>
</li>
<li>
<p>the value of <code>x</code>,</p>
</li>
<li>
<p>the value of <code>cdr</code>, and</p>
</li>
<li>
<p>the value of <code>x</code> (again).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The continuation of <code>(cdr x)</code> is not listed because it is the same as the one waiting for <code>(if (null? x) (quote ()) (cdr x))</code>.</p>
</div>
<div class="paragraph">
<p>Scheme allows the continuation of any expression to be captured with the procedure <code>call/cc</code>. <code>call/cc</code> must be passed a procedure <code><em>p</em></code> of one argument. <code>call/cc</code> constructs a concrete representation of the current continuation and passes it to <code><em>p</em></code>. The continuation itself is represented by a procedure <code><em>k</em></code>. Each time <code><em>k</em></code> is applied to a value, it returns the value to the continuation of the <code>call/cc</code> application. This value becomes, in essence, the value of the application of <code>call/cc</code>.</p>
</div>
<div class="paragraph">
<p>If <code><em>p</em></code> returns without invoking <code><em>k</em></code>, the value returned by the procedure becomes the value of the application of <code>call/cc</code>.</p>
</div>
<div class="paragraph">
<p>Consider the simple examples below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(call/cc
  (lambda (k)
    (* 5 4))) ⇒ 20

(call/cc
  (lambda (k)
    (* 5 (k 4)))) ⇒ 4

(+ 2
   (call/cc
     (lambda (k)
       (* 5 (k 4))))) ⇒ 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the first example, the continuation is captured and bound to <code>k</code>, but <code>k</code> is never used, so the value is simply the product of 5 and 4. In the second, the continuation is invoked before the multiplication, so the value is the value passed to the continuation, 4. In the third, the continuation includes the addition by 2; thus, the value is the value passed to the continuation, 4, plus 2.</p>
</div>
<div class="paragraph">
<p>Here is a less trivial example, showing the use of <code>call/cc</code> to provide a nonlocal exit from a recursion.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define product
  (lambda (ls)
    (call/cc
      (lambda (break)
        (let f ([ls ls])
          (cond
            [(null? ls) 1]
            [(= (car ls) 0) (break 0)]
            [else (* (car ls) (f (cdr ls)))]))))))

(product '(1 2 3 4 5)) ⇒ 120
(product '(7 3 8 0 1 9 5)) ⇒ 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The nonlocal exit allows <code>product</code> to return immediately, without performing the pending multiplications, when a zero value is detected.</p>
</div>
<div class="paragraph">
<p>Each of the continuation invocations above returns to the continuation while control remains within the procedure passed to <code>call/cc</code>. The following example uses the continuation after this procedure has already returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x (call/cc (lambda (k) k))])
  (x (lambda (ignore) "hi"))) ⇒ "hi"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The continuation captured by this invocation of <code>call/cc</code> may be described as "Take the value, bind it to <code>x</code>, and apply the value of <code>x</code> to the value of <code>(lambda (ignore) "hi")</code>." Since <code>(lambda (k) k)</code> returns its argument, <code>x</code> is bound to the continuation itself; this continuation is applied to the procedure resulting from the evaluation of <code>(lambda (ignore) "hi")</code>. This has the effect of binding <code>x</code> (again!) to this procedure and applying the procedure to itself. The procedure ignores its argument and returns <code>"hi"</code>.</p>
</div>
<div class="paragraph">
<p>The following variation of the example above is probably the most confusing Scheme program of its size; it might be easy to guess what it returns, but it takes some thought to figure out why.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(((call/cc (lambda (k) k)) (lambda (x) x)) "HEY!") ⇒ "HEY!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of the <code>call/cc</code> is its own continuation, as in the preceding example. This is applied to the identity procedure <code>(lambda (x) x)</code>, so the <code>call/cc</code> returns a second time with this value. Then, the identity procedure is applied to itself, yielding the identity procedure. This is finally applied to <code>"HEY!"</code>, yielding <code>"HEY!"</code>.</p>
</div>
<div class="paragraph">
<p>Continuations used in this manner are not always so puzzling. Consider the following definition of <code>factorial</code> that saves the continuation at the base of the recursion before returning 1, by assigning the top-level variable <code>retry</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define retry #f)

(define factorial
  (lambda (x)
    (if (= x 0)
        (call/cc (lambda (k) (set! retry k) 1))
        (* x (factorial (- x 1))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this definition, <code>factorial</code> works as we expect <code>factorial</code> to work, except it has the side effect of assigning <code>retry</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(factorial 4) ⇒ 24
(retry 1) ⇒ 24
(retry 2) ⇒ 48</code></pre>
</div>
</div>
<div class="paragraph">
<p>The continuation bound to <code>retry</code> might be described as "Multiply the value by 1, then multiply this result by 2, then multiply this result by 3, then multiply this result by 4." If we pass the continuation a different value, i.e., not 1, we will cause the base value to be something other than 1 and hence change the end result.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(retry 2) ⇒ 48
(retry 5) ⇒ 120</code></pre>
</div>
</div>
<div class="paragraph">
<p>This mechanism could be the basis for a breakpoint package implemented with <code>call/cc</code>; each time a breakpoint is encountered, the continuation of the breakpoint is saved so that the computation may be restarted from the breakpoint (more than once, if desired).</p>
</div>
<div class="paragraph">
<p>Continuations may be used to implement various forms of multitasking. The simple "light-weight process" mechanism defined below allows multiple computations to be interleaved. Since it is <em>nonpreemptive</em>, it requires that each process voluntarily "pause" from time to time in order to allow the others to run.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define lwp-list '())
(define lwp
  (lambda (thunk)
    (set! lwp-list (append lwp-list (list thunk)))))

(define start
  (lambda ()
    (let ([p (car lwp-list)])
      (set! lwp-list (cdr lwp-list))
      (p))))

(define pause
  (lambda ()
    (call/cc
      (lambda (k)
        (lwp (lambda () (k #f)))
        (start)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following light-weight processes cooperate to print an infinite sequence of lines containing <code>"hey!"</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lwp (lambda () (let f () (pause) (display "h") (f))))
(lwp (lambda () (let f () (pause) (display "e") (f))))
(lwp (lambda () (let f () (pause) (display "y") (f))))
(lwp (lambda () (let f () (pause) (display "!") (f))))
(lwp (lambda () (let f () (pause) (newline) (f))))
(start) ⇒ <em>hey!</em>
           <em>hey!</em>
           <em>hey!</em>
           <em>hey!</em>
           &#8230;&#8203;</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#section_12.11.">Section 12.11</a> for an implementation of <em>engines</em>, which support preemptive multitasking, with <code>call/cc</code>.</p>
</div>
<div class="sect3">
<h4 id="exercise_3.3.1">Exercise 3.3.1</h4>
<div id="further:s66" class="paragraph">
<p>Use <code>call/cc</code> to write a program that loops indefinitely, printing a sequence of numbers beginning at zero. Do not use any recursive procedures, and do not use any assignments.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.3.2">Exercise 3.3.2</h4>
<div class="paragraph">
<p>Rewrite <code>product</code> without <code>call/cc</code>, retaining the feature that no multiplications are performed if any of the list elements are zero.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.3.3">Exercise 3.3.3</h4>
<div class="paragraph">
<p>What would happen if a process created by <code>lwp</code> as defined above were to terminate, i.e., simply return without calling <code>pause</code>? Define a <code>quit</code> procedure that allows a process to terminate without otherwise affecting the <code>lwp</code> system. Be sure to handle the case in which the only remaining process terminates.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.3.4">Exercise 3.3.4</h4>
<div class="paragraph">
<p>Each time <code>lwp</code> is called, the list of processes is copied because <code>lwp</code> uses <code>append</code> to add its argument to the end of the process list. Modify the original <code>lwp</code> code to use the queue data type developed in <a href="#section_2.9.">Section 2.9</a> to avoid this problem.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.3.5">Exercise 3.3.5</h4>
<div class="paragraph">
<p>The light-weight process mechanism allows new processes to be created dynamically, although the example given in this section does not do so. Design an application that requires new processes to be created dynamically and implement it using the light-weight process mechanism.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_3.4.">Section 3.4. Continuation Passing Style</h3>
<div class="paragraph">
<p>As we discussed in the preceding section, a continuation waits for the value of each expression. In particular, a continuation is associated with each procedure call. When one procedure invokes another via a nontail call, the called procedure receives an implicit continuation that is responsible for completing what is left of the calling procedure&#8217;s body plus returning to the calling procedure&#8217;s continuation. If the call is a tail call, the called procedure simply receives the continuation of the calling procedure.</p>
</div>
<div class="paragraph">
<p>We can make the continuations explicit by encapsulating "what to do" in an explicit procedural argument passed along on each call. For example, the continuation of the call to <code>f</code> in</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec ([f (lambda (x) (cons 'a x))]
         [g (lambda (x) (cons 'b (f x)))]
         [h (lambda (x) (g (cons 'c x)))])
  (cons 'd (h '()))) ⇒ (d b a c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>conses the symbol <code>b</code> onto the value returned to it, then returns the result of this cons to the continuation of the call to <code>g</code>. This continuation is the same as the continuation of the call to <code>h</code>, which conses the symbol <code>d</code> onto the value returned to it. We can rewrite this in <em>continuation-passing style</em>, or CPS, by replacing these implicit continuations with explicit procedures.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec ([f (lambda (x k) (k (cons 'a x)))]
         [g (lambda (x k)
              (f x (lambda (v) (k (cons 'b v)))))]
         [h (lambda (x k) (g (cons 'c x) k))])
  (h '() (lambda (v) (cons 'd v))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Like the implicit continuation of <code>h</code> and <code>g</code> in the preceding example, the explicit continuation passed to <code>h</code> and on to <code>g</code>,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (v) (cons 'd v))</code></pre>
</div>
</div>
<div class="paragraph">
<p>conses the symbol <code>d</code> onto the value passed to it. Similarly, the continuation passed to <code>f</code>,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (v) (k (cons 'b v)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>conses <code>b</code> onto the value passed to it, then passes this on to the continuation of <code>g</code>.</p>
</div>
<div class="paragraph">
<p>Expressions written in CPS are more complicated, of course, but this style of programming has some useful applications. CPS allows a procedure to pass more than one result to its continuation, because the procedure that implements the continuation can take any number of arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define car&cdr
  (lambda (p k)
    (k (car p) (cdr p))))

(car&cdr '(a b c)
  (lambda (x y)
    (list y x))) ⇒ ((b c) a)
(car&cdr '(a b c) cons) ⇒ (a b c)
(car&cdr '(a b c a d) memv) ⇒ (a d)</code></pre>
</div>
</div>
<div class="paragraph">
<p>(This can be done with multiple values as well; see <a href="#section_5.8.">Section 5.8</a>.) CPS also allows a procedure to take separate "success" and "failure" continuations, which may accept different numbers of arguments. An example is <code>integer-divide</code> below, which passes the quotient and remainder of its first two arguments to its third, unless the second argument (the divisor) is zero, in which case it passes an error message to its fourth argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define integer-divide
  (lambda (x y success failure)
    (if (= y 0)
        (failure "divide by zero")
        (let ([q (quotient x y)])
          (success q (- x (* q y)))))))

(integer-divide 10 3 list (lambda (x) x)) ⇒ (3 1)
(integer-divide 10 0 list (lambda (x) x)) ⇒ "divide by zero"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The procedure <code>quotient</code>, employed by <code>integer-divide</code>, returns the quotient of its two arguments, truncated toward zero.</p>
</div>
<div class="paragraph">
<p>Explicit success and failure continuations can sometimes help to avoid the extra communication necessary to separate successful execution of a procedure from unsuccessful execution. Furthermore, it is possible to have multiple success or failure continuations for different flavors of success or failure, each possibly taking different numbers and types of arguments. See Sections <a href="#section_12.10.">12.10</a> and <a href="#section_12.11.">12.11</a> for extended examples that employ continuation-passing style.</p>
</div>
<div class="paragraph">
<p>At this point you might be wondering about the relationship between CPS and the continuations captured via <code>call/cc</code>. It turns out that any program that uses <code>call/cc</code> can be rewritten in CPS without <code>call/cc</code>, but a total rewrite of the program (sometimes including even system-defined primitives) might be necessary. Try to convert the <code>product</code> example on <a href="#defn:product-call/cc">page 75</a> into CPS before looking at the version below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define product
  (lambda (ls k)
    (let ([break k])
      (let f ([ls ls] [k k])
        (cond
          [(null? ls) (k 1)]
          [(= (car ls) 0) (break 0)]
          [else (f (cdr ls)
                   (lambda (x)
                     (k (* (car ls) x))))])))))

(product '(1 2 3 4 5) (lambda (x) x)) ⇒ 120
(product '(7 3 8 0 1 9 5) (lambda (x) x)) ⇒ 0</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.4.1">Exercise 3.4.1</h4>
<div class="paragraph">
<p>Rewrite the <code>reciprocal</code> example first given in <a href="#section_2.1.">Section 2.1</a> to accept both success and failure continuations, like <code>integer-divide</code> above.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.4.2">Exercise 3.4.2</h4>
<div id="further:s77" class="paragraph">
<p>Rewrite the <code>retry</code> example from <a href="#defn:product-call/cc">page 75</a> to use CPS.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.4.3">Exercise 3.4.3</h4>
<div class="paragraph">
<p>Rewrite the following expression in CPS to avoid using <code>call/cc</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define reciprocals
  (lambda (ls)
    (call/cc
      (lambda (k)
        (map (lambda (x)
               (if (= x 0)
                   (k "zero found")
                   (/ 1 x)))
             ls)))))

(reciprocals '(2 1/3 5 1/4)) ⇒ (1/2 3 1/5 4)
(reciprocals '(2 1/3 0 5 1/4)) ⇒ "zero found"</code></pre>
</div>
</div>
<div class="paragraph">
<p>[<em>Hint</em>: A single-list version of <code>map</code> is defined on <a href="#defn:map1">page 46</a>.]</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_3.5.">Section 3.5. Internal Definitions</h3>
<div class="paragraph">
<p>In <a href="#section_2.6.">Section 2.6</a>, we discussed top-level definitions. Definitions may also appear at the front of a <code>lambda</code>, <code>let</code>, or <code>letrec</code> body, in which case the bindings they create are local to the body.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define f (lambda (x) (* x x)))
(let ([x 3])
  (define f (lambda (y) (+ y x)))
  (f 4)) ⇒ 7
(f 4) ⇒ 16</code></pre>
</div>
</div>
<div class="paragraph">
<p>Procedures bound by internal definitions can be mutually recursive, as with <code>letrec</code>. For example, we can rewrite the <code>even?</code> and <code>odd?</code> example from <a href="#section_3.2.">Section 3.2</a> using internal definitions as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ()
  (define even?
    (lambda (x)
      (or (= x 0)
          (odd? (- x 1)))))
  (define odd?
    (lambda (x)
      (and (not (= x 0))
           (even? (- x 1)))))
  (even? 20)) ⇒ #t</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, we can replace the use of <code>letrec</code> to bind <code>race</code> with an internal definition of <code>race</code> in our first definition of <code>list?</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define list?
  (lambda (x)
    (define race
      (lambda (h t)
        (if (pair? h)
            (let ([h (cdr h)])
              (if (pair? h)
                  (and (not (eq? h t))
                       (race (cdr h) (cdr t)))
                  (null? h)))
            (null? h))))
    (race x x)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In fact, internal variable definitions and <code>letrec</code> are practically interchangeable. The only difference, other than the obvious difference in syntax, is that variable definitions are guaranteed to be evaluated from left to right, while the bindings of a letrec may be evaluated in any order. So we cannot quite replace a <code>lambda</code>, <code>let</code>, or <code>letrec</code> body containing internal definitions with a <code>letrec</code> expression. We can, however, use <code>letrec*</code>, which, like <code>let*</code>, guarantees left-to-right evaluation order. A body of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define <em>var</em> <em>expr<sub>0</sub></em>)
  &#8230;&#8203;
<em>expr<sub>1</sub></em>
<em>expr<sub>2</sub></em>
  &#8230;&#8203;</code></pre>
</div>
</div>
<div class="paragraph">
<p>is equivalent to a <code>letrec*</code> expression binding the defined variables to the associated values in a body comprising the expressions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec* ((<em>var</em> <em>expr<sub>0</sub></em>) ...) <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Conversely, a <code>letrec*</code> of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec* ((<em>var</em> <em>expr<sub>0</sub></em>) ...) <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be replaced with a <code>let</code> expression containing internal definitions and the expressions from the body as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ()
  (define <em>var</em> <em>expr<sub>0</sub></em>)
    &#8230;&#8203;
  <em>expr<sub>1</sub></em>
  <em>expr<sub>2</sub></em>
    &#8230;&#8203;
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The seeming lack of symmetry between these transformations is due to the fact that <code>letrec*</code> expressions can appear anywhere an expression is valid, whereas internal definitions can appear only at the front of a body. Thus, in replacing a <code>letrec*</code> with internal definitions, we must generally introduce a <code>let</code> expression to hold the definitions.</p>
</div>
<div class="paragraph">
<p>Another difference between internal definitions and <code>letrec</code> or <code>letrec*</code> is that syntax definitions may appear among the internal definitions, while <code>letrec</code> and <code>letrec*</code> bind only variables.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 3])
  (define-syntax set-x!
    (syntax-rules ()
      [(_ e) (set! x e)]))
  (set-x! (+ x x))
  x) ⇒ 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>The scope of a syntactic extension established by an internal syntax definition, as with an internal variable definition, is limited to the body in which the syntax definition appears.</p>
</div>
<div class="paragraph">
<p>Internal definitions may be used in conjunction with top-level definitions and assignments to help modularize programs. Each module of a program should make visible only those bindings that are needed by other modules, while hiding other bindings that would otherwise clutter the top-level namespace and possibly result in unintended use or redefinition of those bindings. A common way of structuring a module is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define <em>export-var</em> #f)
  &#8230;&#8203;
(let ()
  (define <em>var</em> <em>expr</em>)
    &#8230;&#8203;
  <em>init-expr</em>
    &#8230;&#8203;
  (set! <em>export-var</em> <em>export-val</em>)
    &#8230;&#8203;
)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first set of definitions establish top-level bindings for the variables we desire to export (make visible globally). The second set of definitions establish local bindings visible only within the module. The expressions <code><em>init-expr</em> ...</code> perform any initialization that must occur after the local bindings have been established. Finally, the <code>set!</code> expressions assign the exported variables to the appropriate values.</p>
</div>
<div class="paragraph">
<p>An advantage of this form of modularization is that the bracketing <code>let</code> expression may be removed or "commented out" during program development, making the internal definitions top-level to facilitate interactive testing. This form of modularization also has several disadvantages, as we discuss in the next section.</p>
</div>
<div class="paragraph">
<p>The following module exports a single variable, <code>calc</code>, which is bound to a procedure that implements a simple four-function calculator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define calc #f)
(let ()
  (define do-calc
    (lambda (ek expr)
      (cond
        [(number? expr) expr]
        [(and (list? expr) (= (length expr) 3))
         (let ([op (car expr)] [args (cdr expr)])
           (case op
             [(add) (apply-op ek + args)]
             [(sub) (apply-op ek - args)]
             [(mul) (apply-op ek * args)]
             [(div) (apply-op ek / args)]
             [else (complain ek "invalid operator" op)]))]
        [else (complain ek "invalid expression" expr)])))
  (define apply-op
    (lambda (ek op args)
      (op (do-calc ek (car args)) (do-calc ek (cadr args)))))
  (define complain
    (lambda (ek msg expr)
      (ek (list msg expr))))
  (set! calc
    (lambda (expr)
      ; grab an error continuation ek
      (call/cc
        (lambda (ek)
          (do-calc ek expr))))))

(calc '(add (mul 3 2) -4)) ⇒ 2
(calc '(div 1/2 1/6)) ⇒ 3
(calc '(add (mul 3 2) (div 4))) ⇒ ("invalid expression" (div 4))
(calc '(mul (add 1 -2) (pow 2 7))) ⇒ ("invalid operator" pow)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This example uses a <code>case</code> expression to determine which operator to apply. <code>case</code> is similar to <code>cond</code> except that the test is always the same: <code>(memv <em>val</em> (<em>key</em> ...))</code>, where <code><em>val</em></code> is the value of the first <code>case</code> subform and <code>(<em>key</em> ...)</code> is the list of items at the front of each <code>case</code> clause. The <code>case</code> expression in the example above could be rewritten using <code>cond</code> as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([temp op])
  (cond
    [(memv temp '(add)) (apply-op ek + args)]
    [(memv temp '(sub)) (apply-op ek - args)]
    [(memv temp '(mul)) (apply-op ek * args)]
    [(memv temp '(div)) (apply-op ek / args)]
    [else (complain ek "invalid operator" op)]))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.5.1">Exercise 3.5.1</h4>
<div class="paragraph">
<p>Redefine <code>complain</code> in the <code>calc</code> example as an equivalent syntactic extension.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.5.2">Exercise 3.5.2</h4>
<div id="further:s87" class="paragraph">
<p>In the <code>calc</code> example, the error continuation <code>ek</code> is passed along on each call to <code>apply-op</code>, <code>complain</code>, and <code>do-calc</code>. Move the definitions of <code>apply-op</code>, <code>complain</code>, and <code>do-calc</code> inward as far as necessary to eliminate the <code>ek</code> argument from the definitions and applications of these procedures.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.5.3">Exercise 3.5.3</h4>
<div class="paragraph">
<p>Eliminate the <code>call/cc</code> from <code>calc</code> and rewrite <code>complain</code> to raise an exception using <code>assertion-violation</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.5.4">Exercise 3.5.4</h4>
<div class="paragraph">
<p>Extend <code>calc</code> to handle unary minus expressions, e.g.,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(calc '(minus (add 2 3))) ⇒ -5</code></pre>
</div>
</div>
<div class="paragraph">
<p>and other operators of your choice.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_3.6.">Section 3.6. Libraries</h3>
<div class="paragraph">
<p>At the end of the preceding section, we discussed a form of modularization that involves assigning a set of top-level variables from within a <code>let</code> while keeping unpublished helpers local to the <code>let</code>. This form of modularization has several drawbacks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is unportable, because the behavior and even existence of an interactive top level is not guaranteed by the Revised<sup>6</sup> Report.</p>
</li>
<li>
<p>It requires assignments, which make the code appear somewhat awkward and may inhibit compiler analyses and optimizations.</p>
</li>
<li>
<p>It does not support the publication of keyword bindings, since there is no analogue to <code>set!</code> for keywords.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An alternative that does not share these drawbacks is to create a library. A library exports a set of identifiers, each defined within the library or imported from some other library. An exported identifier need not be bound as a variable; it may be bound as a keyword instead.</p>
</div>
<div class="paragraph">
<p>The following library exports two identifiers: the variable <code>gpa-&gt;grade</code> and the keyword <code>gpa</code>. The variable <code>gpa-&gt;grade</code> is bound to a procedure that takes a grade-point average (GPA), represented as a number, and returns the corresponding letter grade, based on a four-point scale. The keyword <code>gpa</code> names a syntactic extension whose subforms must all be letter grades and whose value is the GPA computed from those letter grades.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (grades)
  (export gpa->grade gpa)
  (import (rnrs))

  (define in-range?
    (lambda (x n y)
      (and (>= n x) (< n y))))

  (define-syntax range-case
    (syntax-rules (- else)
      [(_ expr ((x - y) e1 e2 ...) ... [else ee1 ee2 ...])
       (let ([tmp expr])
         (cond
           [(in-range? x tmp y) e1 e2 ...]
           ...
           [else ee1 ee2 ...]))]
      [(_ expr ((x - y) e1 e2 ...) ...)
       (let ([tmp expr])
         (cond
           [(in-range? x tmp y) e1 e2 ...]
           ...))]))

  (define letter->number
    (lambda (x)
      (case x
        [(a)  4.0]
        [(b)  3.0]
        [(c)  2.0]
        [(d)  1.0]
        [(f)  0.0]
        [else (assertion-violation 'grade "invalid letter grade" x)])))

  (define gpa->grade
    (lambda (x)
      (range-case x
        [(0.0 - 0.5) 'f]
        [(0.5 - 1.5) 'd]
        [(1.5 - 2.5) 'c]
        [(2.5 - 3.5) 'b]
        [else 'a])))

  (define-syntax gpa
    (syntax-rules ()
      [(_ g1 g2 ...)
       (let ([ls (map letter->number '(g1 g2 ...))])
         (/ (apply + ls) (length ls)))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The name of the library is <code>(grades)</code>. This may seem like a funny kind of name, but all library names are parenthesized. The library imports from the standard <code>(rnrs)</code> library, which contains most of the primitive and keyword bindings we have used in this chapter and the last, and everything we need to implement <code>gpa-&gt;grade</code> and <code>gpa</code>.</p>
</div>
<div class="paragraph">
<p>Along with <code>gpa-&gt;grade</code> and <code>gpa</code>, several other syntactic extensions and procedures are defined within the library, but none of the others are exported. The ones that aren&#8217;t exported are simply helpers for the ones that are. Everything used within the library should be familiar, except for the <code>apply</code> procedure, which is described on <a href="#desc:apply">page 107</a>.</p>
</div>
<div class="paragraph">
<p>If your Scheme implementation supports <code>import</code> in the interactive top level, you can test the two exports as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(import (grades))
(gpa c a c b b) ⇒ 2.8
(gpa->grade 2.8) ⇒ b</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#chp_libraries_and_top_level_programs">Chapter 10</a> describes libraries in more detail and provides additional examples of their use.</p>
</div>
<div class="sect3">
<h4 id="exercise_3.6.1">Exercise 3.6.1</h4>
<div class="paragraph">
<p>Modify <code>gpa</code> to handle &#8220;x&#8221; grades, which do not count in the grade-point average. Be careful to handle gracefully the situation where each grade is <code>x</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(import (grades))
(gpa a x b c) ⇒ 3.0</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.6.2">Exercise 3.6.2</h4>
<div id="further:s91" class="paragraph">
<p>Export from <code>(grades)</code> a new syntactic form, <code>distribution</code>, that takes a set of grades, like <code>gpa</code>, but returns a list of the form <code>((<em>n</em> <em>g</em>) ...)</code>, where <code><em>n</em></code> is the number of times <code><em>g</em></code> appears in the set, with one entry for each <code><em>g</em></code>. Have <code>distribution</code> call an unexported procedure to do the actual work.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(import (grades))
(distribution a b a c c c a f b a) ⇒ ((4 a) (2 b) (3 c) (0 d) (1 f))</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exercise_3.6.3">Exercise 3.6.3</h4>
<div class="paragraph">
<p>Now read about output operations in <a href="#section_7.8.">Section 7.8</a> and define a new export, <code>histogram</code>, as a procedure that takes a <code><em>textual output port</em></code> and a distribution, such as might be produced by <code>distribution</code>, and prints a histogram in the style illustrated by the example below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(import (grades))
(histogram
  (current-output-port)
  (distribution a b a c c a c a f b a))</code></pre>
</div>
</div>
<div class="paragraph">
<p>prints:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">  a: *****
  b: **
  c: ***
  d:
  f: *</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chp_procedures_and_variable_bindings">Chapter 4. Procedures and Variable Bindings</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/ch4.png" alt="ch4">
</div>
</div>
<div class="paragraph">
<p>Procedures and variable bindings are the fundamental building blocks of Scheme programs. This chapter describes the small set of syntactic forms whose primary purpose is to create procedures and manipulate variable bindings. It begins with the two most fundamental building blocks of Scheme programs: variable references and <code>lambda</code> expressions, and continues with descriptions of the variable binding and assignment forms such as <code>define</code>, <code>letrec</code>, <code>let-values</code>, and <code>set!</code>.</p>
</div>
<div class="paragraph">
<p>Various other forms that bind or assign variables for which the binding or assignment is not the primary purpose (such as named <code>let</code>) are found in <a href="#chp_control_operations">Chapter 5</a>.</p>
</div>
<div class="sect2">
<h3 id="section_4.1.">Section 4.1. Variable References</h3>
<div id="binding:s2" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code><em>variable</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the value of <code><em>variable</em></code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Any identifier appearing as an expression in a program is a variable if a visible variable binding for the identifier exists, e.g., the identifier appears within the scope of a binding created by <code>define</code>, <code>lambda</code>, <code>let</code>, or some other variable-binding construct.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">list ⇒ #&lt;procedure&gt;
(define x 'a)
(list x x) ⇒ (a a)
(let ([x 'b])
  (list x x)) ⇒ (b b)
(let ([let 'let]) let) ⇒ let</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is a syntax violation for an identifier reference to appear within a <code>library</code> form or top-level program if it is not bound as a variable, keyword, record name, or other entity. Since the scope of the definitions in a <code>library</code>, top-level program, <code>lambda</code>, or other local body is the entire body, it is not necessary for the definition of a variable to appear before its first reference appears, as long as the reference is not actually evaluated until the definition has been completed. So, for example, the reference to <code>g</code> within the definition of <code>f</code> below</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define f
  (lambda (x)
    (g x)))
(define g
  (lambda (x)
    (+ x x)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>is okay, but the reference to <code>g</code> in the definition of <code>q</code> below is not.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define q (g 3))
(define g
  (lambda (x)
    (+ x x)))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_4.2.">Section 4.2. Lambda</h3>
<div id="binding:s3" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(lambda <em>formals</em> <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a procedure</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>lambda</code> syntactic form is used to create procedures. Any operation that creates a procedure or establishes local variable bindings is ultimately defined in terms of <code>lambda</code> or <code>case-lambda</code>.</p>
</div>
<div class="paragraph">
<p>The variables in <code><em>formals</em></code> are the formal parameters of the procedure, and the sequence of subforms <code><em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...</code> is its body.</p>
</div>
<div id="binding:s6" class="paragraph">
<p>The body may begin with a sequence of definitions, in which case the bindings created by the definitions are local to the body. If definitions are present, the keyword bindings are used and discarded while expanding the body, and the body is expanded into a <code>letrec*</code> expression formed from the variable definitions and the remaining expressions, as described on <a href="#body-expansion">page 292</a>. The remainder of this description of <code>lambda</code> assumes that this transformation has taken place, if necessary, so that the body is a sequence of expressions without definitions.</p>
</div>
<div class="paragraph">
<p>When the procedure is created, the bindings of all variables occurring free within the body, excluding the formal parameters, are retained with the procedure. Subsequently, whenever the procedure is applied to a sequence of actual parameters, the formal parameters are bound to the actual parameters, the retained bindings are restored, and the body is evaluated.</p>
</div>
<div class="paragraph">
<p>Upon application, the formal parameters defined by <code><em>formals</em></code> are bound to the actual parameters as follows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If <code><em>formals</em></code> is a proper list of variables, e.g., <code>(x y z)</code>, each variable is bound to the corresponding actual parameter. An exception with condition type <code>&amp;assertion</code> is raised if too few or too many actual parameters are supplied.</p>
</li>
<li>
<p>If <code><em>formals</em></code> is a single variable (not in a list), e.g., <code>z</code>, it is bound to a list of the actual parameters.</p>
</li>
<li>
<p>If <code><em>formals</em></code> is an improper list of variables terminated by a variable, e.g., <code>(x y . z)</code>, each variable but the last is bound to the corresponding actual parameter. The last variable is bound to a list of the remaining actual parameters. An exception with condition type <code>&amp;assertion</code> is raised if too few actual parameters are supplied.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the body is evaluated, the expressions in the body are evaluated in sequence, and the procedure returns the values of the last expression.</p>
</div>
<div class="paragraph">
<p>Procedures do not have a printed representation in the usual sense. Scheme systems print procedures in different ways; this book uses the notation <code>#&lt;procedure&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (x) (+ x 3)) ⇒ #&lt;procedure&gt;
((lambda (x) (+ x 3)) 7) ⇒ 10
((lambda (x y) (* x (+ x y))) 7 13) ⇒ 140
((lambda (f x) (f x x)) + 11) ⇒ 22
((lambda () (+ 3 4))) ⇒ 7

((lambda (x . y) (list x y))
 28 37) ⇒ (28 (37))
((lambda (x . y) (list x y))
 28 37 47 28) ⇒ (28 (37 47 28))
((lambda (x y . z) (list x y z))
 1 2 3 4) ⇒ (1 2 (3 4))
((lambda x x) 7 13) ⇒ (7 13)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_4.3.">Section 4.3. Case-Lambda</h3>
<div class="paragraph">
<p>A Scheme <code>lambda</code> expression always produces a procedure with a fixed number of arguments or with an indefinite number of arguments greater than or equal to a certain number. In particular,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (<em>var<sub>1</sub></em> ... <em>var<sub>n</sub></em>) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>accepts exactly <code><em>n</em></code> arguments,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda <em>r</em> <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>accepts zero or more arguments, and</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (<em>var<sub>1</sub></em> ... <em>var<sub>n</sub></em> . <em>r</em>) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>accepts <code><em>n</em></code> or more arguments.</p>
</div>
<div class="paragraph">
<p><code>lambda</code> cannot directly produce, however, a procedure that accepts, say, either two or three arguments. In particular, procedures that accept optional arguments are not supported directly by <code>lambda</code>. The latter form of <code>lambda</code> shown above can be used, in conjunction with length checks and compositions of <code>car</code> and <code>cdr</code>, to implement procedures with optional arguments, though at the cost of clarity and efficiency.</p>
</div>
<div class="paragraph">
<p>The <code>case-lambda</code> syntactic form directly supports procedures with optional arguments as well as procedures with fixed or indefinite numbers of arguments. <code>case-lambda</code> is based on the <code>lambda*</code> syntactic form introduced in the article "A New Approach to Procedures with Variable Arity" <a href="#ref11">[11]</a>.</p>
</div>
<div id="binding:s13" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(case-lambda <em>clause</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a procedure</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs control)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>case-lambda</code> expression consists of a set of clauses, each resembling a <code>lambda</code> expression. Each <code><em>clause</em></code> has the form below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">[<em>formals</em> <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>The formal parameters of a clause are defined by <code><em>formals</em></code> in the same manner as for a <code>lambda</code> expression. The number of arguments accepted by the procedure value of a <code>case-lambda</code> expression is determined by the numbers of arguments accepted by the individual clauses.</p>
</div>
<div class="paragraph">
<p>When a procedure created with <code>case-lambda</code> is invoked, the clauses are considered in order. The first clause that accepts the given number of actual parameters is selected, the formal parameters defined by its <code><em>formals</em></code> are bound to the corresponding actual parameters, and the body is evaluated as described for <code>lambda</code> above. If <code><em>formals</em></code> in a clause is a proper list of identifiers, then the clause accepts exactly as many actual parameters as there are formal parameters (identifiers) in <code><em>formals</em></code>. As with a <code>lambda</code> <code><em>formals</em></code>, a <code>case-lambda</code> clause <code><em>formals</em></code> may be a single identifier, in which case the clause accepts any number of arguments, or an improper list of identifiers terminated by an identifier, in which case the clause accepts any number of arguments greater than or equal to the number of formal parameters excluding the terminating identifier. If no clause accepts the number of actual parameters supplied, an exception with condition type <code>&amp;assertion</code> is raised.</p>
</div>
<div class="paragraph">
<p>The following definition for <code>make-list</code> uses <code>case-lambda</code> to support an optional fill parameter.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define make-list
  (case-lambda
    [(n) (make-list n #f)]
    [(n x)
     (do ([n n (- n 1)] [ls '() (cons x ls)])
         ((zero? n) ls))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>substring</code> procedure may be extended with <code>case-lambda</code> to accept either no <code><em>end</em></code> index, in which case it defaults to the end of the string, or no <code><em>start</em></code> and <code><em>end</em></code> indices, in which case <code>substring</code> is equivalent to <code>string-copy</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define substring1
  (case-lambda
    [(s) (substring1 s 0 (string-length s))]
    [(s start) (substring1 s start (string-length s))]
    [(s start end) (substring s start end)]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to default the <code><em>start</em></code> index rather than the <code><em>end</em></code> index when only one index is supplied:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define substring2
  (case-lambda
    [(s) (substring2 s 0 (string-length s))]
    [(s end) (substring2 s 0 end)]
    [(s start end) (substring s start end)]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is even possible to require that both or neither of the <code><em>start</em></code> and <code><em>end</em></code> indices be supplied, simply by leaving out the middle clause:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define substring3
  (case-lambda
    [(s) (substring3 s 0 (string-length s))]
    [(s start end) (substring s start end)]))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_4.4.">Section 4.4. Local Binding</h3>
<div id="binding:s16" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(let ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values of the final body expression</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>let</code> establishes local variable bindings. Each variable <code><em>var</em></code> is bound to the value of the corresponding expression <code><em>expr</em></code>. The body of the <code>let</code>, in which the variables are bound, is the sequence of subforms <code><em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...</code> and is processed and evaluated like a <code>lambda</code> body.</p>
</div>
<div class="paragraph">
<p>The forms <code>let</code>, <code>let*</code>, <code>letrec</code>, and <code>letrec*</code> (the others are described after <code>let</code>) are similar but serve slightly different purposes. With <code>let</code>, in contrast with <code>let*</code>, <code>letrec</code>, and <code>letrec*</code>, the expressions <code><em>expr</em> ...</code> are all outside the scope of the variables <code><em>var</em> ...</code>. Also, in contrast with <code>let*</code> and <code>letrec*</code>, no ordering is implied for the evaluation of the expressions <code><em>expr</em> ...</code>. They may be evaluated from left to right, from right to left, or in any other order at the discretion of the implementation. Use <code>let</code> whenever the values are independent of the variables and the order of evaluation is unimportant.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x (* 3.0 3.0)] [y (* 4.0 4.0)])
  (sqrt (+ x y))) ⇒ 5.0

(let ([x 'a] [y '(b c)])
  (cons x y)) ⇒ (a b c)

(let ([x 0] [y 1])
  (let ([x y] [y x])
    (list x y))) ⇒ (1 0)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following definition of <code>let</code> shows the typical derivation of <code>let</code> from <code>lambda</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax let
  (syntax-rules ()
    [(_ ((x e) ...) b1 b2 ...)
     ((lambda (x ...) b1 b2 ...) e ...)]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another form of <code>let</code>, <em>named</em> <code>let</code>, is described in <a href="#section_5.4.">Section 5.4</a>, and a definition of the full <code>let</code> can be found on <a href="#defn:let">page 312</a>.</p>
</div>
<div id="binding:s18" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(let* ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values of the final body expression</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>let*</code> is similar to <code>let</code> except that the expressions <code><em>expr</em> ...</code> are evaluated in sequence from left to right, and each of these expressions is within the scope of the variables to the left. Use <code>let*</code> when there is a linear dependency among the values or when the order of evaluation is important.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let* ([x (* 5.0 5.0)]
       [y (- x (* 4.0 4.0))])
  (sqrt y)) ⇒ 3.0

(let ([x 0] [y 1])
  (let* ([x y] [y x])
    (list x y))) ⇒ (1 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any <code>let*</code> expression may be converted to a set of nested <code>let</code> expressions. The following definition of <code>let*</code> demonstrates the typical transformation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax let*
  (syntax-rules ()
    [(_ () e1 e2 ...)
     (let () e1 e2 ...)]
    [(_ ((x1 v1) (x2 v2) ...) e1 e2 ...)
     (let ((x1 v1))
       (let* ((x2 v2) ...) e1 e2 ...))]))</code></pre>
</div>
</div>
<div id="binding:s20" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(letrec ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values of the final body expression</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>letrec</code> is similar to <code>let</code> and <code>let*</code>, except that all of the expressions <code><em>expr</em> ...</code> are within the scope of all of the variables <code><em>var</em> ...</code>. <code>letrec</code> allows the definition of mutually recursive procedures.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec ([sum (lambda (x)
                (if (zero? x)
                    0
                    (+ x (sum (- x 1)))))])
  (sum 5)) ⇒ 15</code></pre>
</div>
</div>
<div class="paragraph">
<p>The order of evaluation of the expressions <code><em>expr</em> ...</code> is unspecified, so a program must not evaluate a reference to any of the variables bound by the <code>letrec</code> expression before all of the values have been computed. (Occurrence of a variable within a <code>lambda</code> expression does not count as a reference, unless the resulting procedure is applied before all of the values have been computed.) If this restriction is violated, an exception with condition type <code>&amp;assertion</code> is raised.</p>
</div>
<div class="paragraph">
<p>An <code><em>expr</em></code> should not return more than once. That is, it should not return both normally and via the invocation of a continuation obtained during its evaluation, and it should not return twice via two invocations of such a continuation. Implementations are not required to detect a violation of this restriction, but if they do, an exception with condition type <code>&amp;assertion</code> is raised.</p>
</div>
<div class="paragraph">
<p>Choose <code>letrec</code> over <code>let</code> or <code>let*</code> when there is a circular dependency among the variables and their values and when the order of evaluation is unimportant. Choose <code>letrec*</code> over <code>letrec</code> when there is a circular dependency and the bindings need to be evaluated from left to right.</p>
</div>
<div class="paragraph">
<p>A <code>letrec</code> expression of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>may be expressed in terms of <code>let</code> and <code>set!</code> as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ((<em>var</em> #f) ...)
  (let ((<em>temp</em> <em>expr</em>) ...)
    (set! <em>var</em> <em>temp</em>) ...
    (let () <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code><em>temp</em> ...</code> are fresh variables, i.e., ones that do not already appear in the <code>letrec</code> expression, one for each <code>(<em>var</em> <em>expr</em>)</code> pair. The outer <code>let</code> expression establishes the variable bindings. The initial value given each variable is unimportant, so any value suffices in place of <code>#f</code>. The bindings are established first so that <code><em>expr</em> ...</code> may contain occurrences of the variables, i.e., so that the expressions are computed within the scope of the variables. The middle <code>let</code> evaluates the values and binds them to the temporary variables, and the <code>set!</code> expressions assign each variable to the corresponding value. The inner <code>let</code> is present in case the body contains internal definitions.</p>
</div>
<div class="paragraph">
<p>A definition of <code>letrec</code> that uses this transformation is shown on <a href="#defn:letrec">page 310</a>.</p>
</div>
<div class="paragraph">
<p>This transformation does not enforce the restriction that the <code><em>expr</em></code> expressions must not evaluate any references of or assignments to the variables. More elaborate transformations that enforce this restriction and actually produce more efficient code are possible <a href="#ref31">[31]</a>.</p>
</div>
<div id="desc:letrec*" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(letrec* ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code> <a id="binding:s22"></a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values of the final body expression</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>letrec*</code> is similar to <code>letrec</code>, except that <code>letrec*</code> evaluates <code><em>expr</em> ...</code> in sequence from left to right. While programs must still not evaluate a reference to any <code><em>var</em></code> before the corresponding <code><em>expr</em></code> has been evaluated, references to <code><em>var</em></code> may be evaluated any time thereafter, including during the evaluation of the <code><em>expr</em></code> of any subsequent binding.</p>
</div>
<div class="paragraph">
<p>A <code>letrec*</code> expression of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec* ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>may be expressed in terms of <code>let</code> and <code>set!</code> as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ((<em>var</em> #f) ...)
  (set! <em>var</em> <em>expr</em>) ...
  (let () <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The outer <code>let</code> expression creates the bindings, each assignment evaluates an expression and immediately sets the corresponding variable to its value, in sequence, and the inner let evaluates the body. <code>let</code> is used in the latter case rather than <code>begin</code> since the body may include internal definitions as well as expressions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(letrec* ([sum (lambda (x)
                 (if (zero? x)
                     0
                     (+ x (sum (- x 1)))))]
          [f (lambda () (cons n n-sum))]
          [n 15]
          [n-sum (sum n)])
  (f)) ⇒ (15 . 120)

(letrec* ([f (lambda () (lambda () g))]
          [g (f)])
  (eq? (g) g)) ⇒ #t

(letrec* ([g (f)]
          [f (lambda () (lambda () g))])
  (eq? (g) g)) ⇒ <em>exception: attempt to reference undefined variable f</em></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_4.5.">Section 4.5. Multiple Values</h3>
<div id="desc:let-values" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(let-values ((<em>formals</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code> <a id="binding:s23"></a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(let*-values ((<em>formals</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values of the final body expression</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>let-values</code> is a convenient way to receive multiple values and bind them to variables. It is structured like <code>let</code> but permits an arbitrary formals list (like <code>lambda</code>) on each left-hand side. <code>let*-values</code> is similar but performs the bindings in left-to-right order, as with <code>let*</code>. An exception with condition type <code>&amp;assertion</code> is raised if the number of values returned by an <code><em>expr</em></code> is not appropriate for the corresponding <code><em>formals</em></code>, as described in the entry for <code>lambda</code> above. A definition of <code>let-values</code> is given on <a href="#fullletvalues">page 310</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let-values ([(a b) (values 1 2)] [c (values 1 2 3)])
  (list a b c)) ⇒ (1 2 (1 2 3))

(let*-values ([(a b) (values 1 2)] [(a b) (values b a)])
  (list a b)) ⇒ (2 1)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_4.6.">Section 4.6. Variable Definitions</h3>
<div id="binding:s24" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(define <em>var</em> <em>expr</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(define var)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(define (<em>var<sub>0</sub></em> <em>var<sub>1</sub></em> ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(define (<em>var<sub>0</sub></em> . <em>var<sub>r</sub></em>) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(define (<em>var<sub>0</sub></em> <em>var<sub>1</sub></em> <em>var<sub>2</sub></em> ... . <em>var<sub>r</sub></em>) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In the first form, <code>define</code> creates a new binding of <code><em>var</em></code> to the value of <code><em>expr</em></code>. The <code><em>expr</em></code> should not return more than once. That is, it should not return both normally and via the invocation of a continuation obtained during its evaluation, and it should not return twice via two invocations of such a continuation. Implementations are not required to detect a violation of this restriction, but if they do, an exception with condition type <code>&amp;assertion</code> is raised.</p>
</div>
<div class="paragraph">
<p>The second form is equivalent to <code>(define <em>var</em> <em>unspecified</em>)</code>, where <code><em>unspecified</em></code> is some unspecified value. The remaining are shorthand forms for binding variables to procedures; they are identical to the following definition in terms of <code>lambda</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define <em>var</em>
  (lambda <em>formals</em>
    <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code><em>formals</em></code> is <code>(<em>var<sub>1</sub></em> ...)</code>, <code><em>var<sub>r</sub></em></code>, or <code>(<em>var<sub>1</sub></em> <em>var<sub>2</sub></em> ... . <em>var<sub>r</sub></em>)</code> for the third, fourth, and fifth <code>define</code> formats.</p>
</div>
<div class="paragraph">
<p>Definitions may appear at the front of a <code>library</code> body, anywhere among the forms of a top-level-program body, and at the front of a <code>lambda</code> or <code>case-lambda</code> body or the body of any form derived from <code>lambda</code>, e.g., <code>let</code>, or <code>letrec*</code>. Any body that begins with a sequence of definitions is transformed during macro expansion into a <code>letrec*</code> expression as described on <a href="#body-expansion">page 292</a>.</p>
</div>
<div class="paragraph">
<p>Syntax definitions may appear along with variable definitions wherever variable definitions may appear; see <a href="#chp_syntactic_extension">Chapter 8</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define x 3)
x ⇒ 3

(define f
  (lambda (x y)
    (* (+ x y) 2)))
(f 5 4) ⇒ 18

(define (sum-of-squares x y)
  (+ (* x x) (* y y)))
(sum-of-squares 3 4) ⇒ 25

(define f
  (lambda (x)
    (+ x 1)))
(let ([x 2])
  (define f
    (lambda (y)
      (+ y x)))
  (f 3)) ⇒ 5
(f 3) ⇒ 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>A set of definitions may be grouped by enclosing them in a <code>begin</code> form. Definitions grouped in this manner may appear wherever ordinary variable and syntax definitions may appear. They are treated as if written separately, i.e., without the enclosing <code>begin</code> form. <a id="multi-define-syntax"></a> This feature allows syntactic extensions to expand into groups of definitions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax multi-define-syntax
  (syntax-rules ()
    [(_ (var expr) ...)
     (begin
       (define-syntax var expr)
       ...)]))
(let ()
  (define plus
    (lambda (x y)
        (if (zero? x)
            y
            (plus (sub1 x) (add1 y)))))
  (multi-define-syntax
    (add1 (syntax-rules () [(_ e) (+ e 1)]))
    (sub1 (syntax-rules () [(_ e) (- e 1)])))
  (plus 7 8)) ⇒ 15</code></pre>
</div>
</div>
<div id="binding:s27" class="paragraph">
<p>Many implementations support an interactive "top level" in which variable and other definitions may be entered interactively or loaded from files. The behavior of these top-level definitions is outside the scope of the Revised<sup>6</sup> Report, but as long as top-level variables are defined before any references or assignments to them are evaluated, the behavior is consistent across most implementations. So, for example, the reference to <code>g</code> in the top-level definition of <code>f</code> below is okay if <code><em>g</em></code> is not already defined, and <code>g</code> is assumed to name a variable to be defined at some later point.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define f
  (lambda (x)
    (g x)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If this is then followed by a definition of <code>g</code> before <code>f</code> is evaluated, the assumption that <code>g</code> would be defined as a variable is proven correct, and a call to <code>f</code> works as expected.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define g
  (lambda (x)
    (+ x x)))
(f 3) ⇒ 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>If <code>g</code> were defined instead as the keyword for a syntactic extension, the assumption that <code>g</code> would be bound as a variable is proven false, and if <code>f</code> is not redefined before it is invoked, the implementation is likely to raise an exception.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_4.7.">Section 4.7. Assignment</h3>
<div id="binding:s28" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(set! <em>var</em> <em>expr</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="binding:s29" class="paragraph">
<p><code>set!</code> does not establish a new binding for <code><em>var</em></code> but rather alters the value of an existing binding. It first evaluates <code><em>expr</em></code>, then assigns <code><em>var</em></code> to the value of <code><em>expr</em></code>. Any subsequent reference to <code><em>var</em></code> within the scope of the altered binding evaluates to the new value.</p>
</div>
<div class="paragraph">
<p>Assignments are not employed as frequently in Scheme as in most other languages, but they are useful for implementing state changes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define flip-flop
  (let ([state #f])
    (lambda ()
      (set! state (not state))
      state)))

(flip-flop) ⇒ #t
(flip-flop) ⇒ #f
(flip-flop) ⇒ #t</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assignments are also useful for caching values. The example below uses a technique called <em>memoization</em>, in which a procedure records the values associated with old input values so it need not recompute them, to implement a fast version of the otherwise exponential doubly recursive definition of the Fibonacci function (see <a href="#fibonacci">page 69</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define memoize
  (lambda (proc)
    (let ([cache '()])
      (lambda (x)
        (cond
          [(assq x cache) => cdr]
          [else
           (let ([ans (proc x)])
             (set! cache (cons (cons x ans) cache))
             ans)])))))

(define fibonacci
  (memoize
    (lambda (n)
      (if (< n 2)
          1
          (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))))

(fibonacci 100) ⇒ 573147844013817084101</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chp_control_operations">Chapter 5. Control Operations</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/ch5.png" alt="ch5">
</div>
</div>
<div class="paragraph">
<p>This chapter introduces the syntactic forms and procedures that serve as control structures for Scheme programs, The first section covers the most basic control structure, procedure application, and the remaining sections cover sequencing, conditional evaluation, recursion, mapping, continuations, delayed evaluation, multiple values, and evaluation of programs constructed at run time.</p>
</div>
<div class="sect2">
<h3 id="section_5.1.">Section 5.1. Procedure Application</h3>
<div id="control:s1" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(<em>expr<sub>0</sub></em> <em>expr<sub>1</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>values of applying the value of <code><em>expr<sub>0</sub></em></code> to the values of <code><em>expr<sub>1</sub></em> ...</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Procedure application is the most basic Scheme control structure. Any structured form without a syntax keyword in the first position is a procedure application. The expressions <code><em>expr<sub>0</sub></em></code> and <code><em>expr<sub>1</sub></em> ...</code> are evaluated; each should evaluate to a single value. After each of these expressions has been evaluated, the value of <code><em>expr<sub>0</sub></em></code> is applied to the values of <code><em>expr<sub>1</sub></em> ...</code>. If <code><em>expr<sub>0</sub></em></code> does not evaluate to a procedure, or if the procedure does not accept the number of arguments provided, an exception with condition type <code>&amp;assertion</code> is raised.</p>
</div>
<div id="control:s2" class="paragraph">
<p>The order in which the procedure and argument expressions are evaluated is unspecified. It may be left to right, right to left, or any other order. The evaluation is guaranteed to be sequential, however: whatever order is chosen, each expression is fully evaluated before evaluation of the next is started.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(+ 3 4) ⇒ 7

((if (odd? 3) + -) 6 2) ⇒ 8

((lambda (x) x) 5) ⇒ 5

(let ([f (lambda (x) (+ x x))])
  (f 8)) ⇒ 16</code></pre>
</div>
</div>
<div id="desc:apply" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(apply <em>procedure</em> <em>obj</em> ... <em>list</em>)</code> <a id="control:s3"></a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values of applying <code><em>procedure</em></code> to <code><em>obj</em> ...</code> and the elements of <code><em>list</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>apply</code> invokes <code><em>procedure</em></code>, passing the first <code><em>obj</em></code> as the first argument, the second <code><em>obj</em></code> as the second argument, and so on for each object in <code><em>obj</em> ...</code>, and passing the elements of <code><em>list</em></code> in order as the remaining arguments. Thus, <code><em>procedure</em></code> is called with as many arguments as there are <code><em>objs</em></code> plus elements of <code><em>list</em></code>.</p>
</div>
<div class="paragraph">
<p><code>apply</code> is useful when some or all of the arguments to be passed to a procedure are in a list, since it frees the programmer from explicitly destructuring the list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(apply + '(4 5)) ⇒ 9

(apply min '(6 8 3 2 5)) ⇒ 2

(apply min  5 1 3 '(6 8 3 2 5)) ⇒ 1

(apply vector 'a 'b '(c d e)) ⇒ #(a b c d e)

(define first
  (lambda (ls)
    (apply (lambda (x . y) x) ls)))
(define rest
  (lambda (ls)
    (apply (lambda (x . y) y) ls)))
(first '(a b c d)) ⇒ a
(rest '(a b c d)) ⇒ (b c d)

(apply append
  '(1 2 3)
  '((a b) (c d e) (f))) ⇒ (1 2 3 a b c d e f)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_5.2.">Section 5.2. Sequencing</h3>
<div id="control:s4" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(begin <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values of the last subexpression</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The expressions <code><em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...</code> are evaluated in sequence from left to right. <code>begin</code> is used to sequence assignments, input/output, or other operations that cause side effects.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define x 3)
(begin
  (set! x (+ x 1))
  (+ x x)) ⇒ 8</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>begin</code> form may contain zero or more definitions in place of the expressions <code><em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...</code>, in which case it is considered to be a definition and may appear only where definitions are valid.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ()
  (begin (define x 3) (define y 4))
  (+ x y)) ⇒ 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>This form of <code>begin</code> is primarily used by syntactic extensions that must expand into multiple definitions. (See <a href="#multi-define-syntax">page 101</a>.)</p>
</div>
<div class="paragraph">
<p>The bodies of many syntactic forms, including <code>lambda</code>, <code>case-lambda</code>, <code>let</code>, <code>let*</code>, <code>letrec</code>, and <code>letrec*</code>, as well as the result clauses of <code>cond</code>, <code>case</code>, and <code>do</code>, are treated as if they were inside an implicit <code>begin</code>; i.e., the expressions making up the body or result clause are executed in sequence, with the values of the last expression being returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define swap-pair!
  (lambda (x)
    (let ([temp (car x)])
      (set-car! x (cdr x))
      (set-cdr! x temp)
      x)))
(swap-pair! (cons 'a 'b)) ⇒ (b . a)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_5.3.">Section 5.3. Conditionals</h3>
<div id="control:s8" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(if <em>test</em> <em>consequent</em> <em>alternative</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(if <em>test</em> <em>consequent</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values of <code><em>consequent</em></code> or <code><em>alternative</em></code> depending on the value of <code><em>test</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="control:s9" class="paragraph">
<p>The <code><em>test</em></code>, <code><em>consequent</em></code>, and <code><em>alternative</em></code> subforms must be expressions. If <code><em>test</em></code> evaluates to a true value (anything other than <code>#f</code>), <code>consequent</code> is evaluated and its values are returned. Otherwise, <code>alternative</code> is evaluated and its values are returned. With the second, "one-armed," form, which has no <code><em>alternative</em></code>, the result is unspecified if <code><em>test</em></code> evaluates to false.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([ls '(a b c)])
  (if (null? ls)
      '()
      (cdr ls))) ⇒ (b c)

(let ([ls '()])
  (if (null? ls)
      '()
      (cdr ls))) ⇒ ()

(let ([abs
       (lambda (x)
         (if (< x 0)
             (- 0 x)
             x))])
  (abs -4)) ⇒ 4

(let ([x -4])
  (if (< x 0)
      (list 'minus (- 0 x))
      (list 'plus 4))) ⇒ (minus 4)</code></pre>
</div>
</div>
<div id="control:s10" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(not <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is false, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>not</code> is equivalent to <code>(lambda (x) (if x #f #t))</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(not #f) ⇒ #t
(not #t) ⇒ #f
(not '()) ⇒ #f
(not (< 4 5)) ⇒ #f</code></pre>
</div>
</div>
<div id="control:s11" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(and <em>expr</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If no subexpressions are present, the <code>and</code> form evaluates to <code>#t</code>. Otherwise, <code>and</code> evaluates each subexpression in sequence from left to right until only one subexpression remains or a subexpression returns <code>#f</code>. If one subexpression remains, it is evaluated and its values are returned. If a subexpression returns <code>#f</code>, <code>and</code> returns <code>#f</code> without evaluating the remaining subexpressions. A syntax definition of <code>and</code> appears on <a href="#defn:and">page 62</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 3])
  (and (> x 2) (< x 4))) ⇒ #t

(let ([x 5])
  (and (> x 2) (< x 4))) ⇒ #f

(and #f '(a b) '(c d)) ⇒ #f
(and '(a b) '(c d) '(e f)) ⇒ (e f)</code></pre>
</div>
</div>
<div id="control:s12" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(or <em>expr</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If no subexpressions are present, the <code>or</code> form evaluates to <code>#f</code>. Otherwise, <code>or</code> evaluates each subexpression in sequence from left to right until only one subexpression remains or a subexpression returns a value other than <code>#f</code>. If one subexpression remains, it is evaluated and its values are returned. If a subexpression returns a value other than <code>#f</code>, <code>or</code> returns that value without evaluating the remaining subexpressions. A syntax definition of <code>or</code> appears on <a href="#defn:or">page 63</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 3])
  (or (< x 2) (> x 4))) ⇒ #f

(let ([x 5])
  (or (< x 2) (> x 4))) ⇒ #t

(or #f '(a b) '(c d)) ⇒ (a b)</code></pre>
</div>
</div>
<div id="control:s13" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(cond <em>clause<sub>1</sub></em> <em>clause<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each <code><em>clause</em></code> but the last must take one of the forms below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(<em>test</em>)
(<em>test</em> <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)
(<em>test</em> => <em>expr</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last clause may be in any of the above forms, or it may be an "<code>else</code> clause" of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(else <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each <code><em>test</em></code> is evaluated in order until one evaluates to a true value or until all of the tests have been evaluated. If the first clause whose <code><em>test</em></code> evaluates to a true value is in the first form given above, the value of <code><em>test</em></code> is returned.</p>
</div>
<div class="paragraph">
<p>If the first clause whose <code><em>test</em></code> evaluates to a true value is in the second form given above, the expressions <code><em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...</code> are evaluated in sequence and the values of the last expression are returned.</p>
</div>
<div class="paragraph">
<p>If the first clause whose <code><em>test</em></code> evaluates to a true value is in the third form given above, the expression <code><em>expr</em></code> is evaluated. The value should be a procedure of one argument, which is applied to the value of <code><em>test</em></code>. The values of this application are returned.</p>
</div>
<div class="paragraph">
<p>If none of the tests evaluates to a true value and an <code>else</code> clause is present, the expressions <code><em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...</code> of the <code>else</code> clause are evaluated in sequence and the values of the last expression are returned.</p>
</div>
<div class="paragraph">
<p>If none of the tests evaluates to a true value and no <code>else</code> clause is present, the value or values are unspecified.</p>
</div>
<div class="paragraph">
<p>See <a href="#defn:cond">page 305</a> for a syntax definition of <code>cond</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 0])
  (cond
    [(< x 0) (list 'minus (abs x))]
    [(> x 0) (list 'plus x)]
    [else (list 'zero x)])) ⇒ (zero 0)

(define select
  (lambda (x)
    (cond
      [(not (symbol? x))]
      [(assq x '((a . 1) (b . 2) (c . 3))) => cdr]
      [else 0])))

(select 3) ⇒ #t
(select 'b) ⇒ 2
(select 'e) ⇒ 0</code></pre>
</div>
</div>
<div id="control:s16" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>else</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>=&gt;</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs exceptions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These identifiers are auxiliary keywords for <code>cond</code>. Both also serve as auxiliary keywords for <code>guard</code>, and <code>else</code> also serves as an auxiliary keyword for <code>case</code>. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.</p>
</div>
<div id="control:s17" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(when <em>test-expr</em> <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(unless <em>test-expr</em> <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs control)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For <code>when</code>, if <code><em>test-expr</em></code> evaluates to a true value, the expressions <code><em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...</code> are evaluated in sequence, and the values of the last expression are returned. If <code><em>test-expr</em></code> evaluates to false, none of the other expressions are evaluated, and the value or values of <code>when</code> are unspecified.</p>
</div>
<div class="paragraph">
<p>For <code>unless</code>, if <code><em>test-expr</em></code> evaluates to false, the expressions <code><em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...</code> are evaluated in sequence, and the values of the last expression are returned. If <code><em>test-expr</em></code> evaluates to a true value, none of the other expressions are evaluated, and the value or values of <code>unless</code> are unspecified.</p>
</div>
<div class="paragraph">
<p>A <code>when</code> or <code>unless</code> expression is usually clearer than the corresponding "one-armed" <code>if</code> expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x -4] [sign 'plus])
  (when (< x 0)
    (set! x (- 0 x))
    (set! sign 'minus))
  (list sign x)) ⇒ (minus 4)

(define check-pair
  (lambda (x)
    (unless (pair? x)
      (syntax-violation 'check-pair "invalid argument" x))
    x))

(check-pair '(a b c)) ⇒ (a b c)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>when</code> may be defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax when
  (syntax-rules ()
    [(_ <em>e<sub>0</sub></em> <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...)
     (if <em>e<sub>0</sub></em> (begin <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>unless</code> may be defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax unless
  (syntax-rules ()
    [(_ <em>e<sub>0</sub></em> <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...)
     (if (not <em>e<sub>0</sub></em>) (begin <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>or in terms of <code>when</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax unless
  (syntax-rules ()
    [(_ <em>e<sub>0</sub></em> <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...)
     (when (not <em>e<sub>0</sub></em>) <em>e<sub>1</sub></em> <em>e<sub>2</sub></em> ...)]))</code></pre>
</div>
</div>
<div id="control:s18" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(case <em>expr<sub>0</sub></em> <em>clause<sub>1</sub></em> <em>clause<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each clause but the last must take the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">((<em>key</em> ...) <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where each <code><em>key</em></code> is a datum distinct from the other keys. The last clause may be in the above form or it may be an <code>else</code> clause of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(else <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>expr<sub>0</sub></em> is evaluated and the result is compared (using <code>eqv?</code>) against the keys of each clause in order. If a clause containing a matching key is found, the expressions <code><em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...</code> are evaluated in sequence and the values of the last expression are returned.</p>
</div>
<div class="paragraph">
<p>If none of the clauses contains a matching key and an <code>else</code> clause is present, the expressions <code><em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...</code> of the <code>else</code> clause are evaluated in sequence and the values of the last expression are returned.</p>
</div>
<div class="paragraph">
<p>If none of the clauses contains a matching key and no <code>else</code> clause is present, the value or values are unspecified.</p>
</div>
<div class="paragraph">
<p>See <a href="#defn:case">page 306</a> for a syntax definition of <code>case</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 4] [y 5])
  (case (+ x y)
    [(1 3 5 7 9) 'odd]
    [(0 2 4 6 8) 'even]
    [else 'out-of-range])) ⇒ odd</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_5.4.">Section 5.4. Recursion and Iteration</h3>
<div id="control:s20" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(let <em>name</em> ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>values of the final body expression</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This form of <code>let</code>, called <code><em>named</em></code> <code>let</code>, is a general-purpose iteration and recursion construct. It is similar to the more common form of <code>let</code> (see <a href="#section_4.4.">Section 4.4</a>) in the binding of the variables <code><em>var</em> ...</code> to the values of <code><em>expr</em> ...</code> within the body <code><em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...</code>, which is processed and evaluated like a <code>lambda</code> body. In addition, the variable <code><em>name</em></code> is bound within the body to a procedure that may be called to recur or iterate; the arguments to the procedure become the new values of the variables <code><em>var</em> ...</code>.</p>
</div>
<div class="paragraph">
<p>A named <code>let</code> expression of the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let <em>name</em> ((<em>var</em> <em>expr</em>) ...)
  <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be rewritten with <code>letrec</code> as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">((letrec ((<em>name</em> (lambda (<em>var</em> ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)))
   <em>name</em>)
 <em>expr</em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A syntax definition of <code>let</code> that implements this transformation and handles unnamed <code>let</code> as well can be found on <a href="#defn:let">page 312</a>.</p>
</div>
<div class="paragraph">
<p>The procedure <code>divisors</code> defined below uses named <code>let</code> to compute the nontrivial divisors of a nonnegative integer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define divisors
  (lambda (n)
    (let f ([i 2])
      (cond
        [(>= i n) '()]
        [(integer? (/ n i)) (cons i (f (+ i 1)))]
        [else (f (+ i 1))]))))

(divisors 5) ⇒ ()
(divisors 32) ⇒ (2 4 8 16)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The version above is non-tail-recursive when a divisor is found and tail-recursive when a divisor is not found. The version below is fully tail-recursive. It builds up the list in reverse order, but this is easy to remedy, if desired, by reversing the list on exit.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define divisors
  (lambda (n)
    (let f ([i 2] [ls '()])
      (cond
        [(>= i n) ls]
        [(integer? (/ n i)) (f (+ i 1) (cons i ls))]
        [else (f (+ i 1) ls)]))))</code></pre>
</div>
</div>
<div id="control:s25" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(do ((<em>var</em> <em>init</em> <em>update</em>) ...) (<em>test</em> <em>result</em> ...) <em>expr</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values of the last <code><em>result</em></code> expression</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs control)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>do</code> allows a common restricted form of iteration to be expressed succinctly. The variables <code><em>var</em> ...</code> are bound initially to the values of <code><em>init</em> ...</code> and are rebound on each subsequent iteration to the values of <code><em>update</em> ...</code>. The expressions <code><em>test</em></code>, <code><em>update</em> ...</code>, <code><em>expr</em> ...</code>, and <code><em>result</em> ...</code> are all within the scope of the bindings established for <code><em>var</em> ...</code>.</p>
</div>
<div class="paragraph">
<p>On each step, the test expression <code><em>test</em></code> is evaluated. If the value of <code><em>test</em></code> is true, iteration ceases, the expressions <code><em>result</em> ...</code> are evaluated in sequence, and the values of the last expression are returned. If no result expressions are present, the value or values of the <code>do</code> expression are unspecified.</p>
</div>
<div class="paragraph">
<p>If the value of <code><em>test</em></code> is false, the expressions <code><em>expr</em> ...</code> are evaluated in sequence, the expressions <code><em>update</em> ...</code> are evaluated, new bindings for <code><em>var</em> ...</code> to the values of <code><em>update</em> ...</code> are created, and iteration continues.</p>
</div>
<div class="paragraph">
<p>The expressions <code><em>expr</em> ...</code> are evaluated only for effect and are often omitted entirely. Any <code><em>update</em></code> expression may be omitted, in which case the effect is the same as if the <code><em>update</em></code> were simply the corresponding <code><em>var</em></code>.</p>
</div>
<div class="paragraph">
<p>Although looping constructs in most languages require that the loop iterands be updated via assignment, <code>do</code> requires the loop iterands <code><em>var</em> ...</code> to be updated via rebinding. In fact, no side effects are involved in the evaluation of a <code>do</code> expression unless they are performed explicitly by its subexpressions.</p>
</div>
<div class="paragraph">
<p>See <a href="#defn:do">page 313</a> for a syntax definition of <code>do</code>.</p>
</div>
<div class="paragraph">
<p>The definitions of <code>factorial</code> and <code>fibonacci</code> below are straightforward translations of the tail-recursive named-<code>let</code> versions given in <a href="#section_3.2.">Section 3.2</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define factorial
  (lambda (n)
    (do ([i n (- i 1)] [a 1 (* a i)])
        ((zero? i) a))))

(factorial 10) ⇒ 3628800

(define fibonacci
  (lambda (n)
    (if (= n 0)
        0
        (do ([i n (- i 1)] [a1 1 (+ a1 a2)] [a2 0 a1])
            ((= i 1) a1)))))

(fibonacci 6) ⇒ 8</code></pre>
</div>
</div>
<div class="paragraph">
<p>The definition of <code>divisors</code> below is similar to the tail-recursive definition of <code>divisors</code> given with the description of named <code>let</code> above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define divisors
  (lambda (n)
    (do ([i 2 (+ i 1)]
         [ls '()
             (if (integer? (/ n i))
                 (cons i ls)
                 ls)])
        ((>= i n) ls))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The definition of <code>scale-vector!</code> below, which scales each element of a vector <em>v</em> by a constant <em>k</em>, demonstrates a nonempty <code>do</code> body.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define scale-vector!
  (lambda (v k)
    (let ([n (vector-length v)])
      (do ([i 0 (+ i 1)])
          ((= i n))
        (vector-set! v i (* (vector-ref v i) k))))))

(define vec (vector 1 2 3 4 5))
(scale-vector! vec 2)
vec ⇒ #(2 4 6 8 10)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_5.5.">Section 5.5. Mapping and Folding</h3>
<div class="paragraph">
<p>When a program must recur or iterate over the elements of a list, a mapping or folding operator is often more convenient. These operators abstract away from null checks and explicit recursion by applying a procedure to the elements of the list one by one. A few mapping operators are also available for vectors and strings.</p>
</div>
<div id="control:s30" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(map <em>procedure</em> <em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>list of results</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>map</code> applies <code><em>procedure</em></code> to corresponding elements of the lists <code><em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...</code> and returns a list of the resulting values. The lists <code><em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...</code> must be of the same length. <code><em>procedure</em></code> should accept as many arguments as there are lists, should return a single value, and should not mutate the <code><em>list</em></code> arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(map abs '(1 -2 3 -4 5 -6)) ⇒ (1 2 3 4 5 6)

(map (lambda (x y) (* x y))
     '(1 2 3 4)
     '(8 7 6 5)) ⇒ (8 14 18 20)</code></pre>
</div>
</div>
<div class="paragraph">
<p>While the order in which the applications themselves occur is not specified, the order of the values in the output list is the same as that of the corresponding values in the input lists.</p>
</div>
<div class="paragraph">
<p><code>map</code> might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define map
  (lambda (f ls . more)
    (if (null? more)
        (let map1 ([ls ls])
          (if (null? ls)
              '()
              (cons (f (car ls))
                    (map1 (cdr ls)))))
        (let map-more ([ls ls] [more more])
          (if (null? ls)
              '()
              (cons
                (apply f (car ls) (map car more))
                (map-more (cdr ls) (map cdr more))))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>No error checking is done by this version of <code>map</code>; <code>f</code> is assumed to be a procedure and the other arguments are assumed to be proper lists of the same length. An interesting feature of this definition is that <code>map</code> uses itself to pull out the cars and cdrs of the list of input lists; this works because of the special treatment of the single-list case.</p>
</div>
<div id="desc:for-each" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(for-each <em>procedure</em> <em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...)</code> <a id="control:s33"></a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>for-each</code> is similar to <code>map</code> except that <code>for-each</code> does not create and return a list of the resulting values, and <code>for-each</code> guarantees to perform the applications in sequence over the elements from left to right. <code><em>procedure</em></code> should accept as many arguments as there are lists and should not mutate the <code><em>list</em></code> arguments. <code>for-each</code> may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define for-each
  (lambda (f ls . more)
    (do ([ls ls (cdr ls)] [more more (map cdr more)])
        ((null? ls))
      (apply f (car ls) (map car more)))))

(let ([same-count 0])
  (for-each
    (lambda (x y)
      (when (= x y)
        (set! same-count (+ same-count 1))))
    '(1 2 3 4 5 6)
    '(2 3 3 4 7 6))
  same-count) ⇒ 3</code></pre>
</div>
</div>
<div id="control:s36" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(exists <em>procedure</em> <em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The lists <code><em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...</code> must be of the same length. <code><em>procedure</em></code> should accept as many arguments as there are lists and should not mutate the <code><em>list</em></code> arguments. If the lists are empty, <code>exists</code> returns <code>#f</code>. Otherwise, <code>exists</code> applies <code><em>procedure</em></code> to corresponding elements of the lists <code><em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...</code> in sequence until either the lists each have only one element or <code><em>procedure</em></code> returns a true value <code><em>t</em></code>. In the former case, <code>exists</code> tail-calls <code><em>procedure</em></code>, applying it to the remaining element of each list. In the latter case, <code>exists</code> returns <code><em>t</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(exists symbol? '(1.0 #\a "hi" '())) ⇒ #f

(exists member
        '(a b c)
        '((c b) (b a) (a c))) ⇒ (b a)

(exists (lambda (x y z) (= (+ x y) z))
        '(1 2 3 4)
        '(1.2 2.3 3.4 4.5)
        '(2.3 4.4 6.4 8.6)) ⇒ #t</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>exists</code> may be defined (somewhat inefficiently and without error checks) as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define exists
  (lambda (f ls . more)
    (and (not (null? ls))
      (let exists ([x (car ls)] [ls (cdr ls)] [more more])
        (if (null? ls)
            (apply f x (map car more))
            (or (apply f x (map car more))
                (exists (car ls) (cdr ls) (map cdr more))))))))</code></pre>
</div>
</div>
<div id="control:s37" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(for-all <em>procedure</em> <em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The lists <code><em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...</code> must be of the same length. <code><em>procedure</em></code> should accept as many arguments as there are lists and should not mutate the <code><em>list</em></code> arguments. If the lists are empty, <code>for-all</code> returns <code>#t</code>. Otherwise, <code>for-all</code> applies <code><em>procedure</em></code> to corresponding elements of the lists <code><em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...</code> in sequence until either the lists each have only one element left or <code><em>procedure</em></code> returns <code>#f</code>. In the former case, <code>for-all</code> tail-calls <code><em>procedure</em></code>, applying it to the remaining element of each list. In the latter case, <code>for-all</code> returns <code>#f</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(for-all symbol? '(a b c d)) ⇒ #t

(for-all =
         '(1 2 3 4)
         '(1.0 2.0 3.0 4.0)) ⇒ #t

(for-all (lambda (x y z) (= (+ x y) z))
         '(1 2 3 4)
         '(1.2 2.3 3.4 4.5)
         '(2.2 4.3 6.5 8.5)) ⇒ #f</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>for-all</code> may be defined (somewhat inefficiently and without error checks) as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define for-all
  (lambda (f ls . more)
    (or (null? ls)
      (let for-all ([x (car ls)] [ls (cdr ls)] [more more])
        (if (null? ls)
            (apply f x (map car more))
            (and (apply f x (map car more))
                 (for-all (car ls) (cdr ls) (map cdr more))))))))</code></pre>
</div>
</div>
<div id="control:s38" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fold-left <em>procedure</em> <em>obj</em> <em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code><em>list</em></code> arguments should all have the same length. <code><em>procedure</em></code> should accept one more argument than the number of <code><em>list</em></code> arguments and return a single value. It should not mutate the <code><em>list</em></code> arguments.</p>
</div>
<div class="paragraph">
<p><code>fold-left</code> returns <code><em>obj</em></code> if the <code><em>list</em></code> arguments are empty. If they are not empty, <code>fold-left</code> applies <code><em>procedure</em></code> to <code><em>obj</em></code> and the cars of <code><em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...</code>, then recurs with the value returned by <code><em>procedure</em></code> in place of <code><em>obj</em></code> and the cdr of each <code><em>list</em></code> in place of the <code><em>list</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fold-left cons '() '(1 2 3 4)) ⇒ ((((() . 1) . 2) . 3) . 4)

(fold-left
  (lambda (a x) (+ a (* x x)))
  0 '(1 2 3 4 5)) ⇒ 55

(fold-left
  (lambda (a . args) (append args a))
  '(question)
  '(that not to)
  '(is to be)
  '(the be: or)) ⇒ (to be or not to be: that is the question)</code></pre>
</div>
</div>
<div id="control:s41" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fold-right <em>procedure</em> <em>obj</em> <em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code><em>list</em></code> arguments should all have the same length. <code><em>procedure</em></code> should accept one more argument than the number of <code><em>list</em></code> arguments and return a single value. It should not mutate the <code><em>list</em></code> arguments.</p>
</div>
<div class="paragraph">
<p><code>fold-right</code> returns <code><em>obj</em></code> if the <code><em>list</em></code> arguments are empty. If they are not empty, <code>fold-right</code> recurs with the cdr of each <code><em>list</em></code> replacing the <code><em>list</em></code>, then applies <code><em>procedure</em></code> to the cars of <code><em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...</code> and the result returned by the recursion.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fold-right cons '() '(1 2 3 4)) ⇒ (1 2 3 4)

(fold-right
  (lambda (x a) (+ a (* x x)))
  0 '(1 2 3 4 5)) ⇒ 55

(fold-right
  (lambda (x y a) (cons* x y a))   ⇒ (parting is such sweet sorrow
  '((with apologies))                  gotta go see ya tomorrow
  '(parting such sorrow go ya)         (with apologies))
  '(is sweet gotta see tomorrow))</code></pre>
</div>
</div>
<div id="control:s44" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(vector-map <em>procedure</em> <em>vector<sub>1</sub></em> <em>vector<sub>1</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>vector of results</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>vector-map</code> applies <code><em>procedure</em></code> to corresponding elements of <code><em>vector<sub>1</sub></em> <em>vector<sub>2</sub></em> ...</code> and returns a vector of the resulting values. The vectors <code><em>vector<sub>1</sub></em> <em>vector<sub>2</sub></em> ...</code> must be of the same length, and <code><em>procedure</em></code> should accept as many arguments as there are vectors and return a single value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(vector-map abs '#(1 -2 3 -4 5 -6)) ⇒ #(1 2 3 4 5 6)
(vector-map (lambda (x y) (* x y))
  '#(1 2 3 4)
  '#(8 7 6 5)) ⇒ #(8 14 18 20)</code></pre>
</div>
</div>
<div class="paragraph">
<p>While the order in which the applications themselves occur is not specified, the order of the values in the output vector is the same as that of the corresponding values in the input vectors.</p>
</div>
<div id="control:s47" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(vector-for-each <em>procedure</em> <em>vector<sub>1</sub></em> <em>vector<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>vector-for-each</code> is similar to <code>vector-map</code> except that <code>vector-for-each</code> does not create and return a vector of the resulting values, and <code>vector-for-each</code> guarantees to perform the applications in sequence over the elements from left to right.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([same-count 0])
  (vector-for-each
    (lambda (x y)
      (when (= x y)
        (set! same-count (+ same-count 1))))
    '#(1 2 3 4 5 6)
    '#(2 3 3 4 7 6))
  same-count) ⇒ 3</code></pre>
</div>
</div>
<div id="control:s50" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-for-each <em>procedure</em> <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>string-for-each</code> is similar to <code>for-each</code> and <code>vector-for-each</code> except that the inputs are strings rather than lists or vectors.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([ls '()])
  (string-for-each
    (lambda r (set! ls (cons r ls)))
    "abcd"
    "===="
    "1234")
  (map list->string (reverse ls))) ⇒ ("a=1" "b=2" "c=3" "d=4")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_5.6.">Section 5.6. Continuations</h3>
<div class="paragraph">
<p>Continuations in Scheme are procedures that represent the remainder of a computation from a given point in the computation. They may be obtained with <code>call-with-current-continuation</code>, which can be abbreviated to <code>call/cc</code>.</p>
</div>
<div id="control:s54" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(call/cc <em>procedure</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(call-with-current-continuation <em>procedure</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These procedures are the same. The shorter name is often used for the obvious reason that it requires fewer keystrokes to type.</p>
</div>
<div class="paragraph">
<p><code>call/cc</code> obtains its continuation and passes it to <code><em>procedure</em></code>, which should accept one argument. The continuation itself is represented by a procedure. Each time this procedure is applied to zero or more values, it returns the values to the continuation of the <code>call/cc</code> application. That is, when the continuation procedure is called, it returns its arguments as the values of the application of <code>call/cc</code>.</p>
</div>
<div class="paragraph">
<p>If <code><em>procedure</em></code> returns normally when passed the continuation procedure, the values returned by <code>call/cc</code> are the values returned by <code><em>procedure</em></code>.</p>
</div>
<div class="paragraph">
<p>Continuations allow the implementation of nonlocal exits, backtracking (<a href="#ref14">[14]</a>,<a href="#ref29">[29]</a>), coroutines <a href="#ref16">[16]</a>, and multitasking (<a href="#ref10">[10]</a>,<a href="#ref32">[32]</a>).</p>
</div>
<div class="paragraph">
<p>The example below illustrates the use of a continuation to perform a nonlocal exit from a loop.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define member
  (lambda (x ls)
    (call/cc
      (lambda (break)
        (do ([ls ls (cdr ls)])
            ((null? ls) #f)
          (when (equal? x (car ls))
            (break ls)))))))

(member 'd '(a b c)) ⇒ #f
(member 'b '(a b c)) ⇒ (b c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Additional examples are given in Sections <a href="#section_3.3.">3.3</a> and <a href="#section_12.11.">12.11</a>.</p>
</div>
<div class="paragraph">
<p>The current continuation is typically represented internally as a stack of procedure activation records, and obtaining the continuation involves encapsulating the stack within a procedural object. Since an encapsulated stack has indefinite extent, some mechanism must be used to preserve the stack contents indefinitely. This can be done with surprising ease and efficiency and with no impact on programs that do not use continuations <a href="#ref17">[17]</a>.</p>
</div>
<div id="control:s56" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(dynamic-wind <em>in</em> <em>body</em> <em>out</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>values resulting from the application of <code><em>body</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="control:s57" class="paragraph">
<p><code>dynamic-wind</code> offers "protection" from continuation invocation. It is useful for performing tasks that must be performed whenever control enters or leaves <code><em>body</em></code>, either normally or by continuation application.</p>
</div>
<div class="paragraph">
<p>The three arguments <code><em>in</em></code>, <code><em>body</em></code>, and <code><em>out</em></code> must be procedures and should accept zero arguments, i.e., they should be <code><em>thunks</em></code>. Before applying <code><em>body</em></code>, and each time <code><em>body</em></code> is entered subsequently by the application of a continuation created within <code><em>body</em></code>, the <code><em>in</em></code> thunk is applied. Upon normal exit from <code><em>body</em></code> and each time <code><em>body</em></code> is exited by the application of a continuation created outside <code><em>body</em></code>, the <code><em>out</em></code> thunk is applied.</p>
</div>
<div class="paragraph">
<p>Thus, it is guaranteed that <code><em>in</em></code> is invoked at least once. In addition, if <code><em>body</em></code> ever returns, <code><em>out</em></code> is invoked at least once.</p>
</div>
<div class="paragraph">
<p>The following example demonstrates the use of <code>dynamic-wind</code> to be sure that an input port is closed after processing, regardless of whether the processing completes normally.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([p (open-input-file "input-file")])
  (dynamic-wind
    (lambda () #f)
    (lambda () (process p))
    (lambda () (close-port p))))</code></pre>
</div>
</div>
<div id="control:s59" class="paragraph">
<p>Common Lisp provides a similar facility (<code>unwind-protect</code>) for protection from nonlocal exits. This is often sufficient. <code>unwind-protect</code> provides only the equivalent to <code><em>out</em></code>, however, since Common Lisp does not support fully general continuations. Here is how <code>unwind-protect</code> might be specified with <code>dynamic-wind</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax unwind-protect
  (syntax-rules ()
    [(_ body cleanup ...)
     (dynamic-wind
       (lambda () #f)
       (lambda () body)
       (lambda () cleanup ...))]))

((call/cc
   (let ([x 'a])
     (lambda (k)
       (unwind-protect
         (k (lambda () x))
         (set! x 'b)))))) ⇒ b</code></pre>
</div>
</div>
<div class="paragraph">
<p>Some Scheme implementations support a controlled form of assignment known as <em>fluid binding</em>, in which a variable takes on a temporary value during a given computation and reverts to the old value after the computation has completed. The syntactic form <code>fluid-let</code> defined below in terms of <code>dynamic-wind</code> permits the fluid binding of a single variable <code>x</code> to the value of an expression <code>e</code> within a the body <code><em>b<sub>1</sub></em> <em>b<sub>2</sub></em> ...</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax fluid-let
  (syntax-rules ()
    [(_ ((x e)) <em>b<sub>1</sub></em> <em>b<sub>2</sub></em> ...)
     (let ([y e])
       (let ([swap (lambda () (let ([t x]) (set! x y) (set! y t)))])
         (dynamic-wind swap (lambda () <em>b<sub>1</sub></em> <em>b<sub>2</sub></em> ...) swap)))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Implementations that support <code>fluid-let</code> typically extend it to allow an indefinite number of <code>(x e)</code> pairs, as with <code>let</code>.</p>
</div>
<div class="paragraph">
<p>If no continuations are invoked within the body of a <code>fluid-let</code>, the behavior is the same as if the variable were simply assigned the new value on entry and assigned the old value on return.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 3])
  (+ (fluid-let ([x 5])
       x)
     x)) ⇒ 8</code></pre>
</div>
</div>
<div class="paragraph">
<p>A fluid-bound variable also reverts to the old value if a continuation created outside of the <code>fluid-let</code> is invoked.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 'a])
  (let ([f (lambda () x)])
    (cons (call/cc
            (lambda (k)
              (fluid-let ([x 'b])
                (k (f)))))
          (f)))) ⇒ (b . a)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If control has left a <code>fluid-let</code> body, either normally or by the invocation of a continuation, and control reenters the body by the invocation of a continuation, the temporary value of the fluid-bound variable is reinstated. Furthermore, any changes to the temporary value are maintained and reflected upon reentry.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define reenter #f)
(define x 0)
(fluid-let ([x 1])
  (call/cc (lambda (k) (set! reenter k)))
  (set! x (+ x 1))
  x) ⇒ 2
x ⇒ 0
(reenter '<strong>) ⇒ 3
(reenter '</strong>) ⇒ 4
x ⇒ 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>A library showing how <code>dynamic-wind</code> might be implemented were it not already built in is given below. In addition to defining <code>dynamic-wind</code>, the code defines a version of <code>call/cc</code> that does its part to support <code>dynamic-wind</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (dynamic-wind)
  (export dynamic-wind call/cc
    (rename (call/cc call-with-current-continuation)))
  (import (rename (except (rnrs) dynamic-wind) (call/cc rnrs:call/cc)))

  (define winders '())

  (define common-tail
    (lambda (x y)
      (let ([lx (length x)] [ly (length y)])
        (do ([x (if (> lx ly) (list-tail x (- lx ly)) x) (cdr x)]
             [y (if (> ly lx) (list-tail y (- ly lx)) y) (cdr y)])
            ((eq? x y) x)))))

  (define do-wind
    (lambda (new)
      (let ([tail (common-tail new winders)])
        (let f ([ls winders])
          (if (not (eq? ls tail))
              (begin
                (set! winders (cdr ls))
                ((cdar ls))
                (f (cdr ls)))))
        (let f ([ls new])
          (if (not (eq? ls tail))
              (begin
                (f (cdr ls))
                ((caar ls))
                (set! winders ls)))))))

  (define call/cc
    (lambda (f)
      (rnrs:call/cc
        (lambda (k)
          (f (let ([save winders])
               (lambda (x)
                 (unless (eq? save winders) (do-wind save))
                 (k x))))))))

  (define dynamic-wind
    (lambda (in body out)
      (in)
      (set! winders (cons (cons in out) winders))
      (let-values ([ans* (body)])
        (set! winders (cdr winders))
        (out)
        (apply values ans*)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Together, <code>dynamic-wind</code> and <code>call/cc</code> manage a list of <em>winders</em>. A winder is a pair of <em>in</em> and <em>out</em> thunks established by a call to <code>dynamic-wind</code>. Whenever <code>dynamic-wind</code> is invoked, the <em>in</em> thunk is invoked, a new winder containing the <em>in</em> and <em>out</em> thunks is placed on the winders list, the <em>body</em> thunk is invoked, the winder is removed from the winders list, and the <em>out</em> thunk is invoked. This ordering ensures that the winder is on the winders list only when control has passed through <em>in</em> and not yet entered <em>out</em>. Whenever a continuation is obtained, the winders list is saved, and whenever the continuation is invoked, the saved winders list is reinstated. During reinstatement, the <em>out</em> thunk of each winder on the current winders list that is not also on the saved winders list is invoked, followed by the <em>in</em> thunk of each winder on the saved winders list that is not also on the current winders list. The winders list is updated incrementally, again to ensure that a winder is on the current winders list only if control has passed through its <em>in</em> thunk and not entered its <em>out</em> thunk.</p>
</div>
<div class="paragraph">
<p>The test <code>(not (eq? save winders))</code> performed in <code>call/cc</code> is not strictly necessary but makes invoking a continuation less costly whenever the saved winders list is the same as the current winders list.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_5.7.">Section 5.7. Delayed Evaluation</h3>
<div class="paragraph">
<p>The syntactic form <code>delay</code> and the procedure <code>force</code> may be used in combination to implement <em>lazy evaluation</em>. An expression subject to lazy evaluation is not evaluated until its value is required and, once evaluated, is never reevaluated.</p>
</div>
<div id="control:s65" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(delay <em>expr</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a promise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(force <em>promise</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>result of forcing <code><em>promise</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs r5rs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The first time a promise created by <code>delay</code> is <em>forced</em> (with <code>force</code>), it evaluates <code><em>expr</em></code>, "remembering" the resulting value. Thereafter, each time the promise is forced, it returns the remembered value instead of reevaluating <code><em>expr</em></code>.</p>
</div>
<div class="paragraph">
<p><code>delay</code> and <code>force</code> are typically used only in the absence of side effects, e.g., assignments, so that the order of evaluation is unimportant.</p>
</div>
<div class="paragraph">
<p>The benefit of using <code>delay</code> and <code>force</code> is that some amount of computation might be avoided altogether if it is delayed until absolutely required. Delayed evaluation may be used to construct conceptually infinite lists, or <em>streams</em>. The example below shows how a stream abstraction may be built with <code>delay</code> and <code>force</code>. A stream is a promise that, when forced, returns a pair whose cdr is a stream.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define stream-car
  (lambda (s)
    (car (force s))))

(define stream-cdr
  (lambda (s)
    (cdr (force s))))

(define counters
  (let next ([n 1])
    (delay (cons n (next (+ n 1))))))

(stream-car counters) ⇒ 1

(stream-car (stream-cdr counters)) ⇒ 2

(define stream-add
  (lambda (s1 s2)
    (delay (cons
             (+ (stream-car s1) (stream-car s2))
             (stream-add (stream-cdr s1) (stream-cdr s2))))))

(define even-counters
  (stream-add counters counters))

(stream-car even-counters) ⇒ 2

(stream-car (stream-cdr even-counters)) ⇒ 4</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>delay</code> may be defined by</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax delay
  (syntax-rules ()
    [(_ expr) (make-promise (lambda () expr))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code>make-promise</code> might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define make-promise
  (lambda (p)
    (let ([val #f] [set? #f])
      (lambda ()
        (unless set?
          (let ([x (p)])
            (unless set?
              (set! val x)
              (set! set? #t))))
        val))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>With this definition of <code>delay</code>, <code>force</code> simply invokes the promise to force evaluation or to retrieve the saved value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define force
  (lambda (promise)
    (promise)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second test of the variable <code>set?</code> in <code>make-promise</code> is necessary in the event that, as a result of applying <code><em>p</em></code>, the promise is recursively forced. Since a promise must always return the same value, the result of the first application of <code><em>p</em></code> to complete is returned.</p>
</div>
<div class="paragraph">
<p>Whether <code>delay</code> and <code>force</code> handle multiple return values is unspecified; the implementation given above does not, but the following version does, with the help of <code>call-with-values</code> and <code>apply</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define make-promise
  (lambda (p)
    (let ([vals #f] [set? #f])
      (lambda ()
        (unless set?
          (call-with-values p
            (lambda x
              (unless set?
                (set! vals x)
                (set! set? #t)))))
        (apply values vals)))))

(define p (delay (values 1 2 3)))
(force p) ⇒ 1
             2
             3
(call-with-values (lambda () (force p)) +) ⇒ 6</code></pre>
</div>
</div>
<div class="paragraph">
<p>Neither implementation is quite right, since <code>force</code> must raise an exception with condition type <code>&amp;assertion</code> if its argument is not a promise. Since distinguishing procedures created by <code>make-promise</code> from other procedures is impossible, <code>force</code> cannot do so reliably. The following reimplementation of <code>make-promise</code> and <code>force</code> represents promises as records of the type <code>promise</code> to allow <code>force</code> to make the required check.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type promise
  (fields (immutable p) (mutable vals) (mutable set?))
  (protocol (lambda (new) (lambda (p) (new p #f #f)))))

(define force
  (lambda (promise)
    (unless (promise? promise)
      (assertion-violation 'promise "invalid argument" promise))
    (unless (promise-set? promise)
      (call-with-values (promise-p promise)
        (lambda x
          (unless (promise-set? promise)
            (promise-vals-set! promise x)
            (promise-set?-set! promise #t)))))
    (apply values (promise-vals promise))))</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_5.8.">Section 5.8. Multiple Values</h3>
<div class="paragraph">
<p>While all Scheme primitives and most user-defined procedures return exactly one value, some programming problems are best solved by returning zero values, more than one value, or even a variable number of values. For example, a procedure that partitions a list of values into two sublists needs to return two values. While it is possible for the producer of multiple values to package them into a data structure and for the consumer to extract them, it is often cleaner to use the built-in multiple-values interface. This interface consists of two procedures: <code>values</code> and <code>call-with-values</code>. The former produces multiple values and the latter links procedures that produce multiple-value values with procedures that consume them.</p>
</div>
<div id="control:s70" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(values <em>obj</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>obj</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The procedure <code>values</code> accepts any number of arguments and simply passes (returns) the arguments to its continuation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(values) ⇒

(values 1) ⇒ 1

(values 1 2 3) ⇒ 1
                  2
                  3

(define head&tail
  (lambda (ls)
    (values (car ls) (cdr ls))))

(head&tail '(a b c)) ⇒ a
                        (b c)</code></pre>
</div>
</div>
<div id="control:s71" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(call-with-values <em>producer</em> <em>consumer</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>producer</em></code> and <code><em>consumer</em></code> must be procedures. <code>call-with-values</code> applies <code><em>consumer</em></code> to the values returned by invoking <code><em>producer</em></code> without arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(call-with-values
  (lambda () (values 'bond 'james))
  (lambda (x y) (cons y x))) ⇒ (james . bond)

(call-with-values values list) ⇒ '()</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the second example, <code>values</code> itself serves as the producer. It receives no arguments and thus returns no values. <code>list</code> is thus applied to no arguments and so returns the empty list.</p>
</div>
<div class="paragraph">
<p>The procedure <code>dxdy</code> defined below computes the change in <code><em>x</em></code> and <code><em>y</em></code> coordinates for a pair of points whose coordinates are represented by <code>(<em>x</em> . <em>y</em>)</code> pairs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define dxdy
  (lambda (p1 p2)
    (values (- (car p2) (car p1))
            (- (cdr p2) (cdr p1)))))

(dxdy '(0 . 0) '(0 . 5)) ⇒ 0
                            5</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>dxdy</code> can be used to compute the length and slope of a segment represented by two endpoints.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define segment-length
  (lambda (p1 p2)
    (call-with-values
      (lambda () (dxdy p1 p2))
      (lambda (dx dy) (sqrt (+ (* dx dx) (* dy dy)))))))

(define segment-slope
  (lambda (p1 p2)
    (call-with-values
      (lambda () (dxdy p1 p2))
      (lambda (dx dy) (/ dy dx)))))

(segment-length '(1 . 4) '(4 . 8)) ⇒ 5
(segment-slope '(1 . 4) '(4 . 8)) ⇒ 4/3</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can of course combine these to form one procedure that returns two values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define describe-segment
  (lambda (p1 p2)
    (call-with-values
      (lambda () (dxdy p1 p2))
      (lambda (dx dy)
        (values
          (sqrt (+ (* dx dx) (* dy dy)))
          (/ dy dx))))))

(describe-segment '(1 . 4) '(4 . 8)) ⇒ 5
                                     ⇒ 4/3</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example below employs multiple values to divide a list nondestructively into two sublists of alternating elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define split
  (lambda (ls)
    (if (or (null? ls) (null? (cdr ls)))
        (values ls '())
        (call-with-values
          (lambda () (split (cddr ls)))
          (lambda (odds evens)
            (values (cons (car ls) odds)
                    (cons (cadr ls) evens)))))))

(split '(a b c d e f)) ⇒ (a c e)
                          (b d f)</code></pre>
</div>
</div>
<div class="paragraph">
<p>At each level of recursion, the procedure <code>split</code> returns two values: a list of the odd-numbered elements from the argument list and a list of the even-numbered elements.</p>
</div>
<div class="paragraph">
<p>The continuation of a call to <code>values</code> need not be one established by a call to <code>call-with-values</code>, nor must only <code>values</code> be used to return to a continuation established by <code>call-with-values</code>. In particular, <code>(values <em>e</em>)</code> and <code><em>e</em></code> are equivalent expressions. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(+ (values 2) 4) ⇒ 6

(if (values #t) 1 2) ⇒ 1

(call-with-values
  (lambda () 4)
  (lambda (x) x)) ⇒ 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, <code>values</code> may be used to pass any number of values to a continuation that ignores the values, as in the following.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(begin (values 1 2 3) 4) ⇒ 4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because a continuation may accept zero or more than one value, continuations obtained via <code>call/cc</code> may accept zero or more than one argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(call-with-values
  (lambda ()
    (call/cc (lambda (k) (k 2 3))))
  (lambda (x y) (list x y))) ⇒ (2 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The behavior is unspecified when a continuation expecting exactly one value receives zero values or more than one value. For example, the behavior of each of the following expressions is unspecified. Some implementations raise an exception, while others silently suppress additional values or supply defaults for missing values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(if (values 1 2) 'x 'y)

(+ (values) 5)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Programs that wish to force extra values to be ignored in particular contexts can do so easily by calling <code>call-with-values</code> explicitly. A syntactic form, which we might call <code>first</code>, can be defined to abstract the discarding of more than one value when only one is desired.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax first
  (syntax-rules ()
    [(_ expr)
     (call-with-values
       (lambda () expr)
       (lambda (x . y) x))]))

(if (first (values #t #f)) 'a 'b) ⇒ a</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since implementations are required to raise an exception with condition type <code>&amp;assertion</code> if a procedure does not accept the number of arguments passed to it, each of the following raises an exception.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(call-with-values
  (lambda () (values 2 3 4))
  (lambda (x y) x))

(call-with-values
  (lambda () (call/cc (lambda (k) (k 0))))
  (lambda (x y) x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since <code><em>producer</em></code> is most often a <code>lambda</code> expression, it is often convenient to use a syntactic extension that suppresses the <code>lambda</code> expression in the interest of readability.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax with-values
  (syntax-rules ()
    [(_ expr consumer)
     (call-with-values (lambda () expr) consumer)]))

(with-values (values 1 2) list) ⇒ (1 2)
(with-values (split '(1 2 3 4))
  (lambda (odds evens)
    evens)) ⇒ (2 4)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the <code><em>consumer</em></code> is also a <code>lambda</code> expression, the multiple-value variants of <code>let</code> and <code>let*</code> described in <a href="#section_4.5.">Section 4.5</a> are usually even more convenient.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let-values ([(odds evens) (split '(1 2 3 4))])
  evens) ⇒ (2 4)

(let-values ([ls (values 'a 'b 'c)])
  ls) ⇒ (a b c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Many standard syntactic forms and procedures pass along multiple values. Most of these are "automatic," in the sense that nothing special must be done by the implementation to make this happen. The usual expansion of <code>let</code> into a direct <code>lambda</code> call automatically propagates multiple values produced by the body of the <code>let</code>. Other operators must be coded specially to pass along multiple values. The <code>call-with-port</code> procedure (<a href="#section_7.6.">Section 7.6</a>), for example, calls its procedure argument, then closes the port argument before returning the procedure&#8217;s values, so it must save the values temporarily. This is easily accomplished via <code>let-values</code>, <code>apply</code>, and <code>values</code>:</p>
</div>
<div id="defn:call-with-port" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define call-with-port
  (lambda (port proc)
    (let-values ([val* (proc port)])
      (close-port port)
      (apply values val*))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If this seems like too much overhead when a single value is returned, the code can use <code>call-with-values</code> and <code>case-lambda</code> to handle the single-value case more efficiently:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define call-with-port
  (lambda (port proc)
    (call-with-values (lambda () (proc port))
      (case-lambda
        [(val) (close-port port) val]
        [val* (close-port port) (apply values val*)]))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The definitions of <code>values</code> and <code>call-with-values</code> (and concomitant redefinition of <code>call/cc</code>) in the library below demonstrate that the multiple-return-values interface could be implemented in Scheme if it were not already built in. No error checking can be done, however, for the case in which more than one value is returned to a single-value context, such as the test part of an <code>if</code> expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (mrvs)
  (export call-with-values values call/cc
    (rename (call/cc call-with-current-continuation)))
  (import
    (rename
      (except (rnrs) values call-with-values)
      (call/cc rnrs:call/cc)))

  (define magic (cons 'multiple 'values))

  (define magic?
    (lambda (x)
      (and (pair? x) (eq? (car x) magic))))

  (define call/cc
    (lambda (p)
      (rnrs:call/cc
        (lambda (k)
          (p (lambda args
               (k (apply values args))))))))

  (define values
    (lambda args
      (if (and (not (null? args)) (null? (cdr args)))
          (car args)
          (cons magic args))))

  (define call-with-values
    (lambda (producer consumer)
      (let ([x (producer)])
        (if (magic? x)
            (apply consumer (cdr x))
            (consumer x))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Multiple values can be implemented more efficiently <a href="#ref2">[2]</a>, but this code serves to illustrate the meanings of the operators and may be used to provide multiple values in older, nonstandard implementations that do not support them.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_5.9.">Section 5.9. Eval</h3>
<div class="paragraph">
<p>Scheme&#8217;s <code>eval</code> procedure allows programmers to write programs that construct and evaluate other programs. This ability to do run-time <em>meta programming</em> should not be overused but is handy when needed.</p>
</div>
<div id="control:s80" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(eval <em>obj</em> <em>environment</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>values of the Scheme expression represented by <code><em>obj</em></code> in <code><em>environment</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs eval)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>obj</em></code> does not represent a syntactically valid expression, <code>eval</code> raises an exception with condition type <code>&amp;syntax</code>. The environments returned by <code>environment</code>, <code>scheme-report-environment</code>, and <code>null-environment</code> are immutable. Thus, <code>eval</code> also raises an exception with condition type <code>&amp;syntax</code> if an assignment to any of the variables in the environment appears within the expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define cons 'not-cons)
(eval '(let ([x 3]) (cons x 4)) (environment '(rnrs))) ⇒ (3 . 4)

(define lambda 'not-lambda)
(eval '(lambda (x) x) (environment '(rnrs))) ⇒ #&lt;procedure&gt;

(eval '(cons 3 4) (environment)) ⇒ <em>exception</em></code></pre>
</div>
</div>
<div id="control:s81" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(environment <em>import-spec</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>an environment</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs eval)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>environment</code> returns an environment formed from the combined bindings of the given import specifiers. Each <code><em>import-spec</em></code> must be an s-expression representing a valid import specifier (see <a href="#chp_libraries_and_top_level_programs">Chapter 10</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define env (environment '(rnrs) '(prefix <code>(rnrs lists)</code> $)))
(eval '($cons* 3 4 (* 5 8)) env) ⇒ (3 4 . 40)</code></pre>
</div>
</div>
<div id="control:s82" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(null-environment <em>version</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(scheme-report-environment <em>version</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>an R5RS compatibility environment</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs r5rs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>version</em></code> must be the exact integer <code>5</code>.</p>
</div>
<div class="paragraph">
<p><code>null-environment</code> returns an environment containing bindings for the keywords whose meanings are defined by the Revised<sup>5</sup> Report on Scheme, along with bindings for the auxiliary keywords <code>else</code>, <code>=&gt;</code>, <code>...</code>, and <code>_</code>.</p>
</div>
<div class="paragraph">
<p><code>scheme-report-environment</code> returns an environment containing the same keyword bindings as the environment returned by <code>null-environment</code> along with bindings for the variables whose meanings are defined by the Revised<sup>5</sup> Report on Scheme, except those not defined by the Revised<sup>6</sup> Report: <code>load</code>, <code>interaction-environment</code>, <code>transcript-on</code>, <code>transcript-off</code>, and <code>char-ready?</code>.</p>
</div>
<div class="paragraph">
<p>The bindings for each of the identifiers in the environments returned by these procedures are those of the corresponding Revised<sup>6</sup> Report library, so this does not provide full backward compatibility, even if the excepted identifier bindings are not used.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chp_operations_on_objects">Chapter 6. Operations on Objects</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/ch6.png" alt="ch6">
</div>
</div>
<div class="paragraph">
<p>This chapter describes the operations on objects, including lists, numbers, characters, strings, vectors, bytevectors, symbols, booleans, hashtables, and enumerations. The first section covers constant objects and quotation. The second section describes generic equivalence predicates for comparing two objects and predicates for determining the type of an object. Later sections describe procedures that deal primarily with one of the object types mentioned above. There is no section treating operations on procedures, since the only operation defined specifically for procedures is application, and this is described in <a href="#chp_control_operations">Chapter 5</a>. Operations on ports are covered in the more general discussion of input and output in <a href="#chp_input_and_output">Chapter 7</a>. A mechanism for defining new data types is described in <a href="#chp_records">Chapter 9</a>.</p>
</div>
<div class="sect2">
<h3 id="section_6.1.">Section 6.1. Constants and Quotation</h3>
<div id="objects:s1" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code><em>constant</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>constant</em></code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>constant</em></code> is any self-evaluating constant, i.e., a number, boolean, character, string, or bytevector. Constants are immutable; see the note in the description of <code>quote</code> below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">3.2 ⇒ 3.2
#f ⇒ #f
#\c ⇒ #\c
"hi" ⇒ "hi"
#vu8(3 4 5) ⇒ #vu8(3 4 5)</code></pre>
</div>
</div>
<div id="objects:s2" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(quote <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>'<em>obj</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>obj</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>'<em>obj</em></code> is equivalent to <code>(quote <em>obj</em>)</code>. The abbreviated form is converted into the longer form by the Scheme reader (see <code>read</code>).</p>
</div>
<div class="paragraph">
<p><code>quote</code> inhibits the normal evaluation rule for <code><em>obj</em></code>, allowing <code><em>obj</em></code> to be employed as data. Although any Scheme object may be quoted, quotation is not necessary for self-evaluating constants, i.e., numbers, booleans, characters, strings, and bytevectors.</p>
</div>
<div class="paragraph">
<p>Quoted and self-evaluating constants are immutable. That is, programs should not alter a constant via <code>set-car!</code>, <code>string-set!</code>, etc., and implementations are permitted to raise an exception with condition type <code>&amp;assertion</code> if such an alteration is attempted. If an attempt to alter an immutable object is undetected, the behavior of the program is unspecified. An implementation may choose to share storage among different constants to save space.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(+ 2 3) ⇒ 5
'(+ 2 3) ⇒ (+ 2 3)
(quote (+ 2 3)) ⇒ (+ 2 3)
'a ⇒ a
'cons ⇒ cons
'() ⇒ ()
'7 ⇒ 7</code></pre>
</div>
</div>
<div id="objects:s5" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(quasiquote <em>obj</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>`<em>obj</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(unquote <em>obj</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>,<em>obj</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(unquote-splicing <em>obj</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>,@<em>obj</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>`<em>obj</em></code> is equivalent to <code>(quasiquote <em>obj</em>)</code>, <code>,<em>obj</em></code> is equivalent to <code>(unquote <em>obj</em>)</code>, and <code>,@<em>obj</em></code> is equivalent to <code>(unquote-splicing <em>obj</em>)</code>. The abbreviated forms are converted into the longer forms by the Scheme reader (see <code>read</code>).</p>
</div>
<div class="paragraph">
<p><code>quasiquote</code> is similar to <code>quote</code>, but it allows parts of the quoted text to be "unquoted." Within a <code>quasiquote</code> expression, <code>unquote</code> and <code>unquote-splicing</code> subforms are evaluated, and everything else is quoted, i.e., left unevaluated. The value of each <code>unquote</code> subform is inserted into the output in place of the <code>unquote</code> form, while the value of each <code>unquote-splicing</code> subform is spliced into the surrounding list or vector structure. <code>unquote</code> and <code>unquote-splicing</code> are valid only within <code>quasiquote</code> expressions.</p>
</div>
<div class="paragraph">
<p><code>quasiquote</code> expressions may be nested, with each <code>quasiquote</code> introducing a new level of quotation and each <code>unquote</code> or <code>unquote-splicing</code> taking away a level of quotation. An expression nested within <em>n</em> <code>quasiquote</code> expressions must be within <em>n</em> <code>unquote</code> or <code>unquote-splicing</code> expressions to be evaluated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">`(+ 2 3) ⇒ (+ 2 3)

`(+ 2 ,(* 3 4)) ⇒ (+ 2 12)
`(a b (,(+ 2 3) c) d) ⇒ (a b (5 c) d)
`(a b ,(reverse '(c d e)) f g) ⇒ (a b (e d c) f g)
(let ([a 1] [b 2])
  `(,a . ,b)) ⇒ (1 . 2)

`(+ ,@(cdr '(* 2 3))) ⇒ (+ 2 3)
`(a b ,@(reverse '(c d e)) f g) ⇒ (a b e d c f g)
(let ([a 1] [b 2])
  `(,a ,@b)) ⇒ (1 . 2)
`#(,@(list 1 2 3)) ⇒ #(1 2 3)

'`,(cons 'a 'b) ⇒ `,(cons 'a 'b)
`',(cons 'a 'b) ⇒ '(a . b)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>unquote</code> and <code>unquote-splicing</code> forms with zero or more than one subform are valid only in splicing (list or vector) contexts. <code>(unquote <em>obj</em> ...)</code> is equivalent to <code>(unquote <em>obj</em>) ...</code>, and <code>(unquote-splicing <em>obj</em> ...)</code> is equivalent to <code>(unquote-splicing <em>obj</em>) ...</code>. These forms are primarily useful as intermediate forms in the output of the <code>quasiquote</code> expander. They support certain useful nested quasiquotation idioms <a href="#ref3">[3]</a>, such as <code>,@,@</code>, which has the effect of a doubly indirect splicing when used within a doubly nested and doubly evaluated <code>quasiquote</code> expression.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">`(a (unquote) b) ⇒ (a b)
`(a (unquote (+ 3 3)) b) ⇒ (a 6 b)
`(a (unquote (+ 3 3) (* 3 3)) b) ⇒ (a 6 9 b)

(let ([x '(m n)]) ``(a ,@,@x f)) ⇒ `(a (unquote-splicing m n) f)
(let ([x '(m n)])
  (eval `(let ([m '(b c)] [n '(d e)]) `(a ,@,@x f))
        (environment '(rnrs)))) ⇒ (a b c d e f)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>unquote</code> and <code>unquote-splicing</code> are auxiliary keywords for <code>quasiquote</code>. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_6.2.">Section 6.2. Generic Equivalence and Type Predicates</h3>
<div class="paragraph">
<p>This section describes the basic Scheme predicates (procedures returning one of the boolean values <code>#t</code> or <code>#f</code>) for determining the type of an object or the equivalence of two objects. The equivalence predicates <code>eq?</code>, <code>eqv?</code>, and <code>equal?</code> are discussed first, followed by the type predicates.</p>
</div>
<div id="objects:s10" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(eq? <em>obj<sub>1</sub></em> <em>obj<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj<sub>1</sub></em></code> and <code><em>obj<sub>2</sub></em></code> are identical, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In most Scheme systems, two objects are considered identical if they are represented internally by the same pointer value and distinct (not identical) if they are represented internally by different pointer values, although other criteria, such as time-stamping, are possible.</p>
</div>
<div class="paragraph">
<p>Although the particular rules for object identity vary somewhat from system to system, the following rules always hold.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Two objects of different types (booleans, the empty list, pairs, numbers, characters, strings, vectors, symbols, and procedures) are distinct.</p>
</li>
<li>
<p>Two objects of the same type with different contents or values are distinct.</p>
</li>
<li>
<p>The boolean object <code>#t</code> is identical to itself wherever it appears, and <code>#f</code> is identical to itself wherever it appears, but <code>#t</code> and <code>#f</code> are distinct.</p>
</li>
<li>
<p>The empty list <code>()</code> is identical to itself wherever it appears.</p>
</li>
<li>
<p>Two symbols are identical if and only if they have the same name (by <code>string=?</code>).</p>
</li>
<li>
<p>A constant pair, vector, string, or bytevector is identical to itself, as is a pair, vector, string, or bytevector created by an application of <code>cons</code>, <code>vector</code>, <code>string</code>, <code>make-bytevector</code>, etc. Two pairs, vectors, strings, or bytevectors created by different applications of <code>cons</code>, <code>vector</code>, <code>string</code>, <code>make-bytevector</code>, etc., are distinct. One consequence is that <code>cons</code>, for example, may be used to create a unique object distinct from all other objects.</p>
</li>
<li>
<p>Two procedures that may behave differently are distinct. A procedure created by an evaluation of a <code>lambda</code> expression is identical to itself. Two procedures created by the same <code>lambda</code> expression at different times, or by similar <code>lambda</code> expressions, may or may not be distinct.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>eq?</code> cannot be used to compare numbers and characters reliably. Although every inexact number is distinct from every exact number, two exact numbers, two inexact numbers, or two characters with the same value may or may not be identical.</p>
</div>
<div class="paragraph">
<p>Since constant objects are immutable, i.e., programs should not modify them via <code>vector-set!</code>, <code>set-car!</code>, or any other structure mutation operation, all or portions of different quoted constants or self-evaluating literals may be represented internally by the same object. Thus, <code>eq?</code> may return <code>#t</code> when applied to equal parts of different immutable constants.</p>
</div>
<div class="paragraph">
<p><code>eq?</code> is most often used to compare symbols or to check for pointer equivalence of allocated objects, e.g., pairs, vectors, or record instances.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(eq? 'a 3) ⇒ #f
(eq? #t 't) ⇒ #f
(eq? "abc" 'abc) ⇒ #f
(eq? "hi" '(hi)) ⇒ #f
(eq? #f '()) ⇒ #f

(eq? 9/2 7/2) ⇒ #f
(eq? 3.4 53344) ⇒ #f
(eq? 3 3.0) ⇒ #f
(eq? 1/3 #i1/3) ⇒ #f

(eq? 9/2 9/2) ⇒ <em>unspecified</em>
(eq? 3.4 (+ 3.0 .4)) ⇒ <em>unspecified</em>
(let ([x (* 12345678987654321 2)])
  (eq? x x)) ⇒ <em>unspecified</em>

(eq? #\a #\b) ⇒ #f
(eq? #\a #\a) ⇒ <em>unspecified</em>
(let ([x (string-ref "hi" 0)])
  (eq? x x)) ⇒ <em>unspecified</em>

(eq? #t #t) ⇒ #t
(eq? #f #f) ⇒ #t
(eq? #t #f) ⇒ #f
(eq? (null? '()) #t) ⇒ #t
(eq? (null? '(a)) #f) ⇒ #t

(eq? (cdr '(a)) '()) ⇒ #t

(eq? 'a 'a) ⇒ #t
(eq? 'a 'b) ⇒ #f
(eq? 'a (string->symbol "a")) ⇒ #t

(eq? '(a) '(b)) ⇒ #f
(eq? '(a) '(a)) ⇒ <em>unspecified</em>
(let ([x '(a . b)]) (eq? x x)) ⇒ #t
(let ([x (cons 'a 'b)])
  (eq? x x)) ⇒ #t
(eq? (cons 'a 'b) (cons 'a 'b)) ⇒ #f

(eq? "abc" "cba") ⇒ #f
(eq? "abc" "abc") ⇒ <em>unspecified</em>
(let ([x "hi"]) (eq? x x)) ⇒ #t
(let ([x (string #\h #\i)]) (eq? x x)) ⇒ #t
(eq? (string #\h #\i)
     (string #\h #\i)) ⇒ #f

(eq? '#vu8(1) '#vu8(1)) ⇒ <em>unspecified</em>
(eq? '#vu8(1) '#vu8(2)) ⇒ #f
(let ([x (make-bytevector 10 0)])
  (eq? x x)) ⇒ #t
(let ([x (make-bytevector 10 0)])
  (eq? x (make-bytevector 10 0))) ⇒ #f

(eq? '#(a) '#(b)) ⇒ #f
(eq? '#(a) '#(a)) ⇒ <em>unspecified</em>
(let ([x '#(a)]) (eq? x x)) ⇒ #t
(let ([x (vector 'a)])
  (eq? x x)) ⇒ #t
(eq? (vector 'a) (vector 'a)) ⇒ #f

(eq? car car) ⇒ #t
(eq? car cdr) ⇒ #f
(let ([f (lambda (x) x)])
  (eq? f f)) ⇒ #t
(let ([f (lambda () (lambda (x) x))])
  (eq? (f) (f))) ⇒ <em>unspecified</em>
(eq? (lambda (x) x) (lambda (y) y)) ⇒ <em>unspecified</em>

(let ([f (lambda (x)
           (lambda ()
             (set! x (+ x 1))
             x))])
  (eq? (f 0) (f 0))) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s12" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(eqv? <em>obj<sub>1</sub></em> <em>obj<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj<sub>1</sub></em></code> and <code><em>obj<sub>2</sub></em></code> are equivalent, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>eqv?</code> is similar to <code>eq?</code> except <code>eqv?</code> is guaranteed to return <code>#t</code> for two characters that are considered equal by <code>char=?</code> and two numbers that are (a) considered equal by <code>=</code> and (b) cannot be distinguished by any other operation besides <code>eq?</code> and <code>eqv?</code>. A consequence of (b) is that <code>(eqv? -0.0 +0.0)</code> is <code>#f</code> even though <code>(= -0.0 +0.0)</code> is <code>#t</code> in systems that distinguish <code>-0.0</code> and <code>+0.0</code>, such as those based on IEEE floating-point arithmetic. This is because operations such as <code>/</code> can expose the difference:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(/ 1.0 -0.0) ⇒ -inf.0
(/ 1.0 +0.0) ⇒ +inf.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, although 3.0 and 3.0+0.0i are considered numerically equal, they are not considered equivalent by <code>eqv?</code> if -0.0 and 0.0 have different representations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(= 3.0+0.0i 3.0) ⇒ #t
(eqv? 3.0+0.0i 3.0) ⇒ #f</code></pre>
</div>
</div>
<div class="paragraph">
<p>The boolean value returned by <code>eqv?</code> is not specified when the arguments are NaNs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(eqv? +nan.0 (/ 0.0 0.0)) ⇒ <em>unspecified</em></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>eqv?</code> is less implementation-dependent but generally more expensive than <code>eq?</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(eqv? 'a 3) ⇒ #f
(eqv? #t 't) ⇒ #f
(eqv? "abc" 'abc) ⇒ #f
(eqv? "hi" '(hi)) ⇒ #f
(eqv? #f '()) ⇒ #f

(eqv? 9/2 7/2) ⇒ #f
(eqv? 3.4 53344) ⇒ #f
(eqv? 3 3.0) ⇒ #f
(eqv? 1/3 #i1/3) ⇒ #f

(eqv? 9/2 9/2) ⇒ #t
(eqv? 3.4 (+ 3.0 .4)) ⇒ #t
(let ([x (* 12345678987654321 2)])
  (eqv? x x)) ⇒ #t

(eqv? #\a #\b) ⇒ #f
(eqv? #\a #\a) ⇒ #t
(let ([x (string-ref "hi" 0)])
  (eqv? x x)) ⇒ #t

(eqv? #t #t) ⇒ #t
(eqv? #f #f) ⇒ #t
(eqv? #t #f) ⇒ #f
(eqv? (null? '()) #t) ⇒ #t
(eqv? (null? '(a)) #f) ⇒ #t

(eqv? (cdr '(a)) '()) ⇒ #t

(eqv? 'a 'a) ⇒ #t
(eqv? 'a 'b) ⇒ #f
(eqv? 'a (string->symbol "a")) ⇒ #t

(eqv? '(a) '(b)) ⇒ #f
(eqv? '(a) '(a)) ⇒ <em>unspecified</em>
(let ([x '(a . b)]) (eqv? x x)) ⇒ #t
(let ([x (cons 'a 'b)])
  (eqv? x x)) ⇒ #t
(eqv? (cons 'a 'b) (cons 'a 'b)) ⇒ #f

(eqv? "abc" "cba") ⇒ #f
(eqv? "abc" "abc") ⇒ <em>unspecified</em>
(let ([x "hi"]) (eqv? x x)) ⇒ #t
(let ([x (string #\h #\i)]) (eqv? x x)) ⇒ #t
(eqv? (string #\h #\i)
      (string #\h #\i)) ⇒ #f

(eqv? '#vu8(1) '#vu8(1)) ⇒ <em>unspecified</em>
(eqv? '#vu8(1) '#vu8(2)) ⇒ #f
(let ([x (make-bytevector 10 0)])
  (eqv? x x)) ⇒ #t
(let ([x (make-bytevector 10 0)])
  (eqv? x (make-bytevector 10 0))) ⇒ #f

(eqv? '#(a) '#(b)) ⇒ #f
(eqv? '#(a) '#(a)) ⇒ <em>unspecified</em>
(let ([x '#(a)]) (eqv? x x)) ⇒ #t
(let ([x (vector 'a)])
  (eqv? x x)) ⇒ #t
(eqv? (vector 'a) (vector 'a)) ⇒ #f

(eqv? car car) ⇒ #t
(eqv? car cdr) ⇒ #f
(let ([f (lambda (x) x)])
  (eqv? f f)) ⇒ #t
(let ([f (lambda () (lambda (x) x))])
  (eqv? (f) (f))) ⇒ <em>unspecified</em>
(eqv? (lambda (x) x) (lambda (y) y)) ⇒ <em>unspecified</em>

(let ([f (lambda (x)
           (lambda ()
             (set! x (+ x 1))
             x))])
  (eqv? (f 0) (f 0))) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s13" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(equal? <em>obj<sub>1</sub></em> <em>obj<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj<sub>1</sub></em></code> and <code><em>obj<sub>2</sub></em></code> have the same structure and contents, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Two objects are equal if they are equivalent according to <code>eqv?</code>, strings that are <code>string=?</code>, bytevectors that are <code>bytevector=?</code>, pairs whose cars and cdrs are equal, or vectors of the same length whose corresponding elements are equal.</p>
</div>
<div class="paragraph">
<p><code>equal?</code> is required to terminate even for cyclic arguments and return <code>#t</code> "if and only if the (possibly infinite) unfoldings of its arguments into regular trees are equal as ordered trees" <a href="#ref24">[24]</a>. In essence, two values are equivalent, in the sense of <code>equal?</code>, if the structure of the two objects cannot be distinguished by any composition of pair and vector accessors along with the <code>eqv?</code>, <code>string=?</code>, and <code>bytevector=?</code> procedures for comparing data at the leaves.</p>
</div>
<div class="paragraph">
<p>Implementing <code>equal?</code> efficiently is tricky <a href="#ref1">[1]</a>, and even with a good implementation, it is likely to be more expensive than either <code>eqv?</code> or <code>eq?</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(equal? 'a 3) ⇒ #f
(equal? #t 't) ⇒ #f
(equal? "abc" 'abc) ⇒ #f
(equal? "hi" '(hi)) ⇒ #f
(equal? #f '()) ⇒ #f

(equal? 9/2 7/2) ⇒ #f
(equal? 3.4 53344) ⇒ #f
(equal? 3 3.0) ⇒ #f
(equal? 1/3 #i1/3) ⇒ #f

(equal? 9/2 9/2) ⇒ #t
(equal? 3.4 (+ 3.0 .4)) ⇒ #t
(let ([x (* 12345678987654321 2)])
  (equal? x x)) ⇒ #t

(equal? #\a #\b) ⇒ #f
(equal? #\a #\a) ⇒ #t
(let ([x (string-ref "hi" 0)])
  (equal? x x)) ⇒ #t

(equal? #t #t) ⇒ #t
(equal? #f #f) ⇒ #t
(equal? #t #f) ⇒ #f
(equal? (null? '()) #t) ⇒ #t
(equal? (null? '(a)) #f) ⇒ #t

(equal? (cdr '(a)) '()) ⇒ #t

(equal? 'a 'a) ⇒ #t
(equal? 'a 'b) ⇒ #f
(equal? 'a (string->symbol "a")) ⇒ #t

(equal? '(a) '(b)) ⇒ #f
(equal? '(a) '(a)) ⇒ #t
(let ([x '(a . b)]) (equal? x x)) ⇒ #t
(let ([x (cons 'a 'b)])
  (equal? x x)) ⇒ #t
(equal? (cons 'a 'b) (cons 'a 'b)) ⇒ #t

(equal? "abc" "cba") ⇒ #f
(equal? "abc" "abc") ⇒ #t
(let ([x "hi"]) (equal? x x)) ⇒ #t
(let ([x (string #\h #\i)]) (equal? x x)) ⇒ #t
(equal? (string #\h #\i)
        (string #\h #\i)) ⇒ #t

(equal? '#vu8(1) '#vu8(1)) ⇒ #t
(equal? '#vu8(1) '#vu8(2)) ⇒ #f
(let ([x (make-bytevector 10 0)])
  (equal? x x)) ⇒ #t
(let ([x (make-bytevector 10 0)])
  (equal? x (make-bytevector 10 0))) ⇒ #t

(equal? '#(a) '#(b)) ⇒ #f
(equal? '#(a) '#(a)) ⇒ #t
(let ([x '#(a)]) (equal? x x)) ⇒ #t
(let ([x (vector 'a)])
  (equal? x x)) ⇒ #t
(equal? (vector 'a) (vector 'a)) ⇒ #t

(equal? car car) ⇒ #t
(equal? car cdr) ⇒ #f
(let ([f (lambda (x) x)])
  (equal? f f)) ⇒ #t
(let ([f (lambda () (lambda (x) x))])
  (equal? (f) (f))) ⇒ <em>unspecified</em>
(equal? (lambda (x) x) (lambda (y) y)) ⇒ <em>unspecified</em>

(let ([f (lambda (x)
           (lambda ()
             (set! x (+ x 1))
             x))])
  (equal? (f 0) (f 0))) ⇒ #f

(equal?
  (let ([x (cons 'x 'x)])
    (set-car! x x)
    (set-cdr! x x)
    x)
  (let ([x (cons 'x 'x)])
    (set-car! x x)
    (set-cdr! x x)
    (cons x x))) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s14" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(boolean? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is either <code>#t</code> or <code>#f</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>boolean?</code> is equivalent to <code>(lambda (x) (or (eq? x #t) (eq? x #f)))</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(boolean? #t) ⇒ #t
(boolean? #f) ⇒ #t
(or (boolean? 't) (boolean? '())) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s15" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(null? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is the empty list, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>null?</code> is equivalent to <code>(lambda (x) (eq? x '()))</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(null? '()) ⇒ #t
(null? '(a)) ⇒ #f
(null? (cdr '(a))) ⇒ #t
(null? 3) ⇒ #f
(null? #f) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s16" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(pair? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a pair, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(pair? '(a b c)) ⇒ #t
(pair? '(3 . 4)) ⇒ #t
(pair? '()) ⇒ #f
(pair? '#(a b)) ⇒ #f
(pair? 3) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s17" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(number? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a number object, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(complex? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a complex number object, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(real? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a real number object, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(rational? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a rational number object, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(integer? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is an integer object, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These predicates form a hierarchy: any integer is rational, any rational is real, any real is complex, and any complex is numeric. Most implementations do not provide internal representations for irrational numbers, so all real numbers are typically rational as well.</p>
</div>
<div class="paragraph">
<p>The <code>real?</code>, <code>rational?</code>, and <code>integer?</code> predicates do not recognize as real, rational, or integer complex numbers with inexact zero imaginary parts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(integer? 1901) ⇒ #t
(rational? 1901) ⇒ #t
(real? 1901) ⇒ #t
(complex? 1901) ⇒ #t
(number? 1901) ⇒ #t

(integer? -3.0) ⇒ #t
(rational? -3.0) ⇒ #t
(real? -3.0) ⇒ #t
(complex? -3.0) ⇒ #t
(number? -3.0) ⇒ #t

(integer? 7+0i) ⇒ #t
(rational? 7+0i) ⇒ #t
(real? 7+0i) ⇒ #t
(complex? 7+0i) ⇒ #t
(number? 7+0i) ⇒ #t

(integer? -2/3) ⇒ #f
(rational? -2/3) ⇒ #t
(real? -2/3) ⇒ #t
(complex? -2/3) ⇒ #t
(number? -2/3) ⇒ #t

(integer? -2.345) ⇒ #f
(rational? -2.345) ⇒ #t
(real? -2.345) ⇒ #t
(complex? -2.345) ⇒ #t
(number? -2.345) ⇒ #t

(integer? 7.0+0.0i) ⇒ #f
(rational? 7.0+0.0i) ⇒ #f
(real? 7.0+0.0i) ⇒ #f
(complex? 7.0+0.0i) ⇒ #t
(number? 7.0+0.0i) ⇒ #t

(integer? 3.2-2.01i) ⇒ #f
(rational? 3.2-2.01i) ⇒ #f
(real? 3.2-2.01i) ⇒ #f
(complex? 3.2-2.01i) ⇒ #t
(number? 3.2-2.01i) ⇒ #t

(integer? 'a) ⇒ #f
(rational? '(a b c)) ⇒ #f
(real? "3") ⇒ #f
(complex? '#(1 2)) ⇒ #f
(number? #\a) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s18" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(real-valued? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a real number, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(rational-valued? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a rational number, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(integer-valued? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is an integer, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These predicates are similar to <code>real?</code>, <code>rational?</code>, and <code>integer?</code>, but treat as real, rational, or integral complex numbers with inexact zero imaginary parts.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(integer-valued? 1901) ⇒ #t
(rational-valued? 1901) ⇒ #t
(real-valued? 1901) ⇒ #t

(integer-valued? -3.0) ⇒ #t
(rational-valued? -3.0) ⇒ #t
(real-valued? -3.0) ⇒ #t

(integer-valued? 7+0i) ⇒ #t
(rational-valued? 7+0i) ⇒ #t
(real-valued? 7+0i) ⇒ #t

(integer-valued? -2/3) ⇒ #f
(rational-valued? -2/3) ⇒ #t
(real-valued? -2/3) ⇒ #t

(integer-valued? -2.345) ⇒ #f
(rational-valued? -2.345) ⇒ #t
(real-valued? -2.345) ⇒ #t

(integer-valued? 7.0+0.0i) ⇒ #t
(rational-valued? 7.0+0.0i) ⇒ #t
(real-valued? 7.0+0.0i) ⇒ #t

(integer-valued? 3.2-2.01i) ⇒ #f
(rational-valued? 3.2-2.01i) ⇒ #f
(real-valued? 3.2-2.01i) ⇒ #f</code></pre>
</div>
</div>
<div class="paragraph">
<p>As with <code>real?</code>, <code>rational?</code>, and <code>integer?</code>, these predicates return <code>#f</code> for all non-numeric values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(integer-valued? 'a) ⇒ #f
(rational-valued? '(a b c)) ⇒ #f
(real-valued? "3") ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s19" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a character, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(char? 'a) ⇒ #f
(char? 97) ⇒ #f
(char? #\a) ⇒ #t
(char? "a") ⇒ #f
(char? (string-ref (make-string 1) 0)) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s20" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a string, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(string? "hi") ⇒ #t
(string? 'hi) ⇒ #f
(string? #\h) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s21" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(vector? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a vector, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(vector? '#()) ⇒ #t
(vector? '#(a b c)) ⇒ #t
(vector? (vector 'a 'b 'c)) ⇒ #t
(vector? '()) ⇒ #f
(vector? '(a b c)) ⇒ #f
(vector? "abc") ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s22" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(symbol? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a symbol, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(symbol? 't) ⇒ #t
(symbol? "t") ⇒ #f
(symbol? '(t)) ⇒ #f
(symbol? #\t) ⇒ #f
(symbol? 3) ⇒ #f
(symbol? #t) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s23" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(procedure? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a procedure, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(procedure? car) ⇒ #t
(procedure? 'car) ⇒ #f
(procedure? (lambda (x) x)) ⇒ #t
(procedure? '(lambda (x) x)) ⇒ #f
(call/cc procedure?) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s24" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a bytevector, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bytevector? #vu8()) ⇒ #t
(bytevector? '#()) ⇒ #f
(bytevector? "abc") ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s25" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a hashtable, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(hashtable? (make-eq-hashtable)) ⇒ #t
(hashtable? '(not a hash table)) ⇒ #f</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_6.3.">Section 6.3. Lists and Pairs</h3>
<div class="paragraph">
<p>The pair, or <em>cons cell</em>, is the most fundamental of Scheme&#8217;s structured object types. The most common use for pairs is to build lists, which are ordered sequences of pairs linked one to the next by the <em>cdr</em> field. The elements of the list occupy the <em>car</em> fields of the pairs. The cdr of the last pair in a <em>proper list</em> is the empty list, <code>()</code>; the cdr of the last pair in an <em>improper list</em> can be anything other than <code>()</code>.</p>
</div>
<div class="paragraph">
<p>Pairs may be used to construct binary trees. Each pair in the tree structure is an internal node of the binary tree; its car and cdr are the children of the node.</p>
</div>
<div class="paragraph">
<p>Proper lists are printed as sequences of objects separated by whitespace and enclosed in parentheses. Matching pairs of brackets ( <code>[</code> <code>]</code> ) may be used in place of parentheses. For example, <code>(1 2 3)</code> and <code>(a [nested list])</code> are proper lists. The empty list is written as <code>()</code>.</p>
</div>
<div class="paragraph">
<p>Improper lists and trees require a slightly more complex syntax. A single pair is written as two objects separated by whitespace and a dot, e.g., <code>(a . b)</code>. This is referred to as <em>dotted-pair notation</em>. Improper lists and trees are also written in dotted-pair notation; the dot appears wherever necessary, e.g., <code>(1 2 3 . 4)</code> or <code>1 . 2) . 3)</code>. Proper lists may be written in dotted-pair notation as well. For example, <code>(1 2 3)</code> may be written as <code>(1 . (2 . (3 . ())</code>.</p>
</div>
<div class="paragraph">
<p>It is possible to create a circular list or a cyclic graph by destructively altering the car or cdr field of a pair, using <code>set-car!</code> or <code>set-cdr!</code>. Such lists are not considered proper lists.</p>
</div>
<div class="paragraph">
<p>Procedures that accept a <code><em>list</em></code> argument are required to detect that the list is improper only to the extent that they actually traverse the list far enough either (a) to attempt to operate on a non-list tail or (b) to loop indefinitely due to a circularity. For example, <code>member</code> need not detect that a list is improper if it actually finds the element being sought, and <code>list-ref</code> need never detect circularities, because its recursion is bounded by the index argument.</p>
</div>
<div id="objects:s37" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(cons <em>obj<sub>1</sub></em> <em>obj<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new pair whose car and cdr are <code><em>obj<sub>1</sub></em></code> and <code><em>obj<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>cons</code> is the pair constructor procedure. <code><em>obj<sub>1</sub></em></code> becomes the car and <code><em>obj<sub>2</sub></em></code> becomes the cdr of the new pair.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(cons 'a '()) ⇒ (a)
(cons 'a '(b c)) ⇒ (a b c)
(cons 3 4) ⇒ (3 . 4)</code></pre>
</div>
</div>
<div id="objects:s38" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(car <em>pair</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the car of <code><em>pair</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The empty list is not a pair, so the argument must not be the empty list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(car '(a)) ⇒ a
(car '(a b c)) ⇒ a
(car (cons 3 4)) ⇒ 3</code></pre>
</div>
</div>
<div id="objects:s39" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(cdr <em>pair</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the cdr of <code><em>pair</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The empty list is not a pair, so the argument must not be the empty list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(cdr '(a)) ⇒ ()
(cdr '(a b c)) ⇒ (b c)
(cdr (cons 3 4)) ⇒ 4</code></pre>
</div>
</div>
<div id="objects:s40" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(set-car! <em>pair</em> <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs mutable-pairs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>set-car!</code> changes the car of <code><em>pair</em></code> to <code><em>obj</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x (list 'a 'b 'c)])
  (set-car! x 1)
  x) ⇒ (1 b c)</code></pre>
</div>
</div>
<div id="objects:s41" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(set-cdr! <em>pair</em> <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs mutable-pairs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>set-cdr!</code> changes the cdr of <code><em>pair</em></code> to <code><em>obj</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x (list 'a 'b 'c)])
  (set-cdr! x 1)
  x) ⇒ (a . 1)</code></pre>
</div>
</div>
<div id="objects:s42" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(caar <em>pair</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(cadr <em>pair</em>)</code> &lt;graphic&gt;</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(cddddr <em>pair</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the caar, cadr, ..., or cddddr of <code><em>pair</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These procedures are defined as the composition of up to four <code>car`s and `cdr`s. The `a&#8217;s and `d&#8217;s between the `c</code> and <code>r</code> represent the application of <code>car</code> or <code>cdr</code> in order from right to left. For example, the procedure <code>cadr</code> applied to a pair yields the <code>car</code> of the <code>cdr</code> of the pair and is equivalent to <code>(lambda (x) (car (cdr x)))</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(caar '((a))) ⇒ a
(cadr '(a b c)) ⇒ b
(cdddr '(a b c d)) ⇒ (d)
(cadadr '(a (b c))) ⇒ c</code></pre>
</div>
</div>
<div id="objects:s43" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(list <em>obj</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a list of <code><em>obj</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>list</code> is equivalent to <code>(lambda x x)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(list) ⇒ ()
(list 1 2 3) ⇒ (1 2 3)
(list 3 2 1) ⇒ (3 2 1)</code></pre>
</div>
</div>
<div id="objects:s44" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(cons* <em>obj</em> ... <em>final-obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a list of <code><em>obj</em> ...</code> terminated by <code><em>final-obj</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the objects <code><em>obj</em> ...</code> are omitted, the result is simply <code><em>final-obj</em></code>. Otherwise, a list of <code><em>obj</em> ...</code> is constructed, as with <code>list</code>, except that the final cdr field is <code><em>final-obj</em></code> instead of <code>()</code>. If <code><em>final-obj</em></code> is not a list, the result is an improper list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(cons* '()) ⇒ ()
(cons* '(a b)) ⇒ (a b)
(cons* 'a 'b 'c) ⇒ (a b . c)
(cons* 'a 'b '(c d)) ⇒ (a b c d)</code></pre>
</div>
</div>
<div id="objects:s45" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(list? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a proper list, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>list?</code> must return <code>#f</code> for all improper lists, including cyclic lists. A definition of <code>list?</code> is shown on page 67.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(list? '()) ⇒ #t
(list? '(a b c)) ⇒ #t
(list? 'a) ⇒ #f
(list? '(3 . 4)) ⇒ #f
(list? 3) ⇒ #f
(let ([x (list 'a 'b 'c)])
  (set-cdr! (cddr x) x)
  (list? x)) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s46" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(length <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the number of elements in <code><em>list</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>length</code> may be defined as follows, using an adaptation of the hare and tortoise algorithm used for the definition of <code>list?</code> on page 67.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define length
  (lambda (x)
    (define improper-list
      (lambda ()
        (assertion-violation 'length "not a proper list" x)))

    (let f ([h x] [t x] [n 0])
      (if (pair? h)
          (let ([h (cdr h)])
            (if (pair? h)
                (if (eq? h t)
                    (improper-list)
                    (f (cdr h) (cdr t) (+ n 2)))
                (if (null? h)
                    (+ n 1)
                    (improper-list))))
          (if (null? h)
              n
              (improper-list))))))

(length '()) ⇒ 0
(length '(a b c)) ⇒ 3
(length '(a b . c)) ⇒ <em>exception</em>
(length
  (let ([ls (list 'a 'b)])
    (set-cdr! (cdr ls) ls) ⇒ <em>exception</em>
    ls))
(length
  (let ([ls (list 'a 'b)])
    (set-car! (cdr ls) ls) ⇒ 2
    ls))</code></pre>
</div>
</div>
<div id="objects:s47" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(list-ref <em>list</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the <code><em>n</em></code>th element (zero-based) of <code><em>list</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer less than the length of <code><em>list</em></code>. <code>list-ref</code> may be defined without error checks as follows.</p>
</div>
<div id="defn:list-ref" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define list-ref
  (lambda (ls n)
    (if (= n 0)
        (car ls)
        (list-ref (cdr ls) (- n 1)))))

(list-ref '(a b c) 0) ⇒ a
(list-ref '(a b c) 1) ⇒ b
(list-ref '(a b c) 2) ⇒ c</code></pre>
</div>
</div>
<div id="objects:s48" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(list-tail <em>list</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the <code><em>n</em></code>th tail (zero-based) of <code><em>list</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer less than or equal to the length of <code><em>list</em></code>. The result is not a copy; the tail is <code>eq?</code> to the <code><em>n</em></code>th cdr of <code><em>list</em></code> (or to <code><em>list</em></code> itself, if <code><em>n</em></code> is zero).</p>
</div>
<div class="paragraph">
<p><code>list-tail</code> may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define list-tail
  (lambda (ls n)
    (if (= n 0)
        ls
        (list-tail (cdr ls) (- n 1)))))

(list-tail '(a b c) 0) ⇒ (a b c)
(list-tail '(a b c) 2) ⇒ (c)
(list-tail '(a b c) 3) ⇒ ()
(list-tail '(a b c . d) 2) ⇒ (c . d)
(list-tail '(a b c . d) 3) ⇒ d
(let ([x (list 1 2 3)])
  (eq? (list-tail x 2)
       (cddr x))) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s49" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(append)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(append <em>list</em> ... <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the concatenation of the input lists</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>append</code> returns a new list consisting of the elements of the first list followed by the elements of the second list, the elements of the third list, and so on. The new list is made from new pairs for all arguments but the last; the last (which need not be a list) is merely placed at the end of the new structure. <code>append</code> may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define append
  (lambda args
    (let f ([ls '()] [args args])
      (if (null? args)
          ls
          (let g ([ls ls])
            (if (null? ls)
                (f (car args) (cdr args))
                (cons (car ls) (g (cdr ls)))))))))

(append '(a b c) '()) ⇒ (a b c)
(append '() '(a b c)) ⇒ (a b c)
(append '(a b) '(c d)) ⇒ (a b c d)
(append '(a b) 'c) ⇒ (a b . c)
(let ([x (list 'b)])
  (eq? x (cdr (append '(a) x)))) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s50" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(reverse <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new list containing the elements of <code><em>list</em></code> in reverse order</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>reverse</code> may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define reverse
  (lambda (ls)
    (let rev ([ls ls] [new '()])
      (if (null? ls)
          new
          (rev (cdr ls) (cons (car ls) new))))))

(reverse '()) ⇒ ()
(reverse '(a b c)) ⇒ (c b a)</code></pre>
</div>
</div>
<div id="objects:s51" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(memq <em>obj</em> <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(memv <em>obj</em> <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(member <em>obj</em> <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the first tail of <code><em>list</em></code> whose car is equivalent to <code><em>obj</em></code>, or <code>#f</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These procedures traverse the argument <code><em>list</em></code> in order, comparing the elements of <code><em>list</em></code> against <code><em>obj</em></code>. If an object equivalent to <code><em>obj</em></code> is found, the tail of the list whose first element is that object is returned. If the list contains more than one object equivalent to <code><em>obj</em></code>, the first tail whose first element is equivalent to <code><em>obj</em></code> is returned. If no object equivalent to <code><em>obj</em></code> is found, <code>#f</code> is returned. The equivalence test for <code>memq</code> is <code>eq?</code>, for <code>memv</code> is <code>eqv?</code>, and for <code>member</code> is <code>equal?</code>.</p>
</div>
<div class="paragraph">
<p>These procedures are most often used as predicates, but their names do not end with a question mark because they return a useful true value in place of <code>#t</code>. <code>memq</code> may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define memq
  (lambda (x ls)
    (cond
      [(null? ls) #f]
      [(eq? (car ls) x) ls]
      [else (memq x (cdr ls))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>memv</code> and <code>member</code> may be defined similarly, with <code>eqv?</code> and <code>equal?</code> in place of <code>eq?</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(memq 'a '(b c a d e)) ⇒ (a d e)
(memq 'a '(b c d e g)) ⇒ #f
(memq 'a '(b a c a d a)) ⇒ (a c a d a)

(memv 3.4 '(1.2 2.3 3.4 4.5)) ⇒ (3.4 4.5)
(memv 3.4 '(1.3 2.5 3.7 4.9)) ⇒ #f
(let ([ls (list 'a 'b 'c)])
  (set-car! (memv 'b ls) 'z)
  ls) ⇒ (a z c)

(member '(b) '((a) (b) (c))) ⇒ ((b) (c))
(member '(d) '((a) (b) (c))) ⇒ #f
(member "b" '("a" "b" "c")) ⇒ ("b" "c")

(let ()
  (define member?
    (lambda (x ls)
      (and (member x ls) #t)))
  (member? '(b) '((a) (b) (c)))) ⇒ #t

(define count-occurrences
  (lambda (x ls)
    (cond
      [(memq x ls) =>
       (lambda (ls)
         (+ (count-occurrences x (cdr ls)) 1))]
      [else 0])))

(count-occurrences 'a '(a b c d a)) ⇒ 2</code></pre>
</div>
</div>
<div id="objects:s52" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(memp <em>procedure</em> <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the first tail of <code><em>list</em></code> for whose car <code><em>procedure</em></code> returns true, or <code>#f</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>procedure</em></code> should accept one argument and return a single value. It should not modify <code><em>list</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(memp odd? '(1 2 3 4)) ⇒ (1 2 3 4)
(memp even? '(1 2 3 4)) ⇒ (2 3 4)
(let ([ls (list 1 2 3 4)])
  (eq? (memp odd? ls) ls)) ⇒ #t
(let ([ls (list 1 2 3 4)])
  (eq? (memp even? ls) (cdr ls))) ⇒ #t
(memp odd? '(2 4 6 8)) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s53" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(remq <em>obj</em> <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(remv <em>obj</em> <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(remove <em>obj</em> <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a list containing the elements of <code><em>list</em></code> with all occurrences of <code><em>obj</em></code> removed</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These procedures traverse the argument <code><em>list</em></code>, removing any objects that are equivalent to <code><em>obj</em></code>. The elements remaining in the output list are in the same order as they appear in the input list. If a tail of <code><em>list</em></code> (including <code><em>list</em></code> itself) contains no occurrences of <code><em>obj</em></code>, the corresponding tail of the result list may be the same (by <code>eq?</code>) as the tail of the input list.</p>
</div>
<div class="paragraph">
<p>The equivalence test for <code>remq</code> is <code>eq?</code>, for <code>remv</code> is <code>eqv?</code>, and for <code>remove</code> is <code>equal?</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(remq 'a '(a b a c a d)) ⇒ (b c d)
(remq 'a '(b c d)) ⇒ (b c d)

(remv 1/2 '(1.2 1/2 0.5 3/2 4)) ⇒ (1.2 0.5 3/2 4)

(remove '(b) '((a) (b) (c))) ⇒ ((a) (c))</code></pre>
</div>
</div>
<div id="objects:s54" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(remp <em>procedure</em> <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a list of the elements of <code><em>list</em></code> for which <code><em>procedure</em></code> returns <code>#f</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>procedure</em></code> should accept one argument and return a single value. It should not modify <code><em>list</em></code>.</p>
</div>
<div class="paragraph">
<p><code>remp</code> applies <code><em>procedure</em></code> to each element of <code><em>list</em></code> and returns a list containing only the elements for which <code><em>procedure</em></code> returns <code>#f</code>. The elements of the returned list appear in the same order as they appeared in the original list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(remp odd? '(1 2 3 4)) ⇒ (2 4)
(remp
  (lambda (x) (and (> x 0) (< x 10)))
  '(-5 15 3 14 -20 6 0 -9)) ⇒ (-5 15 14 -20 0 -9)</code></pre>
</div>
</div>
<div id="objects:s55" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(filter <em>procedure</em> <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a list of the elements of <code><em>list</em></code> for which <code><em>procedure</em></code> returns true</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>procedure</em></code> should accept one argument and return a single value. It should not modify <code><em>list</em></code>.</p>
</div>
<div class="paragraph">
<p><code>filter</code> applies <code><em>procedure</em></code> to each element of <code><em>list</em></code> and returns a new list containing only the elements for which <code><em>procedure</em></code> returns true. The elements of the returned list appear in the same order as they appeared in the original list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(filter odd? '(1 2 3 4)) ⇒ (1 3)
(filter
  (lambda (x) (and (> x 0) (< x 10)))
  '(-5 15 3 14 -20 6 0 -9)) ⇒ (3 6)</code></pre>
</div>
</div>
<div id="objects:s56" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(partition <em>procedure</em> <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>procedure</em></code> should accept one argument and return a single value. It should not modify <code><em>list</em></code>.</p>
</div>
<div class="paragraph">
<p><code>partition</code> applies <code><em>procedure</em></code> to each element of <code><em>list</em></code> and returns two values: a new list containing only the elements for which <code><em>procedure</em></code> returns true, and a new list containing only the elements for which <code><em>procedure</em></code> returns <code>#f</code>. The elements of the returned lists appear in the same order as they appeared in the original list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(partition odd? '(1 2 3 4)) ⇒ (1 3)
                               (2 4)
(partition
  (lambda (x) (and (> x 0) (< x 10)))
  '(-5 15 3 14 -20 6 0 -9)) ⇒ (3 6)
                               (-5 15 14 -20 0 -9)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The values returned by <code>partition</code> can be obtained by calling <code>filter</code> and <code>remp</code> separately, but this would require two calls to <code><em>procedure</em></code> for each element of <code><em>list</em></code>.</p>
</div>
<div id="objects:s57" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(find <em>procedure</em> <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the first element of <code><em>list</em></code> for which <code><em>procedure</em></code> returns true, or <code>#f</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>procedure</em></code> should accept one argument and return a single value. It should not modify <code><em>list</em></code>.</p>
</div>
<div class="paragraph">
<p><code>find</code> traverses the argument <code><em>list</em></code> in order, applying <code><em>procedure</em></code> to each element in turn. If <code><em>procedure</em></code> returns a true value for a given element, <code>find</code> returns that element without applying <code><em>procedure</em></code> to the remaining elements. If <code><em>procedure</em></code> returns <code>#f</code> for each element of <code><em>list</em></code>, <code>find</code> returns <code>#f</code>.</p>
</div>
<div class="paragraph">
<p>If a program must distinguish between finding <code>#f</code> in the list and finding no element at all, <code>memp</code> should be used instead.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(find odd? '(1 2 3 4)) ⇒ 1
(find even? '(1 2 3 4)) ⇒ 2
(find odd? '(2 4 6 8)) ⇒ #f
(find not '(1 a #f 55)) ⇒ #f</code></pre>
</div>
</div>
<div id="page:assq" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(assq <em>obj</em> <em>alist</em>)</code> <a id="objects:s58"></a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(assv <em>obj</em> <em>alist</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(assoc <em>obj</em> <em>alist</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>first element of <code><em>alist</em></code> whose car is equivalent to <code><em>obj</em></code>, or <code>#f</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The argument <code><em>alist</em></code> must be an <em>association list</em>. An association list is a proper list whose elements are key-value pairs of the form <code>(key . value)</code>. Associations are useful for storing information (values) associated with certain objects (keys).</p>
</div>
<div class="paragraph">
<p>These procedures traverse the association list, testing each key for equivalence with <code><em>obj</em></code>. If an equivalent key is found, the key-value pair is returned. Otherwise, <code>#f</code> is returned.</p>
</div>
<div class="paragraph">
<p>The equivalence test for <code>assq</code> is <code>eq?</code>, for <code>assv</code> is <code>eqv?</code>, and for <code>assoc</code> is <code>equal?</code>. <code>assq</code> may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define assq
  (lambda (x ls)
    (cond
      [(null? ls) #f]
      [(eq? (caar ls) x) (car ls)]
      [else (assq x (cdr ls))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>assv</code> and <code>assoc</code> may be defined similarly, with <code>eqv?</code> and <code>equal?</code> in place of <code>eq?</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(assq 'b '((a . 1) (b . 2))) ⇒ (b . 2)
(cdr (assq 'b '((a . 1) (b . 2)))) ⇒ 2
(assq 'c '((a . 1) (b . 2))) ⇒ #f

(assv 2/3 '((1/3 . 1) (2/3 . 2))) ⇒ (2/3 . 2)
(assv 2/3 '((1/3 . a) (3/4 . b))) ⇒ #f

(assoc '(a) '(((a) . a) (-1 . b))) ⇒ ((a) . a)
(assoc '(a) '(((b) . b) (a . c))) ⇒ #f

(let ([alist (list (cons 2 'a) (cons 3 'b))])
  (set-cdr! (assv 3 alist) 'c)
  alist) ⇒ ((2 . a) (3 . c))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interpreter given in <a href="#section_12.7.">Section 12.7</a> represents environments as association lists and uses <code>assq</code> for both variable lookup and assignment.</p>
</div>
<div id="objects:s60" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(assp <em>procedure</em> <em>alist</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>first element of <code><em>alist</em></code> for whose car <code><em>procedure</em></code> returns true, or <code>#f</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs lists)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="objects:s61" class="paragraph">
<p><code><em>alist</em></code> must be an <em>association list</em>. An association list is a proper list whose elements are key-value pairs of the form <code>(key . value)</code>. <code><em>procedure</em></code> should accept one argument and return a single value. It should not modify <code><em>list</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(assp odd? '((1 . a) (2 . b))) ⇒ (1 . a)
(assp even? '((1 . a) (2 . b))) ⇒ (2 . b)
(let ([ls (list (cons 1 'a) (cons 2 'b))])
  (eq? (assp odd? ls) (car ls))) ⇒ #t
(let ([ls (list (cons 1 'a) (cons 2 'b))])
  (eq? (assp even? ls) (cadr ls))) ⇒ #t
(assp odd? '((2 . b))) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s62" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(list-sort <em>predicate</em> <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a list containing the elements of <code><em>list</em></code> sorted according to <code><em>predicate</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs sorting)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>predicate</em></code> should be a procedure that expects two arguments and returns <code>#t</code> if its first argument must precede its second in the sorted list. That is, if <code><em>predicate</em></code> is applied to two elements <code><em>x</em></code> and <code><em>y</em></code>, where <code><em>x</em></code> appears after <code><em>y</em></code> in the input list, it should return true only if <code><em>x</em></code> should appear before <code><em>y</em></code> in the output list. If this constraint is met, <code>list-sort</code> performs a stable sort, i.e., two elements are reordered only when necessary according to <code><em>predicate</em></code>. Duplicate elements are not removed. This procedure may call predicate up to \(n\log{n}\) times, where \(n\) is the length of <code><em>list</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(list-sort < '(3 4 2 1 2 5)) ⇒ (1 2 2 3 4 5)
(list-sort > '(0.5 1/2)) ⇒ (0.5 1/2)
(list-sort > '(1/2 0.5)) ⇒ (1/2 0.5)
(list->string
  (list-sort char>?
    (string->list "hello"))) ⇒ "ollhe"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_6.4.">Section 6.4. Numbers</h3>
<div class="paragraph">
<p>Scheme numbers may be classified as integers, rational numbers, real numbers, or complex numbers. This classification is hierarchical, in that all integers are rational, all rational numbers are real, and all real numbers are complex. The predicates <code>integer?</code>, <code>rational?</code>, <code>real?</code>, and <code>complex?</code> described in <a href="#section_6.2.">Section 6.2</a> are used to determine into which of these classes a number falls.</p>
</div>
<div class="paragraph">
<p>A Scheme number may also be classified as <em>exact</em> or <em>inexact</em>, depending upon the quality of operations used to derive the number and the inputs to these operations. The predicates <code>exact?</code> and <code>inexact?</code> may be used to determine the exactness of a number. Most operations on numbers in Scheme are <em>exactness preserving</em>: if given exact operands they return exact values, and if given inexact operands or a combination of exact and inexact operands they return inexact values.</p>
</div>
<div class="paragraph">
<p>Exact integer and rational arithmetic is typically supported to arbitrary precision; the size of an integer or of the denominator or numerator of a ratio is limited only by system storage constraints. Although other representations are possible, inexact numbers are typically represented by <em>floating-point</em> numbers supported by the host computer&#8217;s hardware or by system software. Complex numbers are typically represented as ordered pairs (<code><em>real-part</em></code>, <code><em>imag-part</em></code>), where <code><em>real-part</em></code> and <code><em>imag-part</em></code> are exact integers, exact rationals, or floating-point numbers.</p>
</div>
<div class="paragraph">
<p>Scheme numbers are written in a straightforward manner not much different from ordinary conventions for writing numbers. An exact integer is normally written as a sequence of numerals preceded by an optional sign. For example, <code>3</code>, <code>+19</code>, <code>-100000</code>, and <code>208423089237489374</code> all represent exact integers.</p>
</div>
<div class="paragraph">
<p>An exact rational number is normally written as two sequences of numerals separated by a slash (<code>/</code>) and preceded by an optional sign. For example, <code>3/4</code>, <code>-6/5</code>, and <code>1/1208203823</code> are all exact rational numbers. A ratio is reduced immediately to lowest terms when it is read and may in fact reduce to an exact integer.</p>
</div>
<div class="paragraph">
<p>Inexact real numbers are normally written in either floating-point or scientific notation. Floating-point notation consists of a sequence of numerals followed by a decimal point and another sequence of numerals, all preceded by an optional sign. Scientific notation consists of an optional sign, a sequence of numerals, an optional decimal point followed by a second string of numerals, and an exponent; an exponent is written as the letter <code>e</code> followed by an optional sign and a sequence of numerals. For example, <code>1.0</code> and <code>-200.0</code> are valid inexact integers, and <code>1.5</code>, <code>0.034</code>, <code>-10e-10</code> and <code>1.5e-5</code> are valid inexact rational numbers. The exponent is the power of ten by which the number preceding the exponent should be scaled, so that <code>2e3</code> is equivalent to <code>2000.0</code>.</p>
</div>
<div class="paragraph">
<p>A mantissa width <code>|<em>w</em></code> may appear as the suffix of a real number or the real components of a complex number written in floating-point or scientific notation. The mantissa width <code><em>w</em></code> represents the number of significant bits in the representation of the number. The mantissa width defaults to 53, the number of significant bits in a normalized IEEE double floating-point number, or more. For denormalized IEEE double floating-point numbers, the mantissa width is less than 53. If an implementation cannot represent a number with the mantissa width specified, it uses a representation with at least as many significant bits as requested if possible, otherwise it uses its representation with the largest mantissa width.</p>
</div>
<div class="paragraph">
<p>Exact and inexact real numbers are written as exact or inexact integers or rational numbers; no provision is made in the syntax of Scheme numbers for nonrational real numbers, i.e., irrational numbers.</p>
</div>
<div class="paragraph">
<p>Complex numbers may be written in either rectangular or polar form. In rectangular form, a complex number is written as <code><em>x</em>+<em>y<sub>i</sub></em></code> or <code><em>x</em>-<em>y<sub>i</sub></em></code>, where <code><em>x</em></code> is an integer, rational, or real number and <code><em>y</em></code> is an unsigned integer, rational, or real number. The real part, <em>x</em>, may be omitted, in which case it is assumed to be zero. For example, <code>3+4i</code>, <code>3.2-3/4i</code>, <code>+i</code>, and <code>-3e-5i</code> are complex numbers written in rectangular form. In polar form, a complex number is written as <code><em>x</em>@<em>y</em></code>, where <code><em>x</em></code> and <code><em>y</em></code> are integer, rational, or real numbers. For example, <code>1.1@1.764</code> and <code>-1@-1/2</code> are complex numbers written in polar form.</p>
</div>
<div class="paragraph">
<p>The syntaxes <code>+inf.0</code> and <code>-inf.0</code> represent inexact real numbers that represent positive and negative infinity. The syntaxes <code>+nan.0</code> and <code>-nan.0</code> represent an inexact "not-a-number" (NaN) value. Infinities may be produced by dividing inexact positive and negative values by inexact zero, and NaNs may also be produced by dividing inexact zero by inexact zero, among other ways.</p>
</div>
<div class="paragraph">
<p>The exactness of a numeric representation may be overridden by preceding the representation by either <code>#e</code> or <code>#i</code>. <code>#e</code> forces the number to be exact, and <code>#i</code> forces it to be inexact. For example, <code>1</code>, <code>#e1</code>, <code>1/1</code>, <code>#e1/1</code>, <code>#e1.0</code>, and <code>#e1e0</code> all represent the exact integer 1, and <code>#i3/10</code>, <code>0.3</code>, <code>#i0.3</code>, and <code>3e-1</code> all represent the inexact rational 0.3.</p>
</div>
<div class="paragraph">
<p>Numbers are written by default in base 10, although the special prefixes <code>#b</code> (binary), <code>#o</code> (octal), <code>#d</code> (decimal), and <code>#x</code> (hexadecimal) can be used to specify base 2, base 8, base 10, or base 16. For radix 16, the letters <code>a</code> through <code>f</code> or <code>A</code> through <code>F</code> serve as the additional numerals required to express digit values 10 through 15. For example, <code>#b10101</code> is the binary equivalent of <code>21<sub>10</sub></code>, <code>#o72</code> is the octal equivalent of <code>58<sub>10</sub></code>, and <code>#xC7</code> is the hexadecimal equivalent of <code>199<sub>10</sub></code>. Numbers written in floating-point and scientific notations are always written in base 10.</p>
</div>
<div class="paragraph">
<p>If both are present, radix and exactness prefixes may appear in either order.</p>
</div>
<div class="paragraph">
<p>A Scheme implementation may support more than one size of internal representation for inexact quantities. The exponent markers <code>s</code> (<em>short</em>), <code>f</code> (<em>single</em>), <code>d</code> (<em>double</em>), and <code>l</code> (<em>long</em>) may appear in place of the default exponent marker <code>e</code> to override the default size for numbers written in scientific notation. In implementations that support multiple representations, the default size has at least as much precision as <em>double</em>.</p>
</div>
<div class="paragraph">
<p>A precise grammar for Scheme numbers is given on <a href="#grammar:numbers">page 459</a>.</p>
</div>
<div class="paragraph">
<p>Any number can be written in a variety of different ways, but the system printer (invoked by <code>put-datum</code>, <code>write</code>, and <code>display</code>) and <code>number-&gt;string</code> express numbers in a compact form, using the fewest number of digits necessary to retain the property that, when read, the printed number is identical to the original number.</p>
</div>
<div class="paragraph">
<p>The remainder of this section describes "generic arithmetic" procedures that operate on numbers. The two sections that follow this section describe operations specific to <em>fixnums</em> and <em>flonums</em>, which are representations of exact, fixed-precision integer values and inexact real values.</p>
</div>
<div class="paragraph">
<p>The types of numeric arguments accepted by the procedures in this section are implied by the names given to the arguments: <code><em>num</em></code> for complex numbers (that is, all numbers), <code><em>real</em></code> for real numbers, <code><em>rat</em></code> for rational numbers, and <code><em>int</em></code> for integers. If a <code><em>real</em></code>, <code><em>rat</em></code>, or <code><em>int</em></code> is required, the argument must be considered real, rational, or integral by <code>real?</code>, <code>rational?</code>, or <code>integer?</code>, i.e., the imaginary part of the number must be exactly zero. Where exact integers are required, the name <code><em>exint</em></code> is used. In each case, a suffix may appear on the name, e.g., <code><em>int<sub>2</sub></em></code>.</p>
</div>
<div id="objects:s86" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(exact? <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>num</em></code> is exact, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(exact? 1) ⇒ #t
(exact? -15/16) ⇒ #t
(exact? 2.01) ⇒ #f
(exact? #i77) ⇒ #f
(exact? #i2/3) ⇒ #f
(exact? 1.0-2i) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s87" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(inexact? <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>num</em></code> is inexact, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(inexact? -123) ⇒ #f
(inexact? #i123) ⇒ #t
(inexact? 1e23) ⇒ #t
(inexact? +i) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s88" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(= <em>num<sub>1</sub></em> <em>num<sub>2</sub></em> <em>num<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(&lt; <em>real<sub>1</sub></em> <em>real<sub>2</sub></em> <em>real<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(&gt; <em>real<sub>1</sub></em> <em>real<sub>2</sub></em> <em>real<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(&lt;= <em>real<sub>1</sub></em> <em>real<sub>2</sub></em> <em>real<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(&gt;= <em>real<sub>1</sub></em> <em>real<sub>2</sub></em> <em>real<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the relation holds, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The predicate <code>=</code> returns <code>#t</code> if its arguments are equal. The predicate <code>&lt;</code> returns <code>#t</code> if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while <code>&gt;</code> returns <code>#t</code> if its arguments are monotonically decreasing. The predicate <code>&lt;=</code> returns <code>#t</code> if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while <code>&gt;=</code> returns <code>#t</code> if its arguments are monotonically nonincreasing.</p>
</div>
<div class="paragraph">
<p>As implied by the names of the arguments, <code>=</code> is defined for complex arguments while the other relational predicates are defined only for real arguments. Two complex numbers are considered equal if their real and imaginary parts are equal. Comparisons involving NaNs always return <code>#f</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(= 7 7) ⇒ #t
(= 7 9) ⇒ #f

(< 2e3 3e2) ⇒ #f
(<= 1 2 3 3 4 5) ⇒ #t
(<= 1 2 3 4 5) ⇒ #t

(> 1 2 2 3 3 4) ⇒ #f
(>= 1 2 2 3 3 4) ⇒ #f

(= -1/2 -0.5) ⇒ #t
(= 2/3 .667) ⇒ #f
(= 7.2+0i 7.2) ⇒ #t
(= 7.2-3i 7) ⇒ #f

(< 1/2 2/3 3/4) ⇒ #t
(> 8 4.102 2/3 -5) ⇒ #t

(let ([x 0.218723452])
  (< 0.210 x 0.220)) ⇒ #t

(let ([i 1] [v (vector 'a 'b 'c)])
  (< -1 i (vector-length v))) ⇒ #t

(apply < '(1 2 3 4)) ⇒ #t
(apply > '(4 3 3 2)) ⇒ #f

(= +nan.0 +nan.0) ⇒ #f
(< +nan.0 +nan.0) ⇒ #f
(> +nan.0 +nan.0) ⇒ #f
(>= +inf.0 +nan.0) ⇒ #f
(>= +nan.0 -inf.0) ⇒ #f
(> +nan.0 0.0) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s89" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(+ <em>num</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the sum of the arguments <code><em>num</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When called with no arguments, <code>+</code> returns 0.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(+) ⇒ 0
(+ 1 2) ⇒ 3
(+ 1/2 2/3) ⇒ 7/6
(+ 3 4 5) ⇒ 12
(+ 3.0 4) ⇒ 7.0
(+ 3+4i 4+3i) ⇒ 7+7i
(apply + '(1 2 3 4 5)) ⇒ 15</code></pre>
</div>
</div>
<div id="objects:s90" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(- <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the additive inverse of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(- <em>num<sub>1</sub></em> <em>num<sub>2</sub></em> <em>num<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the difference between <code><em>num<sub>1</sub></em></code> and the sum of <code><em>num<sub>2</sub></em> <em>num<sub>3</sub></em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(- 3) ⇒ -3
(- -2/3) ⇒ 2/3
(- 4 3.0) ⇒ 1.0
(- 3.25+4.25i 1/4+1/4i) ⇒ 3.0+4.0i
(- 4 3 2 1) ⇒ -2</code></pre>
</div>
</div>
<div id="objects:s91" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(* <em>num</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the product of the arguments <code><em>num</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When called with no arguments, <code>*</code> returns 1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(*) ⇒ 1
(* 3.4) ⇒ 3.4
(* 1 1/2) ⇒ 1/2
(* 3 4 5.5) ⇒ 66.0
(* 1+2i 3+4i) ⇒ -5+10i
(apply * '(1 2 3 4 5)) ⇒ 120</code></pre>
</div>
</div>
<div id="objects:s92" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(/ <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the multiplicative inverse of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(/ <em>num<sub>1</sub></em> <em>num<sub>2</sub></em> <em>num<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the result of dividing <code><em>num<sub>1</sub></em></code> by the product of <code><em>num<sub>2</sub></em> <em>num<sub>3</sub></em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(/ -17) ⇒ -1/17
(/ 1/2) ⇒ 2
(/ .5) ⇒ 2.0
(/ 3 4) ⇒ 3/4
(/ 3.0 4) ⇒ .75
(/ -5+10i 3+4i) ⇒ 1+2i
(/ 60 5 4 3 2) ⇒ 1/2</code></pre>
</div>
</div>
<div id="objects:s93" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(zero? <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>num</em></code> is zero, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>zero?</code> is equivalent to <code>(lambda (x) (= x 0))</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(zero? 0) ⇒ #t
(zero? 1) ⇒ #f
(zero? (- 3.0 3.0)) ⇒ #t
(zero? (+ 1/2 1/2)) ⇒ #f
(zero? 0+0i) ⇒ #t
(zero? 0.0-0.0i) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s94" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(positive? <em>real</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>real</em></code> is greater than zero, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>positive?</code> is equivalent to <code>(lambda (x) (&gt; x 0))</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(positive? 128) ⇒ #t
(positive? 0.0) ⇒ #f
(positive? 1.8e-15) ⇒ #t
(positive? -2/3) ⇒ #f
(positive? .001-0.0i) ⇒ <em>exception: not a real number</em></code></pre>
</div>
</div>
<div id="objects:s95" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(negative? <em>real</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>real</em></code> is less than zero, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>negative?</code> is equivalent to <code>(lambda (x) (&lt; x 0))</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(negative? -65) ⇒ #t
(negative? 0) ⇒ #f
(negative? -0.0121) ⇒ #t
(negative? 15/16) ⇒ #f
(negative? -7.0+0.0i) ⇒ <em>exception: not a real number</em></code></pre>
</div>
</div>
<div id="objects:s96" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(even? <em>int</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>int</em></code> is even, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(odd? <em>int</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>int</em></code> is odd, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(even? 0) ⇒ #t
(even? 1) ⇒ #f
(even? 2.0) ⇒ #t
(even? -120762398465) ⇒ #f
(even? 2.0+0.0i) ⇒ <em>exception: not an integer</em>

(odd? 0) ⇒ #f
(odd? 1) ⇒ #t
(odd? 2.0) ⇒ #f
(odd? -120762398465) ⇒ #t
(odd? 2.0+0.0i) ⇒ <em>exception: not an integer</em></code></pre>
</div>
</div>
<div id="objects:s97" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(finite? <em>real</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>real</em></code> is finite, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(infinite? <em>real</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>real</em></code> is infinite, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(nan? <em>real</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>real</em></code> is a NaN, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(finite? 2/3) ⇒ #t
(infinite? 2/3) ⇒ #f
(nan? 2/3) ⇒ #f

(finite? 3.1415) ⇒ #t
(infinite? 3.1415) ⇒ #f
(nan? 3.1415) ⇒ #f

(finite? +inf.0) ⇒ #f
(infinite? -inf.0) ⇒ #t
(nan? -inf.0) ⇒ #f

(finite? +nan.0) ⇒ #f
(infinite? +nan.0) ⇒ #f
(nan? +nan.0) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s98" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(quotient <em>int<sub>1</sub></em> <em>int<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the integer quotient of <code><em>int<sub>1</sub></em></code> and <code><em>int<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(remainder <em>int<sub>1</sub></em> <em>int<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the integer remainder of <code><em>int<sub>1</sub></em></code> and <code><em>int<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(modulo <em>int<sub>1</sub></em> <em>int<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the integer modulus of <code><em>int<sub>1</sub></em></code> and <code><em>int<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs r5rs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The result of <code>remainder</code> has the same sign as <code><em>int<sub>1</sub></em></code>, while the result of <code>modulo</code> has the same sign as <code><em>int<sub>2</sub></em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(quotient 45 6) ⇒ 7
(quotient 6.0 2.0) ⇒ 3.0
(quotient 3.0 -2) ⇒ -1.0

(remainder 16 4) ⇒ 0
(remainder 5 2) ⇒ 1
(remainder -45.0 7) ⇒ -3.0
(remainder 10.0 -3.0) ⇒ 1.0
(remainder -17 -9) ⇒ -8

(modulo 16 4) ⇒ 0
(modulo 5 2) ⇒ 1
(modulo -45.0 7) ⇒ 4.0
(modulo 10.0 -3.0) ⇒ -2.0
(modulo -17 -9) ⇒ -8</code></pre>
</div>
</div>
<div id="objects:s99" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(div <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(mod <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(div-and-mod <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>x<sub>1</sub></em></code> and <code><em>x<sub>2</sub></em></code> are exact, <code><em>x<sub>2</sub></em></code> must not be zero. These procedures implement number-theoretic integer division, with the <code>div</code> operation being related to <code>quotient</code> and the <code>mod</code> operation being related to <code>remainder</code> or <code>modulo</code>, but in both cases extended to handle real numbers.</p>
</div>
<div class="paragraph">
<p>The value <code><em>n<sub>d</sub></em></code> of <code>(div <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code> is an integer, and the value <code><em>x<sub>m</sub></em></code> of <code>(mod <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code> is a real number such that \(x_1 = n_d \cdot x_2 + x_m\) and \(0 \le x_m \lt |x_2|\). In situations where the implementation cannot represent the mathematical results prescribed by these equations as a number object, <code>div</code> and <code>mod</code> return an unspecified number or raise an exception with condition type <code>&amp;implementation-restriction</code>.</p>
</div>
<div class="paragraph">
<p>The <code>div-and-mod</code> procedure behaves as if defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define (div-and-mod x1 x2) (values (div x1 x2) (mod x1 x2)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is, unless it raises an exception in the circumstance described above, it returns two values: the result of calling <code>div</code> on the two arguments and the result of calling <code>mod</code> on the two arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(div 17 3) ⇒ 5
(mod 17 3) ⇒ 2
(div -17 3) ⇒ -6
(mod -17 3) ⇒ 1
(div 17 -3) ⇒ -5
(mod 17 -3) ⇒ 2
(div -17 -3) ⇒ 6
(mod -17 -3) ⇒ 1

(div-and-mod 17.5 3) ⇒ 5.0
                        2.5</code></pre>
</div>
</div>
<div id="objects:s100" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(div0 <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(mod0 <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(div0-and-mod0 <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>x<sub>1</sub></em></code> and <code><em>x<sub>2</sub></em></code> are exact, <code><em>x<sub>2</sub></em></code> must not be zero. These procedures are similar to <code>div</code>, <code>mod</code>, and <code>div-and-mod</code>, but constrain the "mod" value differently, which also affects the "div" value. The value <code><em>n<sub>d</sub></em></code> of <code>(div0 <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code> is an integer, and the value <code><em>x<sub>m</sub></em></code> of <code>(mod0 <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code> is a real number such that \(x_1 = n_d \cdot x_2 + x_m\) and \(-|x_2 / 2| \leq x_m \lt |x_2 / 2|\). In situations where the implementation cannot represent the mathematical results prescribed by these equations as a number object, <code>div0</code> and <code>mod0</code> return an unspecified number or raise an exception with condition type <code>&amp;implementation-restriction</code>.</p>
</div>
<div class="paragraph">
<p>The <code>div0-and-mod0</code> procedure behaves as if defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define (div0-and-mod0 x1 x2) (values (div0 x1 x2) (mod0 x1 x2)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is, unless it raises an exception in the circumstance described above, it returns two values: the result of calling <code>div0</code> on the two arguments and the result of calling <code>mod0</code> on the two arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(div0 17 3) ⇒ 6
(mod0 17 3) ⇒ -1
(div0 -17 3) ⇒ -6
(mod0 -17 3) ⇒ 1
(div0 17 -3) ⇒ -6
(mod0 17 -3) ⇒ -1
(div0 -17 -3) ⇒ 6
(mod0 -17 -3) ⇒ 1

(div0-and-mod0 17.5 3) ⇒ 6.0
                          -0.5</code></pre>
</div>
</div>
<div id="objects:s101" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(truncate <em>real</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the integer closest to <code><em>real</em></code> toward zero</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>real</em></code> is an infinity or NaN, <code>truncate</code> returns <code><em>real</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(truncate 19) ⇒ 19
(truncate 2/3) ⇒ 0
(truncate -2/3) ⇒ 0
(truncate 17.3) ⇒ 17.0
(truncate -17/2) ⇒ -8</code></pre>
</div>
</div>
<div id="objects:s102" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(floor <em>real</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the integer closest to <code><em>real</em></code> toward &lt;graphic&gt;</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>real</em></code> is an infinity or NaN, <code>floor</code> returns <code><em>real</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(floor 19) ⇒ 19
(floor 2/3) ⇒ 0
(floor -2/3) ⇒ -1
(floor 17.3) ⇒ 17.0
(floor -17/2) ⇒ -9</code></pre>
</div>
</div>
<div id="objects:s103" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(ceiling <em>real</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the integer closest to <code><em>real</em></code> toward &lt;graphic&gt;</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>real</em></code> is an infinity or NaN, <code>ceiling</code> returns <code><em>real</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(ceiling 19) ⇒ 19
(ceiling 2/3) ⇒ 1
(ceiling -2/3) ⇒ 0
(ceiling 17.3) ⇒ 18.0
(ceiling -17/2) ⇒ -8</code></pre>
</div>
</div>
<div id="objects:s104" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(round <em>real</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the integer closest to <code><em>real</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>real</em></code> is exactly between two integers, the closest even integer is returned. If <code><em>real</em></code> is an infinity or NaN, <code>round</code> returns <code><em>real</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(round 19) ⇒ 19
(round 2/3) ⇒ 1
(round -2/3) ⇒ -1
(round 17.3) ⇒ 17.0
(round -17/2) ⇒ -8
(round 2.5) ⇒ 2.0
(round 3.5) ⇒ 4.0</code></pre>
</div>
</div>
<div id="page:abs" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(abs <em>real</em>)</code> <a id="objects:s105"></a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the absolute value of <code><em>real</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>abs</code> is equivalent to <code>(lambda (x) (if (&lt; x 0) (- x) x))</code>. <code>abs</code> and <code>magnitude</code> (see <a href="#page:magnitude">page 183</a>) are identical for real inputs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(abs 1) ⇒ 1
(abs -3/4) ⇒ 3/4
(abs 1.83) ⇒ 1.83
(abs -0.093) ⇒ 0.093</code></pre>
</div>
</div>
<div id="objects:s107" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(max <em>real<sub>1</sub></em> <em>real<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the maximum of <code><em>real<sub>1</sub></em> <em>real<sub>2</sub></em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(max 4 -7 2 0 -6) ⇒ 4
(max 1/2 3/4 4/5 5/6 6/7) ⇒ 6/7
(max 1.5 1.3 -0.3 0.4 2.0 1.8) ⇒ 2.0
(max 5 2.0) ⇒ 5.0
(max -5 -2.0) ⇒ -2.0
(let ([ls '(7 3 5 2 9 8)])
  (apply max ls)) ⇒ 9</code></pre>
</div>
</div>
<div id="objects:s108" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(min <em>real<sub>1</sub></em> <em>real<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the minimum of <code><em>real<sub>1</sub></em> <em>real<sub>2</sub></em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(min 4 -7 2 0 -6) ⇒ -7
(min 1/2 3/4 4/5 5/6 6/7) ⇒ 1/2
(min 1.5 1.3 -0.3 0.4 2.0 1.8) ⇒ -0.3
(min 5 2.0) ⇒ 2.0
(min -5 -2.0) ⇒ -5.0
(let ([ls '(7 3 5 2 9 8)])
  (apply min ls)) ⇒ 2</code></pre>
</div>
</div>
<div id="page:gcd" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(gcd <em>int</em> ...)</code> <a id="objects:s109"></a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the greatest common divisor of its arguments <code><em>int</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The result is always nonnegative, i.e., factors of -1 are ignored. When called with no arguments, <code>gcd</code> returns 0.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(gcd) ⇒ 0
(gcd 34) ⇒ 34
(gcd 33.0 15.0) ⇒ 3.0
(gcd 70 -42 28) ⇒ 14</code></pre>
</div>
</div>
<div id="objects:s110" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(lcm <em>int</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the least common multiple of its arguments <code><em>int</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The result is always nonnegative, i.e., common multiples of -1 are ignored. Although <code>lcm</code> should probably return &lt;graphic&gt; when called with no arguments, it is defined to return 1. If one or more of the arguments is 0, <code>lcm</code> returns 0.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lcm) ⇒ 1
(lcm 34) ⇒ 34
(lcm 33.0 15.0) ⇒ 165.0
(lcm 70 -42 28) ⇒ 420
(lcm 17.0 0) ⇒ 0.0</code></pre>
</div>
</div>
<div id="objects:s111" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(expt <em>num<sub>1</sub></em> <em>num<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>num<sub>1</sub></em></code> raised to the <code><em>num<sub>2</sub></em></code> power</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If both arguments are 0, <code>expt</code> returns 1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(expt 2 10) ⇒ 1024
(expt 2 -10) ⇒ 1/1024
(expt 2 -10.0) ⇒ 9.765625e-4
(expt -1/2 5) ⇒ -1/32
(expt 3.0 3) ⇒ 27.0
(expt +i 2) ⇒ -1</code></pre>
</div>
</div>
<div id="objects:s112" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(inexact <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>an inexact representation of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="objects:s113" class="paragraph">
<p>If <code><em>num</em></code> is already inexact, it is returned unchanged. If no inexact representation for <code><em>num</em></code> is supported by the implementation, an exception with condition type <code>&amp;implementation-violation</code> may be raised. <code>inexact</code> may also return <code>+inf.0</code> or <code>-inf.0</code> for inputs whose magnitude exceeds the range of the implementation&#8217;s inexact number representations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(inexact 3) ⇒ 3.0
(inexact 3.0) ⇒ 3.0
(inexact -1/4) ⇒ -.25
(inexact 3+4i) ⇒ 3.0+4.0i
(inexact (expt 10 20)) ⇒ 1e20</code></pre>
</div>
</div>
<div id="objects:s114" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(exact <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>an exact representation of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="objects:s115" class="paragraph">
<p>If <code><em>num</em></code> is already exact, it is returned unchanged. If no exact representation for <code><em>num</em></code> is supported by the implementation, an exception with condition type <code>&amp;implementation-violation</code> may be raised.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(exact 3.0) ⇒ 3
(exact 3) ⇒ 3
(exact -.25) ⇒ -1/4
(exact 3.0+4.0i) ⇒ 3+4i
(exact 1e20) ⇒ 100000000000000000000</code></pre>
</div>
</div>
<div id="objects:s116" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(exact-&gt;inexact <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>an inexact representation of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(inexact-&gt;exact <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>an exact representation of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs r5rs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These are alternative names for <code>inexact</code> and <code>exact</code>, supported for compatibility with the Revised5 Report.</p>
</div>
<div id="objects:s117" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(rationalize <em>real<sub>1</sub></em> <em>real<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>rationalize</code> returns the simplest rational number that differs from <code><em>real<sub>1</sub></em></code> by no more than <code><em>real<sub>2</sub></em></code>. A rational number \(q_1 = n_1/m_1\) is simpler than another rational number \(q_2 = n_2/m_2\) if \(|n_1| \leq |n_2|\) and \(|m_1| \leq |m_2|\) and either \(|n_1| \lt |n_2|\) or \(|m_1| \lt |m_2|\).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(rationalize 3/10 1/10) ⇒ 1/3
(rationalize .3 1/10) ⇒ 0.3333333333333333
(eqv? (rationalize .3 1/10) #i1/3) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s118" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(numerator <em>rat</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the numerator of <code><em>rat</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>rat</em></code> is an integer, the numerator is <code><em>rat</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(numerator 9) ⇒ 9
(numerator 9.0) ⇒ 9.0
(numerator 0.0) ⇒ 0.0
(numerator 2/3) ⇒ 2
(numerator -9/4) ⇒ -9
(numerator -2.25) ⇒ -9.0</code></pre>
</div>
</div>
<div id="objects:s119" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(denominator <em>rat</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the denominator of <code><em>rat</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>rat</em></code> is an integer, including zero, the denominator is one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(denominator 9) ⇒ 1
(denominator 9.0) ⇒ 1.0
(denominator 0) ⇒ 1
(denominator 0.0) ⇒ 1.0
(denominator 2/3) ⇒ 3
(denominator -9/4) ⇒ 4
(denominator -2.25) ⇒ 4.0</code></pre>
</div>
</div>
<div id="objects:s120" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(real-part <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the real component of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>num</em></code> is real, <code>real-part</code> returns <code><em>num</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(real-part 3+4i) ⇒ 3
(real-part -2.3+0.7i) ⇒ -2.3
(real-part -i) ⇒ 0
(real-part 17.2) ⇒ 17.2
(real-part -17/100) ⇒ -17/100</code></pre>
</div>
</div>
<div id="objects:s121" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(imag-part <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the imaginary component of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>num</em></code> is real, <code>imag-part</code> returns exact zero.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(imag-part 3+4i) ⇒ 4
(imag-part -2.3+0.7i) ⇒ 0.7
(imag-part -i) ⇒ -1
(imag-part -2.5) ⇒ 0
(imag-part -17/100) ⇒ 0</code></pre>
</div>
</div>
<div id="objects:s122" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-rectangular <em>real<sub>1</sub></em> <em>real<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a complex number with real component <code><em>real<sub>1</sub></em></code> and imaginary component <code><em>real<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(make-rectangular -2 7) ⇒ -2+7i
(make-rectangular 2/3 -1/2) ⇒ 2/3-1/2i
(make-rectangular 3.2 5.3) ⇒ 3.2+5.3i</code></pre>
</div>
</div>
<div id="objects:s123" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-polar <em>real<sub>1</sub></em> <em>real<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a complex number with magnitude <code><em>real<sub>1</sub></em></code> and angle <code><em>real<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(make-polar 2 0) ⇒ 2
(make-polar 2.0 0.0) ⇒ 2.0+0.0i
(make-polar 1.0 (asin -1.0)) ⇒ 0.0-1.0i
(eqv? (make-polar 7.2 -0.588) 7.2@-0.588) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s124" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(angle <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the angle part of the polar representation of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The range of the result is \(-π\) (exclusive) to \(+π\) (inclusive).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(angle 7.3@1.5708) ⇒ 1.5708
(angle 5.2) ⇒ 0.0</code></pre>
</div>
</div>
<div id="page:magnitude" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(magnitude <em>num</em>)</code> <a id="objects:s125"></a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the magnitude of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>magnitude</code> and <code>abs</code> (see <a href="#page:abs">page 178</a>) are identical for real arguments. The magnitude of a complex number \(x + y_i\) is \(+\sqrt{x^2+y^2}\).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(magnitude 1) ⇒ 1
(magnitude -3/4) ⇒ 3/4
(magnitude 1.83) ⇒ 1.83
(magnitude -0.093) ⇒ 0.093
(magnitude 3+4i) ⇒ 5
(magnitude 7.25@1.5708) ⇒ 7.25</code></pre>
</div>
</div>
<div id="objects:s127" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(sqrt <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the principal square root of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Implementations are encouraged, but not required, to return exact results for exact inputs to <code>sqrt</code> whenever feasible.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(sqrt 16) ⇒ 4
(sqrt 1/4) ⇒ 1/2
(sqrt 4.84) ⇒ 2.2
(sqrt -4.84) ⇒ 0.0+2.2i
(sqrt 3+4i) ⇒ 2+1i
(sqrt -3.0-4.0i) ⇒ 1.0-2.0i</code></pre>
</div>
</div>
<div id="objects:s128" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(exact-integer-sqrt <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure returns two nonnegative exact integers <em>s</em> and <em>r</em> where \(n = s_2 + r\) and \(n &lt; (s + 1)^2\).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(exact-integer-sqrt 0) ⇒ 0
                          0
(exact-integer-sqrt 9) ⇒ 3
                       ⇒ 0
(exact-integer-sqrt 19) ⇒ 4
                        ⇒ 3</code></pre>
</div>
</div>
<div id="objects:s129" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(exp <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><em>e</em> to the <code><em>num</em></code> power</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(exp 0.0) ⇒ 1.0
(exp 1.0) ⇒ 2.7182818284590455
(exp -.5) ⇒ 0.6065306597126334</code></pre>
</div>
</div>
<div id="objects:s130" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(log <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the natural logarithm of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(log <em>num<sub>1</sub></em> <em>num<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the base-<code><em>num<sub>2</sub></em></code> logarithm of <code><em>num<sub>1</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(log 1.0) ⇒ 0.0
(log (exp 1.0)) ⇒ 1.0
(/ (log 100) (log 10)) ⇒ 2.0
(log (make-polar (exp 2.0) 1.0)) ⇒ 2.0+1.0i

(log 100.0 10.0) ⇒ 2.0
(log .125 2.0) ⇒ -3.0</code></pre>
</div>
</div>
<div id="objects:s131" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(sin <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(cos <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(tan <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the sine, cosine, or tangent of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The argument is specified in radians.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(sin 0.0) ⇒ 0.0
(cos 0.0) ⇒ 1.0
(tan 0.0) ⇒ 0.0</code></pre>
</div>
</div>
<div id="objects:s132" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(asin <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(acos <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the arc sine or the arc cosine of <code><em>num</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The result is in radians. The arc sine and arc cosine of a complex number <em>z</em> are defined as follows.</p>
</div>
<div class="stemblock">
<div class="content">
\[\sin^{-1}(z) = -i \log(iz + \sqrt{1 - z^2})\]
</div>
</div>
<div class="stemblock">
<div class="content">
\[\cos^{-1}(z) = π/2 - \sin^{-1}(z)\]
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define pi (* (asin 1) 2))
(= (* (acos 0) 2) pi) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s133" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(atan <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(atan <em>real<sub>1</sub></em> <em>real<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When passed a single complex argument <code><em>num</em></code> (the first form), <code>atan</code> returns the arc tangent of <code><em>num</em></code>. The arc tangent of a complex number <em>z</em> is defined as follows.</p>
</div>
<div class="stemblock">
<div class="content">
\[\tan^{-1}(z) = (\log(1 + iz) - \log(1 - iz)) / (2i)\]
</div>
</div>
<div class="paragraph">
<p>When passed two real arguments (the second form), <code>atan</code> is equivalent to <code>(lambda (y x) (angle (make-rectangular x y)))</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define pi (* (atan 1) 4))
(= (* (atan 1.0 0.0) 2) pi) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s134" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-not <em>exint</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the bitwise not of <code><em>exint</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-and <em>exint</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the bitwise and of <code><em>exint</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-ior <em>exint</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the bitwise inclusive or of <code><em>exint</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-xor <em>exint</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the bitwise exclusive or of <code><em>exint</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic bitwise)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The inputs are treated as if represented in two&#8217;s complement, even if they are not represented that way internally.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bitwise-not 0) ⇒ -1
(bitwise-not 3) ⇒ -4

(bitwise-and #b01101 #b00111) ⇒ #b00101
(bitwise-ior #b01101 #b00111) ⇒ #b01111
(bitwise-xor #b01101 #b00111) ⇒ #b01010</code></pre>
</div>
</div>
<div id="objects:s135" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-if <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em> <em>exint<sub>3</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the bitwise "if" of its arguments</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic bitwise)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The inputs are treated as if represented in two&#8217;s complement, even if they are not represented that way internally.</p>
</div>
<div class="paragraph">
<p>For each bit set in <code><em>exint<sub>1</sub></em></code>, the corresponding bit of the result is taken from <code><em>exint<sub>2</sub></em></code>, and for each bit not set in <code><em>exint<sub>1</sub></em></code>, the corresponding bit of the result is taken from <code><em>x<sub>3</sub></em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bitwise-if #b101010 #b111000 #b001100) ⇒ #b101100</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>bitwise-if</code> might be defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define bitwise-if
  (lambda (exint1 exint2 exint3)
    (bitwise-ior
      (bitwise-and exint1 exint2)
      (bitwise-and (bitwise-not exint1) exint3))))</code></pre>
</div>
</div>
<div id="objects:s136" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-bit-count <em>exint</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic bitwise)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For nonnegative inputs, <code>bitwise-bit-count</code> returns the number of bits set in the two&#8217;s complement representation of <code><em>exint</em></code>. For negative inputs, it returns a negative number whose magnitude is one greater than the number of bits not set in the two&#8217;s complement representation of <code><em>exint</em></code>, which is equivalent to <code>(bitwise-not (bitwise-bit-count (bitwise-not <em>exint</em>)))</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bitwise-bit-count #b00000) ⇒ 0
(bitwise-bit-count #b00001) ⇒ 1
(bitwise-bit-count #b00100) ⇒ 1
(bitwise-bit-count #b10101) ⇒ 3

(bitwise-bit-count -1) ⇒ -1
(bitwise-bit-count -2) ⇒ -2
(bitwise-bit-count -4) ⇒ -3</code></pre>
</div>
</div>
<div id="objects:s137" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-length <em>exint</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic bitwise)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure returns the number of bits of the smallest two&#8217;s complement representation of <code><em>exint</em></code>, not including the sign bit for negative numbers. For 0 <code>bitwise-length</code> returns 0.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bitwise-length #b00000) ⇒ 0
(bitwise-length #b00001) ⇒ 1
(bitwise-length #b00100) ⇒ 3
(bitwise-length #b00110) ⇒ 3

(bitwise-length -1) ⇒ 0
(bitwise-length -6) ⇒ 3
(bitwise-length -9) ⇒ 4</code></pre>
</div>
</div>
<div id="objects:s138" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-first-bit-set <em>exint</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the index of the least significant bit set in <code><em>exint</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic bitwise)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The input is treated as if represented in two&#8217;s complement, even if it is not represented that way internally.</p>
</div>
<div class="paragraph">
<p>If <code><em>exint</em></code> is 0, <code>bitwise-first-bit-set</code> returns -1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bitwise-first-bit-set #b00000) ⇒ -1
(bitwise-first-bit-set #b00001) ⇒ 0
(bitwise-first-bit-set #b01100) ⇒ 2

(bitwise-first-bit-set -1) ⇒ 0
(bitwise-first-bit-set -2) ⇒ 1
(bitwise-first-bit-set -3) ⇒ 0</code></pre>
</div>
</div>
<div id="objects:s139" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-bit-set? <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if bit <code><em>exint<sub>2</sub></em></code> of <code><em>exint<sub>1</sub></em></code> is set, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic bitwise)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>exint<sub>2</sub></em></code> is taken as a zero-based index for the bits in the two&#8217;s complement representation of <code><em>exint<sub>1</sub></em></code>. The two&#8217;s complement representation of a nonnegative number conceptually extends to the left (toward more significant bits) with an infinite number of zero bits, and the two&#8217;s complement representation of a negative number conceptually extends to the left with an infinite number of one bits. Thus, exact integers can be used to represent arbitrarily large sets, where 0 is the empty set, -1 is the universe, and <code>bitwise-bit-set?</code> is used to test for membership.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bitwise-bit-set? #b01011 0) ⇒ #t
(bitwise-bit-set? #b01011 2) ⇒ #f

(bitwise-bit-set? -1 0) ⇒ #t
(bitwise-bit-set? -1 20) ⇒ #t
(bitwise-bit-set? -3 1) ⇒ #f

(bitwise-bit-set? 0 5000) ⇒ #f
(bitwise-bit-set? -1 5000) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s140" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-copy-bit <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em> <em>exint<sub>3</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>exint<sub>1</sub></em></code> with bit <code><em>exint<sub>2</sub></em></code> replaced by <code><em>exint<sub>3</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic bitwise)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>exint<sub>2</sub></em></code> is taken as a zero-based index for the bits in the two&#8217;s complement representation of <code><em>exint<sub>1</sub></em></code>. <code><em>exint<sub>3</sub></em></code> must be 0 or 1. This procedure effectively clears or sets the specified bit depending on the value of <code><em>exint<sub>3</sub></em></code>. <code><em>exint<sub>1</sub></em></code> is treated as if represented in two&#8217;s complement, even if it is not represented that way internally.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bitwise-copy-bit #b01110 0 1) ⇒ #b01111
(bitwise-copy-bit #b01110 2 0) ⇒ #b01010</code></pre>
</div>
</div>
<div id="objects:s141" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-bit-field <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em> <em>exint<sub>3</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic bitwise)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>exint<sub>2</sub></em></code> and <code><em>exint<sub>3</sub></em></code> must be nonnegative, and <code><em>exint<sub>2</sub></em></code> must not be greater than <code><em>exint<sub>3</sub></em></code>. This procedure returns the number represented by extracting from <code><em>exint<sub>1</sub></em></code> the sequence of bits from <code><em>exint<sub>2</sub></em></code> (inclusive) to <code><em>exint<sub>3</sub></em></code> (exclusive). <code><em>exint<sub>1</sub></em></code> is treated as if represented in two&#8217;s complement, even if it is not represented that way internally.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bitwise-bit-field #b10110 0 3) ⇒ #b00110
(bitwise-bit-field #b10110 1 3) ⇒ #b00011
(bitwise-bit-field #b10110 2 3) ⇒ #b00001
(bitwise-bit-field #b10110 3 3) ⇒ #b00000</code></pre>
</div>
</div>
<div id="objects:s142" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-copy-bit-field <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em> <em>exint<sub>3</sub></em> <em>exint<sub>4</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic bitwise)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>exint<sub>2</sub></em></code> and <code><em>exint<sub>3</sub></em></code> must be nonnegative, and <code><em>exint<sub>2</sub></em></code> must not be greater than <code><em>exint<sub>3</sub></em></code>. This procedure returns <code><em>exint<sub>1</sub></em></code> with the <code><em>n</em></code> bits from <code><em>exint<sub>2</sub></em></code> (inclusive) to <code><em>exint<sub>3</sub></em></code> (exclusive) replaced by the low-order <code><em>n</em></code> bits of <code><em>exint<sub>4</sub></em></code>. <code><em>exint<sub>1</sub></em></code> and <code><em>exint<sub>4</sub></em></code> are treated as if represented in two&#8217;s complement, even if they are not represented that way internally.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bitwise-copy-bit-field #b10000 0 3 #b10101) ⇒ #b10101
(bitwise-copy-bit-field #b10000 1 3 #b10101) ⇒ #b10010
(bitwise-copy-bit-field #b10000 2 3 #b10101) ⇒ #b10100
(bitwise-copy-bit-field #b10000 3 3 #b10101) ⇒ #b10000</code></pre>
</div>
</div>
<div id="objects:s143" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-arithmetic-shift-right <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>exint<sub>1</sub></em></code> arithmetically shifted right by <code><em>exint<sub>2</sub></em></code> bits</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-arithmetic-shift-left <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>exint<sub>1</sub></em></code> shifted left by <code><em>exint<sub>2</sub></em></code> bits</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic bitwise)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>exint<sub>2</sub></em></code> must be nonnegative. <code><em>exint<sub>1</sub></em></code> is treated as if represented in two&#8217;s complement, even if it is not represented that way internally.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bitwise-arithmetic-shift-right #b10000 3) ⇒ #b00010
(bitwise-arithmetic-shift-right -1 1) ⇒ -1
(bitwise-arithmetic-shift-right -64 3) ⇒ -8

(bitwise-arithmetic-shift-left #b00010 2) ⇒ #b01000
(bitwise-arithmetic-shift-left -1 2) ⇒ -4</code></pre>
</div>
</div>
<div id="objects:s144" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-arithmetic-shift <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic bitwise)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>exint<sub>2</sub></em></code> is negative, <code>bitwise-arithmetic-shift</code> returns the result of arithmetically shifting <code><em>exint<sub>1</sub></em></code> right by <code>-<em>exint<sub>2</sub></em></code> bits. Otherwise, <code>bitwise-arithmetic-shift</code> returns the result of shifting <code><em>exint<sub>1</sub></em></code> left by <code><em>exint<sub>2</sub></em></code> bits. <code><em>exint<sub>1</sub></em></code> is treated as if represented in two&#8217;s complement, even if it is not represented that way internally.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bitwise-arithmetic-shift #b10000 -3) ⇒ #b00010
(bitwise-arithmetic-shift -1 -1) ⇒ -1
(bitwise-arithmetic-shift -64 -3) ⇒ -8
(bitwise-arithmetic-shift #b00010 2) ⇒ #b01000
(bitwise-arithmetic-shift -1 2) ⇒ -4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thus, <code>bitwise-arithmetic-shift</code> behaves as if defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define bitwise-arithmetic-shift
  (lambda (exint1 exint2)
    (if (< exint2 0)
        (bitwise-arithmetic-shift-right exint1 (- exint2))
        (bitwise-arithmetic-shift-left exint1 exint2))))</code></pre>
</div>
</div>
<div id="objects:s145" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-rotate-bit-field <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em> <em>exint<sub>3</sub></em> <em>exint<sub>4</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic bitwise)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>exint<sub>2</sub></em></code>, <code><em>exint<sub>3</sub></em></code>, and <code><em>exint<sub>4</sub></em></code> must be nonnegative, and <code><em>exint<sub>2</sub></em></code> must not be greater than <code><em>exint<sub>3</sub></em></code>. This procedure returns the result of shifting the bits of <code><em>exint<sub>1</sub></em></code> from bit <code><em>exint<sub>2</sub></em></code> (inclusive) through bit <code><em>exint<sub>3</sub></em></code> (exclusive) left by <code>(mod <em>exint<sub>4</sub></em> (- <em>exint<sub>3</sub></em> <em>exint<sub>2</sub></em>))</code> bits, with the bits shifted out of the range inserted at the bottom end of the range. <code><em>exint<sub>1</sub></em></code> is treated as if represented in two&#8217;s complement, even if it is not represented that way internally.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bitwise-rotate-bit-field #b00011010 0 5 3) ⇒ #b00010110
(bitwise-rotate-bit-field #b01101011 2 7 3) ⇒ #b01011011</code></pre>
</div>
</div>
<div id="objects:s146" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bitwise-reverse-bit-field <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em> <em>exint<sub>3</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic bitwise)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>exint<sub>2</sub></em></code> and <code><em>exint<sub>3</sub></em></code> must be nonnegative, and <code><em>exint<sub>2</sub></em></code> must not be greater than <code><em>exint<sub>3</sub></em></code>. This procedure returns the result of reversing the bits of <code><em>exint<sub>1</sub></em></code> from bit <code><em>exint<sub>2</sub></em></code> (inclusive) through bit <code><em>exint<sub>3</sub></em></code> (exclusive). <code><em>exint<sub>1</sub></em></code> is treated as if represented in two&#8217;s complement, even if it is not represented that way internally.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bitwise-reverse-bit-field #b00011010 0 5) ⇒ #b00001011
(bitwise-reverse-bit-field #b01101011 2 7) ⇒ #b00101111</code></pre>
</div>
</div>
<div id="objects:s147" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-&gt;number <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-&gt;number <em>string</em> <em>radix</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the number represented by <code><em>string</em></code>, or <code>#f</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>string</em></code> is a valid representation of a number, that number is returned, otherwise <code>#f</code> is returned. The number is interpreted in radix <code><em>radix</em></code>, which must be an exact integer in the set {2,8,10,16}. If not specified, <code><em>radix</em></code> defaults to 10. Any radix specifier within <code><em>string</em></code>, e.g., <code>#x</code>, overrides the <code><em>radix</em></code> argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(string->number "0") ⇒ 0
(string->number "3.4e3") ⇒ 3400.0
(string->number "#x#e-2e2") ⇒ -738
(string->number "#e-2e2" 16) ⇒ -738
(string->number "#i15/16") ⇒ 0.9375
(string->number "10" 16) ⇒ 16</code></pre>
</div>
</div>
<div id="objects:s148" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(number-&gt;string <em>num</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(number-&gt;string <em>num</em> <em>radix</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(number-&gt;string <em>num</em> <em>radix</em> <em>precision</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>an external representation of <code><em>num</em></code> as a string</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The num is expressed in radix <code><em>radix</em></code>, which must be an exact integer in the set {2,8,10,16}. If not specified, <code><em>radix</em></code> defaults to 10. In any case, no radix specifier appears in the resulting string.</p>
</div>
<div class="paragraph">
<p>The external representation is such that, when converted back into a number using <code>string-&gt;number</code>, the resulting numeric value is equivalent to <code><em>num</em></code>. That is, for all inputs:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(eqv? (string->number
        (number->string <em>num</em> <em>radix</em>)
        <em>radix</em>)
      <em>num</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>returns <code>#t</code>. An exception with condition type <code>&amp;implementation-restriction</code> is raised if this is not possible.</p>
</div>
<div class="paragraph">
<p>If <code><em>precision</em></code> is provided, it must be an exact positive integer, <code><em>num</em></code> must be inexact, and <code><em>radix</em></code> must be 10. In this case, the real part and, if present, the imaginary part of the number are each printed with an explicit mantissa width <code><em>m</em></code>, where <code><em>m</em></code> is the least possible value greater than or equal to <code><em>precision</em></code> that makes the expression above true.</p>
</div>
<div class="paragraph">
<p>If <code><em>radix</em></code> is 10, inexact values of <code><em>num</em></code> are expressed using the fewest number of significant digits possible <a href="#ref5">[5]</a> without violating the above restriction.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(number->string 3.4) ⇒ "3.4"
(number->string 1e2) ⇒ "100.0"
(number->string 1e-23) ⇒ "1e-23"
(number->string -7/2) ⇒ "-7/2"
(number->string 220/9 16) ⇒ "DC/9"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_6.5.">Section 6.5. Fixnums</h3>
<div class="paragraph">
<p><em>Fixnums</em> represent exact integers in the fixnum range, which is required to be a closed range \([-2^{w-1}, 2^{w-1} - 1]\), where <em>w</em> (the <em>fixnum width</em>) is at least 24. The implementation-specific value of <em>w</em> may be determined via the procedure <code>fixnum-width</code>, and the endpoints of the range may be determined via the procedures <code>least-fixnum</code> and <code>greatest-fixnum</code>.</p>
</div>
<div class="paragraph">
<p>The names of arithmetic procedures that operate only on fixnums begin with the prefix &#8220;fx&#8221; to set them apart from their generic counterparts.</p>
</div>
<div class="paragraph">
<p>Procedure arguments required to be fixnums are named <code><em>fx</em></code>, possibly with a suffix, e.g., <code><em>fx<sub>2</sub></em></code>.</p>
</div>
<div class="paragraph">
<p>Unless otherwise specified, the numeric values of fixnum-specific procedures are fixnums. If the value of a fixnum operation should be a fixnum, but the mathematical result would be outside the fixnum range, an exception with condition type <code>&amp;implementation-restriction</code> is raised.</p>
</div>
<div class="paragraph">
<p>Bit and shift operations on fixnums assume that fixnums are represented in two&#8217;s complement, even if they are not represented that way internally.</p>
</div>
<div id="objects:s150" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fixnum? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a fixnum, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fixnum? 0) ⇒ #t
(fixnum? -1) ⇒ #t
(fixnum? (- (expt 2 23))) ⇒ #t
(fixnum? (- (expt 2 23) 1)) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s151" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(least-fixnum)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the least (most negative) fixnum supported by the implementation</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(greatest-fixnum)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the greatest (most positive) fixnum supported by the implementation</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fixnum? (- (least-fixnum) 1)) ⇒ #f
(fixnum? (least-fixnum)) ⇒ #t
(fixnum? (greatest-fixnum)) ⇒ #t
(fixnum? (+ (greatest-fixnum) 1)) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s152" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fixnum-width)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the implementation-dependent <em>fixnum width</em></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As described in the lead-in to this section, the fixnum width determines the size of the fixnum range and must be at least 24.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define w (fixnum-width))
(= (least-fixnum) (- (expt 2 (- w 1)))) ⇒ #t
(= (greatest-fixnum) (- (expt 2 (- w 1)) 1)) ⇒ #t
(>= w 24) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s153" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fx=? <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fx&lt;? <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fx&gt;? <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fx&lt;=? <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fx&gt;=? <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the relation holds, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The predicate <code>fx=?</code> returns <code>#t</code> if its arguments are equal. The predicate <code>fx&lt;?</code> returns <code>#t</code> if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while <code>fx&gt;?</code> returns <code>#t</code> if its arguments are monotonically decreasing. The predicate <code>fx&lt;=?</code> returns <code>#t</code> if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while <code>fx&gt;=?</code> returns <code>#t</code> if its arguments are monotonically nonincreasing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fx=? 0 0) ⇒ #t
(fx=? -1 1) ⇒ #f
(fx<? (least-fixnum) 0 (greatest-fixnum)) ⇒ #t
(let ([x 3]) (fx<=? 0 x 9)) ⇒ #t
(fx>? 5 4 3 2 1) ⇒ #t
(fx<=? 1 3 2) ⇒ #f
(fx>=? 0 0 (least-fixnum)) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s154" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxzero? <em>fx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fx</em></code> is zero, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxpositive? <em>fx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fx</em></code> is greater than zero, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxnegative? <em>fx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fx</em></code> is less than zero, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>fxzero?</code> is equivalent to <code>(lambda (x) (fx=? x 0))</code>, <code>fxpositive?</code> is equivalent to <code>(lambda (x) (fx&gt;? x 0))</code>, and <code>fxnegative?</code> to <code>(lambda (x) (fx&lt;? x 0))</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxzero? 0) ⇒ #t
(fxzero? 1) ⇒ #f

(fxpositive? 128) ⇒ #t
(fxpositive? 0) ⇒ #f
(fxpositive? -1) ⇒ #f

(fxnegative? -65) ⇒ #t
(fxnegative? 0) ⇒ #f
(fxnegative? 1) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s155" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxeven? <em>fx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fx</em></code> is even, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxodd? <em>fx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fx</em></code> is odd, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxeven? 0) ⇒ #t
(fxeven? 1) ⇒ #f
(fxeven? -1) ⇒ #f
(fxeven? -10) ⇒ #t

(fxodd? 0) ⇒ #f
(fxodd? 1) ⇒ #t
(fxodd? -1) ⇒ #t
(fxodd? -10) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s156" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxmin <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the minimum of <code><em>fx<sub>1</sub></em></code> <code><em>fx<sub>2</sub></em></code> ...</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxmax <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the maximum of <code><em>fx<sub>1</sub></em></code> <code><em>fx<sub>2</sub></em></code> ...</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxmin 4 -7 2 0 -6) ⇒ -7

(let ([ls '(7 3 5 2 9 8)])
  (apply fxmin ls)) ⇒ 2

(fxmax 4 -7 2 0 -6) ⇒ 4

(let ([ls '(7 3 5 2 9 8)])
  (apply fxmax ls)) ⇒ 9</code></pre>
</div>
</div>
<div id="objects:s157" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fx+ <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the sum of <code><em>fx<sub>1</sub></em></code> and <code><em>fx<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fx+ -3 4) ⇒ 1</code></pre>
</div>
</div>
<div id="objects:s158" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fx- <em>fx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the additive inverse of <code><em>fx</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fx- <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the difference between <code><em>fx<sub>1</sub></em></code> and <code><em>fx<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fx- 3) ⇒ -3
(fx- -3 4) ⇒ -7</code></pre>
</div>
</div>
<div id="objects:s159" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fx* <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the product of <code><em>fx<sub>1</sub></em></code> and <code><em>fx<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fx* -3 4) ⇒ -12</code></pre>
</div>
</div>
<div id="objects:s160" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxdiv <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxmod <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxdiv-and-mod <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>fx<sub>2</sub></em></code> must not be zero. These are fixnum-specific versions of the generic <code>div</code>, <code>mod</code>, and <code>div-and-mod</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxdiv 17 3) ⇒ 5
(fxmod 17 3) ⇒ 2
(fxdiv -17 3) ⇒ -6
(fxmod -17 3) ⇒ 1
(fxdiv 17 -3) ⇒ -5
(fxmod 17 -3) ⇒ 2
(fxdiv -17 -3) ⇒ 6
(fxmod -17 -3) ⇒ 1

(fxdiv-and-mod 17 3) ⇒ 5
                        2</code></pre>
</div>
</div>
<div id="objects:s161" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxdiv0 <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxmod0 <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxdiv0-and-mod0 <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>fx<sub>2</sub></em></code> must not be zero. These are fixnum-specific versions of the generic <code>div0</code>, <code>mod0</code>, and <code>div0-and-mod0</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxdiv0 17 3) ⇒ 6
(fxmod0 17 3) ⇒ -1
(fxdiv0 -17 3) ⇒ -6
(fxmod0 -17 3) ⇒ 1
(fxdiv0 17 -3) ⇒ -6
(fxmod0 17 -3) ⇒ -1
(fxdiv0 -17 -3) ⇒ 6
(fxmod0 -17 -3) ⇒ 1

(fxdiv0-and-mod0 17 3) ⇒ 6
                          -1</code></pre>
</div>
</div>
<div id="objects:s162" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fx+/carry <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fx-/carry <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fx*/carry <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When an ordinary fixnum addition, subtraction, or multiplication operation overflows, an exception is raised. These alternative procedures instead return a carry and also allow the carry to be propagated to the next operation. They can be used to implement portable code for multiple-precision arithmetic.</p>
</div>
<div class="paragraph">
<p>These procedures return the two fixnum values of the following computations. For <code>fx+/carry</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let* ([s (+ <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)]
       [s0 (mod0 s (expt 2 (fixnum-width)))]
       [s1 (div0 s (expt 2 (fixnum-width)))])
  (values s0 s1))</code></pre>
</div>
</div>
<div class="paragraph">
<p>for <code>fx-/carry</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let* ([d (- <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)]
       [d0 (mod0 d (expt 2 (fixnum-width)))]
       [d1 (div0 d (expt 2 (fixnum-width)))])
  (values d0 d1))</code></pre>
</div>
</div>
<div class="paragraph">
<p>and for <code>fx*/carry</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let* ([s (+ (* <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>) <em>fx<sub>3</sub></em>)]
       [s0 (mod0 s (expt 2 (fixnum-width)))]
       [s1 (div0 s (expt 2 (fixnum-width)))])
  (values s0 s1))</code></pre>
</div>
</div>
<div id="objects:s163" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxnot <em>fx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the bitwise not of <code><em>fx</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxand <em>fx</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the bitwise and of <code><em>fx</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxior <em>fx</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the bitwise inclusive or of <code><em>fx</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxxor <em>fx</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the bitwise exclusive or of <code><em>fx</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxnot 0) ⇒ -1
(fxnot 3) ⇒ -4

(fxand #b01101 #b00111) ⇒ #b00101
(fxior #b01101 #b00111) ⇒ #b01111
(fxxor #b01101 #b00111) ⇒ #b01010</code></pre>
</div>
</div>
<div id="objects:s164" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxif <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the bitwise "if" of its arguments</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For each bit set in <code><em>fx<sub>1</sub></em></code>, the corresponding bit of the result is taken from <code><em>fx<sub>2</sub></em></code>, and for each bit not set in <code><em>fx<sub>1</sub></em></code>, the corresponding bit of the result is taken from <code><em>x<sub>3</sub></em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxif #b101010 #b111000 #b001100) ⇒ #b101100</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fxif</code> might be defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define fxif
  (lambda (fx1 fx2 fx3)
    (fxior (fxand fx1 fx2)
           (fxand (fxnot fx1) fx3))))</code></pre>
</div>
</div>
<div id="objects:s165" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxbit-count <em>fx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For nonnegative inputs, <code>fxbit-count</code> returns the number of bits set in the two&#8217;s complement representation of <code><em>fx</em></code>. For negative inputs, it returns a negative number whose magnitude is one greater than the number of bits not set in <code><em>fx</em></code>, which is equivalent to <code>(fxnot (fxbit-count (fxnot <em>fx</em>)))</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxbit-count #b00000) ⇒ 0
(fxbit-count #b00001) ⇒ 1
(fxbit-count #b00100) ⇒ 1
(fxbit-count #b10101) ⇒ 3

(fxbit-count -1) ⇒ -1
(fxbit-count -2) ⇒ -2
(fxbit-count -4) ⇒ -3</code></pre>
</div>
</div>
<div id="objects:s166" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxlength <em>fx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure returns the number of bits of the smallest two&#8217;s complement representation of <code><em>fx</em></code>, not including the sign bit for negative numbers. For 0 <code>fxlength</code> returns 0.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxlength #b00000) ⇒ 0
(fxlength #b00001) ⇒ 1
(fxlength #b00100) ⇒ 3
(fxlength #b00110) ⇒ 3

(fxlength -1) ⇒ 0
(fxlength -6) ⇒ 3
(fxlength -9) ⇒ 4</code></pre>
</div>
</div>
<div id="objects:s167" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxfirst-bit-set <em>fx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the index of the least significant bit set in <code><em>fx</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>fx</em></code> is 0, <code>fxfirst-bit-set</code> returns -1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxfirst-bit-set #b00000) ⇒ -1
(fxfirst-bit-set #b00001) ⇒ 0
(fxfirst-bit-set #b01100) ⇒ 2

(fxfirst-bit-set -1) ⇒ 0
(fxfirst-bit-set -2) ⇒ 1
(fxfirst-bit-set -3) ⇒ 0</code></pre>
</div>
</div>
<div id="objects:s168" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxbit-set? <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if bit <code><em>fx<sub>2</sub></em></code> of <code><em>fx<sub>1</sub></em></code> is set, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>fx<sub>2</sub></em></code> must be nonnegative. It is taken as a zero-based index for the bits in the two&#8217;s complement representation of <code><em>fx<sub>1</sub></em></code>, with the sign bit virtually replicated an infinite number of positions to the left.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxbit-set? #b01011 0) ⇒ #t
(fxbit-set? #b01011 2) ⇒ #f

(fxbit-set? -1 0) ⇒ #t
(fxbit-set? -1 20) ⇒ #t
(fxbit-set? -3 1) ⇒ #f
(fxbit-set? 0 (- (fixnum-width) 1)) ⇒ #f
(fxbit-set? -1 (- (fixnum-width) 1)) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s169" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxcopy-bit <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>fx<sub>1</sub></em></code> with bit <code><em>fx<sub>2</sub></em></code> replaced by <code><em>fx<sub>3</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>fx<sub>2</sub></em></code> must be nonnegative and less than the value of <code>(- (fixnum-width) 1)</code>. <code><em>fx<sub>3</sub></em></code> must be 0 or 1. This procedure effectively clears or sets the specified bit depending on the value of <code><em>fx<sub>3</sub></em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxcopy-bit #b01110 0 1) ⇒ #b01111
(fxcopy-bit #b01110 2 0) ⇒ #b01010</code></pre>
</div>
</div>
<div id="objects:s170" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxbit-field <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>fx<sub>2</sub></em></code> and <code><em>fx<sub>3</sub></em></code> must be nonnegative and less than the value of <code>(fixnum-width)</code>, and <code><em>fx<sub>2</sub></em></code> must not be greater than <code><em>fx<sub>3</sub></em></code>. This procedure returns the number represented by extracting from <code><em>fx<sub>1</sub></em></code> the sequence of bits from <code><em>fx<sub>2</sub></em></code> (inclusive) to <code><em>fx<sub>3</sub></em></code> (exclusive).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxbit-field #b10110 0 3) ⇒ #b00110
(fxbit-field #b10110 1 3) ⇒ #b00011
(fxbit-field #b10110 2 3) ⇒ #b00001
(fxbit-field #b10110 3 3) ⇒ #b00000</code></pre>
</div>
</div>
<div id="objects:s171" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxcopy-bit-field <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> <em>fx<sub>4</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>fx<sub>2</sub></em></code> and <code><em>fx<sub>3</sub></em></code> must be nonnegative and less than the value of <code>(fixnum-width)</code>, and <code><em>fx<sub>2</sub></em></code> must not be greater than <code><em>fx<sub>3</sub></em></code>. This procedure returns <code><em>fx<sub>1</sub></em></code> with <code><em>n</em></code> bits from <code><em>fx<sub>2</sub></em></code> (inclusive) to <code><em>fx<sub>3</sub></em></code> (exclusive) replaced by the low-order <code><em>n</em></code> bits of <code><em>x<sub>4</sub></em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxcopy-bit-field #b10000 0 3 #b10101) ⇒ #b10101
(fxcopy-bit-field #b10000 1 3 #b10101) ⇒ #b10010
(fxcopy-bit-field #b10000 2 3 #b10101) ⇒ #b10100
(fxcopy-bit-field #b10000 3 3 #b10101) ⇒ #b10000</code></pre>
</div>
</div>
<div id="objects:s172" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxarithmetic-shift-right <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>fx<sub>1</sub></em></code> arithmetically shifted right by <code><em>fx<sub>2</sub></em></code> bits</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxarithmetic-shift-left <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>fx<sub>1</sub></em></code> shifted left by <code><em>fx<sub>2</sub></em></code> bits</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>fx<sub>2</sub></em></code> must be nonnegative and less than the value of <code>(fixnum-width)</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxarithmetic-shift-right #b10000 3) ⇒ #b00010
(fxarithmetic-shift-right -1 1) ⇒ -1
(fxarithmetic-shift-right -64 3) ⇒ -8

(fxarithmetic-shift-left #b00010 2) ⇒ #b01000
(fxarithmetic-shift-left -1 2) ⇒ -4</code></pre>
</div>
</div>
<div id="objects:s173" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxarithmetic-shift <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The absolute value of <code><em>fx<sub>2</sub></em></code> must be less than the value of <code>(fixnum-width)</code>. If <code><em>fx<sub>2</sub></em></code> is negative, <code>fxarithmetic-shift</code> returns the result of arithmetically shifting <code><em>fx<sub>1</sub></em></code> right by <code><em>fx<sub>2</sub></em></code> bits. Otherwise, <code>fxarithmetic-shift</code> returns the result of shifting <code><em>fx<sub>1</sub></em></code> left by <code><em>fx<sub>2</sub></em></code> bits.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxarithmetic-shift #b10000 -3) ⇒ #b00010
(fxarithmetic-shift -1 -1) ⇒ -1
(fxarithmetic-shift -64 -3) ⇒ -8
(fxarithmetic-shift #b00010 2) ⇒ #b01000
(fxarithmetic-shift -1 2) ⇒ -4</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thus, <code>fxarithmetic-shift</code> behaves as if defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define fxarithmetic-shift
  (lambda (<em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)
    (if (fx&lt;? <em>fx<sub>2</sub></em> 0)
        (fxarithmetic-shift-right <em>fx<sub>1</sub></em> (fx- <em>fx<sub>2</sub></em>))
        (fxarithmetic-shift-left <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>))))</code></pre>
</div>
</div>
<div id="objects:s174" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxrotate-bit-field <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> <em>fx<sub>4</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>fx<sub>2</sub></em></code>, <code><em>fx<sub>3</sub></em></code>, and <code><em>fx<sub>4</sub></em></code> must be nonnegative and less than the value of <code>(fixnum-width)</code>, <code><em>fx<sub>2</sub></em></code> must not be greater than <code><em>fx<sub>3</sub></em></code>, and <code><em>fx<sub>4</sub></em></code> must not be greater than the difference between <code><em>fx<sub>3</sub></em></code> and <code><em>fx<sub>2</sub></em></code>.</p>
</div>
<div class="paragraph">
<p>This procedure returns the result of shifting the bits of <code><em>fx<sub>1</sub></em></code> from bit <code><em>fx<sub>2</sub></em></code> (inclusive) through bit <code><em>fx<sub>3</sub></em></code> (exclusive) left by <code><em>fx<sub>4</sub></em></code> bits, with the bits shifted out of the range inserted at the bottom end of the range.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxrotate-bit-field #b00011010 0 5 3) ⇒ #b00010110
(fxrotate-bit-field #b01101011 2 7 3) ⇒ #b01011011</code></pre>
</div>
</div>
<div id="objects:s175" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fxreverse-bit-field <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic fixnums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>fx<sub>2</sub></em></code> and <code><em>fx<sub>3</sub></em></code> must be nonnegative and less than the value of <code>(fixnum-width)</code>, and <code><em>fx<sub>2</sub></em></code> must not be greater than <code><em>fx<sub>3</sub></em></code>. This procedure returns the result of reversing the bits of <code><em>fx<sub>1</sub></em></code> from bit <code><em>fx<sub>2</sub></em></code> (inclusive) through bit <code><em>fx<sub>3</sub></em></code> (exclusive).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fxreverse-bit-field #b00011010 0 5) ⇒ #b00001011
(fxreverse-bit-field #b01101011 2 7) ⇒ #b00101111</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_6.6.">Section 6.6. Flonums</h3>
<div id="objects:s176" class="paragraph">
<p><em>Flonums</em> represent inexact real numbers. Implementations are required to represent as a flonum any inexact real number whose lexical syntax contains no vertical bar and no exponent marker other than <code>e</code>, but are not required to represent any other inexact real number as a flonum.</p>
</div>
<div class="paragraph">
<p>Implementations typically use the IEEE double-precision floating-point representation for flonums, but implementations are not required to do so or even to use a floating-point representation of any sort, despite the name "flonum."</p>
</div>
<div class="paragraph">
<p>This section describes operations on flonums. Flonum-specific procedure names begin with the prefix &#8220;fl&#8221; to set them apart from their generic counterparts.</p>
</div>
<div class="paragraph">
<p>Procedure arguments required to be flonums are named <code><em>fl</em></code>, possibly with suffix, e.g., <code><em>fl<sub>2</sub></em></code>. Unless otherwise specified, the numeric values of flonum-specific procedures are flonums.</p>
</div>
<div id="objects:s177" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flonum? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a flonum, otherwise <code>#f</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(flonum? 0) ⇒ #f
(flonum? 3/4) ⇒ #f
(flonum? 3.5) ⇒ #t
(flonum? .02) ⇒ #t
(flonum? 1e10) ⇒ #t
(flonum? 3.0+0.0i) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s178" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fl=? <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fl&lt;? <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fl&gt;? <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fl&lt;=? <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fl&gt;=? <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the relation holds, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The predicate <code>fl=?</code> returns <code>#t</code> if its arguments are equal. The predicate <code>fl&lt;?</code> returns <code>#t</code> if its arguments are monotonically increasing, i.e., each argument is greater than the preceding ones, while <code>fl&gt;?</code> returns <code>#t</code> if its arguments are monotonically decreasing. The predicate <code>fl&lt;=?</code> returns <code>#t</code> if its arguments are monotonically nondecreasing, i.e., each argument is not less than the preceding ones, while <code>fl&gt;=?</code> returns <code>#t</code> if its arguments are monotonically nonincreasing. When passed only one argument, each of these predicates returns <code>#t</code>.</p>
</div>
<div class="paragraph">
<p>Comparisons involving NaNs always return <code>#f</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fl=? 0.0 0.0) ⇒ #t
(fl&lt;? -1.0 0.0 1.0) ⇒ #t
(fl>? -1.0 0.0 1.0) ⇒ #f
(fl<=? 0.0 3.0 3.0) ⇒ #t
(fl>=? 4.0 3.0 3.0) ⇒ #t
(fl&lt;? 7.0 +inf.0) ⇒ #t
(fl=? +nan.0 0.0) ⇒ #f
(fl=? +nan.0 +nan.0) ⇒ #f
(fl&lt;? +nan.0 +nan.0) ⇒ #f
(fl<=? +nan.0 +inf.0) ⇒ #f
(fl>=? +nan.0 +inf.0) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s179" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flzero? <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fl</em></code> is zero, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flpositive? <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fl</em></code> is greater than zero, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flnegative? <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fl</em></code> is less than zero, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>flzero?</code> is equivalent to <code>(lambda (x) (fl=? x 0.0))</code>, <code>flpositive?</code> is equivalent to <code>(lambda (x) (fl&gt;? x 0.0))</code>, and <code>flnegative?</code> to <code>(lambda (x) (fl&lt;? x 0.0))</code>.</p>
</div>
<div class="paragraph">
<p>Even if the flonum representation distinguishes -0.0 from +0.0, -0.0 is considered both zero and nonnegative.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(flzero? 0.0) ⇒ #t
(flzero? 1.0) ⇒ #f

(flpositive? 128.0) ⇒ #t
(flpositive? 0.0) ⇒ #f
(flpositive? -1.0) ⇒ #f

(flnegative? -65.0) ⇒ #t
(flnegative? 0.0) ⇒ #f
(flnegative? 1.0) ⇒ #f

(flzero? -0.0) ⇒ #t
(flnegative? -0.0) ⇒ #f

(flnegative? +nan.0) ⇒ #f
(flzero? +nan.0) ⇒ #f
(flpositive? +nan.0) ⇒ #f

(flnegative? +inf.0) ⇒ #f
(flnegative? -inf.0) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s180" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flinteger? <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fl</em></code> is integer, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(flinteger? 0.0) ⇒ #t
(flinteger? -17.0) ⇒ #t
(flinteger? +nan.0) ⇒ #f
(flinteger? +inf.0) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s181" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flfinite? <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fl</em></code> is finite, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flinfinite? <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fl</em></code> is infinite, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flnan? <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fl</em></code> is a NaN, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(flfinite? 3.1415) ⇒ #t
(flinfinite? 3.1415) ⇒ #f
(flnan? 3.1415) ⇒ #f

(flfinite? +inf.0) ⇒ #f
(flinfinite? -inf.0) ⇒ #t
(flnan? -inf.0) ⇒ #f

(flfinite? +nan.0) ⇒ #f
(flinfinite? +nan.0) ⇒ #f
(flnan? +nan.0) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s182" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fleven? <em>fl-int</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fl-int</em></code> is even, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flodd? <em>fl-int</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>fl-int</em></code> is odd, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>fl-int</em></code> must be an integer-valued flonum.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fleven? 0.0) ⇒ #t
(fleven? 1.0) ⇒ #f
(fleven? -1.0) ⇒ #f
(fleven? -10.0) ⇒ #t

(flodd? 0.0) ⇒ #f
(flodd? 1.0) ⇒ #t
(flodd? -1.0) ⇒ #t
(flodd? -10.0) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s183" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flmin <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the minimum of <code><em>fl<sub>1</sub></em></code> <code><em>fl<sub>2</sub></em></code> ...</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flmax <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the maximum of <code><em>fl<sub>1</sub></em></code> <code><em>fl<sub>2</sub></em></code> ...</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(flmin 4.2 -7.5 2.0 0.0 -6.4) ⇒ -7.5

(let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])
  (apply flmin ls)) ⇒ 2.6

(flmax 4.2 -7.5 2.0 0.0 -6.4) ⇒ 4.2

(let ([ls '(7.1 3.5 5.0 2.6 2.6 8.0)])
  (apply flmax ls)) ⇒ 8.0</code></pre>
</div>
</div>
<div id="objects:s184" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fl+ <em>fl</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the sum of the arguments <code><em>fl</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When called with no arguments, <code>fl+</code> returns <code>0.0</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fl+) ⇒ 0.0
(fl+ 1.0 2.5) ⇒ 3.25
(fl+ 3.0 4.25 5.0) ⇒ 12.25
(apply fl+ '(1.0 2.0 3.0 4.0 5.0)) ⇒ 15.0</code></pre>
</div>
</div>
<div id="objects:s185" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fl- <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the additive inverse of <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fl- <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the difference between <code><em>fl<sub>1</sub></em></code> and the sum of <code><em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With an IEEE floating-point representation of flonums, the single-argument <code>fl-</code> is equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (x) (fl* -1.0 x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (x) (fl- -0.0 x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>but not</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (x) (fl- 0.0 x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>since the latter returns <code>0.0</code> rather than <code>-0.0</code> for <code>0.0</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fl- 0.0) ⇒ -0.0
(fl- 3.0) ⇒ -3.0
(fl- 4.0 3.0) ⇒ 1.0
(fl- 4.0 3.0 2.0 1.0) ⇒ -2.0</code></pre>
</div>
</div>
<div id="objects:s186" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fl* <em>fl</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the product of the arguments <code><em>fl</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When called with no arguments, <code>fl*</code> returns <code>1.0</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fl*) ⇒ 1.0
(fl* 1.5 2.5) ⇒ 3.75
(fl* 3.0 -4.0 5.0) ⇒ -60.0
(apply fl* '(1.0 -2.0 3.0 -4.0 5.0)) ⇒ 120.0</code></pre>
</div>
</div>
<div id="objects:s187" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fl/ <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the multiplicative inverse of <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fl/ <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the result of dividing <code><em>fl<sub>1</sub></em></code> by the product of <code><em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fl/ -4.0) ⇒ -0.25
(fl/ 8.0 -2.0) ⇒ -4.0
(fl/ -9.0 2.0) ⇒ -4.5
(fl/ 60.0 5.0 3.0 2.0) ⇒ 2.0</code></pre>
</div>
</div>
<div id="objects:s188" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fldiv <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flmod <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fldiv-and-mod <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These are flonum-specific versions of the generic <code>div</code>, <code>mod</code>, and <code>div-and-mod</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fldiv 17.0 3.0) ⇒ 5.0
(flmod 17.0 3.0) ⇒ 2.0
(fldiv -17.0 3.0) ⇒ -6.0
(flmod -17.0 3.0) ⇒ 1.0
(fldiv 17.0 -3.0) ⇒ -5.0
(flmod 17.0 -3.0) ⇒ 2.0
(fldiv -17.0 -3.0) ⇒ 6.0
(flmod -17.0 -3.0) ⇒ 1.0

(fldiv-and-mod 17.5 3.75) ⇒ 4.0
                             2.5</code></pre>
</div>
</div>
<div id="objects:s189" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fldiv0 <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flmod0 <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fldiv0-and-mod0 <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These are flonum-specific versions of the generic <code>div0</code>, <code>mod0</code>, and <code>div0-and-mod0</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fldiv0 17.0 3.0) ⇒ 6.0
(flmod0 17.0 3.0) ⇒ -1.0
(fldiv0 -17.0 3.0) ⇒ -6.0
(flmod0 -17.0 3.0) ⇒ 1.0
(fldiv0 17.0 -3.0) ⇒ -6.0
(flmod0 17.0 -3.0) ⇒ -1.0
(fldiv0 -17.0 -3.0) ⇒ 6.0
(flmod0 -17.0 -3.0) ⇒ 1.0

(fldiv0-and-mod0 17.5 3.75) ⇒ 5.0
                               -1.25</code></pre>
</div>
</div>
<div id="objects:s190" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flround <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the integer closest to <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fltruncate <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the integer closest to <code><em>fl</em></code> toward zero</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flfloor <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the integer closest to <code><em>fl</em></code> toward \(-\infty\)</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flceiling <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the integer closest to <code><em>fl</em></code> toward \(+\infty\)</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>fl</em></code> is an integer, NaN, or infinity, each of these procedures returns <code><em>fl</em></code>. If <code><em>fl</em></code> is exactly between two integers, <code>flround</code> returns the closest even integer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(flround 17.3) ⇒ 17.0
(flround -17.3) ⇒ -17.0
(flround 2.5) ⇒ 2.0
(flround 3.5) ⇒ 4.0

(fltruncate 17.3) ⇒ 17.0
(fltruncate -17.3) ⇒ -17.0

(flfloor 17.3) ⇒ 17.0
(flfloor -17.3) ⇒ -18.0

(flceiling 17.3) ⇒ 18.0
(flceiling -17.3) ⇒ -17.0</code></pre>
</div>
</div>
<div id="objects:s191" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flnumerator <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the numerator of <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fldenominator <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the denominator of <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>fl</em></code> is an integer, including 0.0, or infinity, the numerator is <code><em>fl</em></code> and the denominator is 1.0.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(flnumerator -9.0) ⇒ -9.0
(fldenominator -9.0) ⇒ 1.0
(flnumerator 0.0) ⇒ 0.0
(fldenominator 0.0) ⇒ 1.0
(flnumerator -inf.0) ⇒ -inf.0
(fldenominator -inf.0) ⇒ 1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following hold for IEEE floats, but not necessarily other flonum representations.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(flnumerator 3.5) ⇒ 7.0
(fldenominator 3.5) ⇒ 2.0</code></pre>
</div>
</div>
<div id="objects:s192" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flabs <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>absolute value of <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(flabs 3.2) ⇒ 3.2
(flabs -2e-20) ⇒ 2e-20</code></pre>
</div>
</div>
<div id="objects:s193" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flexp <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><em>e</em> to the <code><em>fl</em></code> power</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fllog <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the natural logarithm of <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fllog <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the base-<code><em>fl<sub>2</sub></em></code> logarithm of <code><em>fl<sub>1</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(flexp 0.0) ⇒ 1.0
(flexp 1.0) ⇒ 2.7182818284590455

(fllog 1.0) ⇒ 0.0
(fllog (exp 1.0)) ⇒ 1.0
(fl/ (fllog 100.0) (fllog 10.0)) ⇒ 2.0

(fllog 100.0 10.0) ⇒ 2.0
(fllog .125 2.0) ⇒ -3.0</code></pre>
</div>
</div>
<div id="objects:s194" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flsin <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the sine of <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flcos <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the cosine of <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fltan <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the tangent of <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="objects:s195" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flasin <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the arc sine of <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flacos <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the arc cosine of <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flatan <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the arc tangent of <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flatan <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the arc tangent of <code><em>fl<sub>1</sub></em></code>/<code><em>fl<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="objects:s196" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flsqrt <em>fl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the principal square root of <code><em>fl</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Returns the principal square root of <code><em>fl</em></code>. The square root of -0.0 should be -0.0. The result for other negative numbers may be a NaN or some other unspecified flonum.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(flsqrt 4.0) ⇒ 2.0
(flsqrt 0.0) ⇒ 0.0
(flsqrt -0.0) ⇒ -0.0</code></pre>
</div>
</div>
<div id="objects:s197" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flexpt <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>fl<sub>1</sub></em></code> raised to the <code><em>fl<sub>2</sub></em></code> power</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>fl<sub>1</sub></em></code> is negative and <code><em>fl<sub>2</sub></em></code> is not an integer, the result may be a NaN or some other unspecified flonum. If <code><em>fl<sub>1</sub></em></code> and <code><em>fl<sub>2</sub></em></code> are both zero, the result is 1.0. If <code><em>fl<sub>1</sub></em></code> is zero and <code><em>fl<sub>2</sub></em></code> is positive, the result is zero. In other cases where <code><em>fl<sub>1</sub></em></code> is zero, the result may be a NaN or some other unspecified flonum.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(flexpt 3.0 2.0) ⇒ 9.0
(flexpt 0.0 +inf.0) ⇒ 0.0</code></pre>
</div>
</div>
<div id="objects:s198" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(fixnum-&gt;flonum <em>fx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the flonum representation closest to <code><em>fx</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(real-&gt;flonum <em>real</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the flonum representation closest to <code><em>real</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>fixnum-&gt;flonum</code> is a restricted variant of <code>inexact</code>. <code>real-&gt;flonum</code> is a restricted variant of <code>inexact</code> when the input is an exact real; when it is an inexact non-flonum real, it coverts the inexact non-flonum real into the closest flonum.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fixnum->flonum 0) ⇒ 0.0
(fixnum->flonum 13) ⇒ 13.0

(real->flonum -1/2) ⇒ -0.5
(real->flonum 1s3) ⇒ 1000.0</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_6.7.">Section 6.7. Characters</h3>
<div id="objects:s199" class="paragraph">
<p>Characters are atomic objects representing letters, digits, special symbols such as <code>$</code> or <code>-</code>, and certain nongraphic control characters such as space and newline. Characters are written with a <code>#\</code> prefix. For most characters, the prefix is followed by the character itself. The written character representation of the letter <code>A</code>, for example, is <code>#\A</code>. The characters newline, space, and tab may be written in this manner as well, but they can be written more clearly as <code>#\newline</code>, <code>#\space</code>, and <code>#\tab</code>. Other character names are supported as well, as defined by the grammar for character objects on <a href="#grammar:characters">page 457</a>. Any Unicode character may be written with the syntax <code>#\x<em>n</em></code>, where <code><em>n</em></code> consists of one or more hexadecimal digits and represents a valid Unicode scalar value.</p>
</div>
<div class="paragraph">
<p>This section describes the operations that deal primarily with characters. See also the following section on strings and <a href="#chp_input_and_output">Chapter 7</a> on input and output for other operations relating to characters.</p>
</div>
<div id="objects:s201" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char=? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char&lt;? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char&gt;? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char&lt;=? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char&gt;=? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the relation holds, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These predicates behave in a similar manner to the numeric predicates <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>. For example, <code>char=?</code> returns <code>#t</code> when its arguments are equivalent characters, and <code>char&lt;?</code> returns <code>#t</code> when its arguments are monotonically increasing character (Unicode scalar) values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(char>? #\a #\b) ⇒ #f
(char&lt;? #\a #\b) ⇒ #t
(char&lt;? #\a #\b #\c) ⇒ #t
(let ([c #\r])
  (char<=? #\a c #\z)) ⇒ #t
(char<=? #\Z #\W) ⇒ #f
(char=? #\+ #\+) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s202" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-ci=? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-ci&lt;? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-ci&gt;? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-ci&lt;=? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-ci&gt;=? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the relation holds, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs unicode)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These predicates are identical to the predicates <code>char=?</code>, <code>char&lt;?</code>, <code>char&gt;?</code>, <code>char&lt;=?</code>, and <code>char&gt;=?</code> except that they are case-insensitive, i.e., compare the case-folded versions of their arguments. For example, <code>char=?</code> considers <code>#\a</code> and <code>#\A</code> to be distinct values; <code>char-ci=?</code> does not.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(char-ci&lt;? #\a #\B) ⇒ #t
(char-ci=? #\W #\w) ⇒ #t
(char-ci=? #\= #\+) ⇒ #f
(let ([c #\R])
  (list (char<=? #\a c #\z)
        (char-ci<=? #\a c #\z))) ⇒ (#f #t)</code></pre>
</div>
</div>
<div id="objects:s203" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-alphabetic? <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>char</em></code> is a letter, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-numeric? <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>char</em></code> is a digit, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-whitespace? <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>char</em></code> is whitespace, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs unicode)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A character is alphabetic if it has the Unicode "Alphabetic" property, numeric if it has the Unicode "Numeric" property, and whitespace if has the Unicode "White_Space" property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(char-alphabetic? #\a) ⇒ #t
(char-alphabetic? #\T) ⇒ #t
(char-alphabetic? #\8) ⇒ #f
(char-alphabetic? #\$) ⇒ #f

(char-numeric? #\7) ⇒ #t
(char-numeric? #\2) ⇒ #t
(char-numeric? #\X) ⇒ #f
(char-numeric? #\space) ⇒ #f

(char-whitespace? #\space) ⇒ #t
(char-whitespace? #\newline) ⇒ #t
(char-whitespace? #\Z) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s204" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-lower-case? <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>char</em></code> is lower case, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-upper-case? <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>char</em></code> is upper case, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-title-case? <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>char</em></code> is title case, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs unicode)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A character is upper-case if it has the Unicode "Uppercase" property, lower-case if it has the "Lowercase" property, and title-case if it is in the Lt general category.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(char-lower-case? #\r) ⇒ #t
(char-lower-case? #\R) ⇒ #f

(char-upper-case? #\r) ⇒ #f
(char-upper-case? #\R) ⇒ #t

(char-title-case? #\I) ⇒ #f
(char-title-case? #\x01C5) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s205" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-general-category <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a symbol representing the Unicode general category of <code><em>char</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs unicode)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The return value is one of the symbols <code>Lu</code>, <code>Ll</code>, <code>Lt</code>, <code>Lm</code>, <code>Lo</code>, <code>Mn</code>, <code>Mc</code>, <code>Me</code>, <code>Nd</code>, <code>Nl</code>, <code>No</code>, <code>Ps</code>, <code>Pe</code>, <code>Pi</code>, <code>Pf</code>, <code>Pd</code>, <code>Pc</code>, <code>Po</code>, <code>Sc</code>, <code>Sm</code>, <code>Sk</code>, <code>So</code>, <code>Zs</code>, <code>Zp</code>, <code>Zl</code>, <code>Cc</code>, <code>Cf</code>, <code>Cs</code>, <code>Co</code>, or <code>Cn</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(char-general-category #\a) ⇒ Ll
(char-general-category #\space) ⇒ Zs
(char-general-category #\x10FFFF) ⇒ Cn</code></pre>
</div>
</div>
<div id="objects:s206" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-upcase <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the upper-case character counterpart of <code><em>char</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs unicode)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>char</em></code> is a lower- or title-case character and has a single upper-case counterpart, <code>char-upcase</code> returns the upper-case counterpart. Otherwise <code>char-upcase</code> returns <code><em>char</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(char-upcase #\g) ⇒ #\G
(char-upcase #\G) ⇒ #\G
(char-upcase #\7) ⇒ #\7
(char-upcase #\&sigmaf;) ⇒ #\&Sigma;</code></pre>
</div>
</div>
<div id="objects:s207" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-downcase <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the lower-case character equivalent of <code><em>char</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs unicode)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>char</em></code> is an upper- or title-case character and has a single lower-case counterpart, <code>char-downcase</code> returns the lower-case counterpart. Otherwise <code>char-downcase</code> returns <code><em>char</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(char-downcase #\g) ⇒ #\g
(char-downcase #\G) ⇒ #\g
(char-downcase #\7) ⇒ #\7
(char-downcase #\&sigmaf;) ⇒ #\&sigmaf;</code></pre>
</div>
</div>
<div id="objects:s208" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-titlecase <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the title-case character equivalent of <code><em>char</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs unicode)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>char</em></code> is an upper- or lower-case character and has a single title-case counterpart, <code>char-titlecase</code> returns the title-case counterpart. Otherwise, if it is not a title-case character, has no single title-case counterpart, but does have a single upper-case counterpart, <code>char-titlecase</code> returns the upper-case counterpart. Otherwise <code>char-titlecase</code> returns <code><em>char</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(char-titlecase #\g) ⇒ #\G
(char-titlecase #\G) ⇒ #\G
(char-titlecase #\7) ⇒ #\7
(char-titlecase #\&sigmaf;) ⇒ #\&Sigma;</code></pre>
</div>
</div>
<div id="objects:s209" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-foldcase <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the case-folded character equivalent of <code><em>char</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs unicode)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>char</em></code> has a case-folded counterpart, <code>char-foldcase</code> returns the case-folded counterpart. Otherwise, <code>char-foldcase</code> returns <code><em>char</em></code>. For most characters, <code>(char-foldcase <em>char</em>)</code> is equivalent to <code>(char-downcase (char-upcase <em>char</em>))</code>, but for Turkic İ and ı, <code>char-foldcase</code> acts as the identity.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(char-foldcase #\g) ⇒ #\g
(char-foldcase #\G) ⇒ #\g
(char-foldcase #\7) ⇒ #\7
(char-foldcase #\&sigmaf;) ⇒ #\&sigma;</code></pre>
</div>
</div>
<div id="objects:s210" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(char-&gt;integer <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the Unicode scalar value of <code><em>char</em></code> as an exact integer</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(char->integer #\newline) ⇒ 10
(char->integer #\space) ⇒ 32
(- (char->integer #\Z) (char->integer #\A)) ⇒ 25</code></pre>
</div>
</div>
<div id="objects:s211" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(integer-&gt;char <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the character corresponding to the Unicode scalar value <code><em>n</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact integer and a valid Unicode scalar value, i.e., \(0 \le n \le \#xD7FF\) or \(\#xE000 \le n \le 10FFFF\).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(integer->char 48) ⇒ #\0
(integer->char #x3BB) ⇒ #\&lambda;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_6.8.">Section 6.8. Strings</h3>
<div id="objects:s212" class="paragraph">
<p>Strings are sequences of characters and are often used as messages, character buffers, or containers for blocks of text. Scheme provides operations for creating strings, extracting characters from strings, obtaining substrings, concatenating strings, and altering the contents of strings.</p>
</div>
<div class="paragraph">
<p>A string is written as a sequence of characters enclosed in double quotes, e.g., <code>"hi there"</code>. A double quote may be introduced into a string by preceding it by a backward slash, e.g., <code>"two \"quotes\" within"</code>. A backward slash may also be included by preceding it with a backward slash, e.g., <code>"a \\slash"</code>. Various special characters can be inserted with other two-character sequences, e.g., <code>\n</code> for newline, <code>\r</code> for carriage return, and <code>\t</code> for tab. Any Unicode character may be inserted with the syntax <code>#\x<em>n</em>;</code>, where <code><em>n</em></code> consists of one or more hexadecimal digits and represents a valid Unicode scalar value. A grammar defining the precise syntax of strings is given on <a href="#grammar:strings">page 458</a>.</p>
</div>
<div class="paragraph">
<p>Strings are indexed by exact nonnegative integers, and the index of the first element of any string is 0. The highest valid index for a given string is one less than its length.</p>
</div>
<div id="objects:s215" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string=? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string&lt;? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string&gt;? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string&lt;=? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string&gt;=? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the relation holds, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As with <code>=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>, these predicates express relationships among all of the arguments. For example, <code>string&gt;?</code> determines if the lexicographic ordering of its arguments is monotonically decreasing.</p>
</div>
<div class="paragraph">
<p>The comparisons are based on the character predicates <code>char=?</code> and <code>char&lt;?</code>. Two strings are lexicographically equivalent if they are the same length and consist of the same sequence of characters according to <code>char=?</code>. If two strings differ only in length, the shorter string is considered to be lexicographically less than the longer string. Otherwise, the first character position at which the strings differ (by <code>char=?</code>) determines which string is lexicographically less than the other, according to <code>char&lt;?</code>.</p>
</div>
<div class="paragraph">
<p>Two-argument <code>string=?</code> may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define string=?
  (lambda (s1 s2)
    (let ([n (string-length s1)])
      (and (= (string-length s2) n)
           (let loop ([i 0])
             (or (= i n)
                 (and (char=? (string-ref s1 i) (string-ref s2 i))
                      (loop (+ i 1)))))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Two-argument <code>string&lt;?</code> may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define string&lt;?
  (lambda (s1 s2)
    (let ([n1 (string-length s1)] [n2 (string-length s2)])
      (let loop ([i 0])
        (and (not (= i n2))
             (or (= i n1)
                 (let ([c1 (string-ref s1 i)] [c2 (string-ref s2 i)])
                   (or (char&lt;? c1 c2)
                       (and (char=? c1 c2)
                            (loop (+ i 1)))))))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>These definitions may be extended straightforwardly to support three or more arguments. <code>string&lt;=?</code>, <code>string&gt;?</code>, and <code>string&gt;=?</code> may be defined similarly.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(string=? "mom" "mom") ⇒ #t
(string&lt;? "mom" "mommy") ⇒ #t
(string>? "Dad" "Dad") ⇒ #f
(string=? "Mom and Dad" "mom and dad") ⇒ #f
(string&lt;? "a" "b" "c") ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s216" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-ci=? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-ci&lt;? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-ci&gt;? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-ci&lt;=? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-ci&gt;=? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the relation holds, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs unicode)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These predicates are identical to <code>string=?</code>, <code>string&lt;?</code>, <code>string&gt;?</code>, <code>string&lt;=?</code>, and <code>string&gt;=?</code> except that they are case-insensitive, i.e., compare the case-folded versions of their arguments.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(string-ci=? "Mom and Dad" "mom and dad") ⇒ #t
(string-ci<=? "say what" "Say What!?") ⇒ #t
(string-ci>? "N" "m" "L" "k") ⇒ #t
(string-ci=? "Straße" "Strasse") ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s217" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string <em>char</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a string containing the characters <code><em>char</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(string) ⇒ ""
(string #\a #\b #\c) ⇒ "abc"
(string #\H #\E #\Y #\!) ⇒ "HEY!"</code></pre>
</div>
</div>
<div id="objects:s218" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-string <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-string <em>n</em> <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a string of length <code><em>n</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer. If <code><em>char</em></code> is supplied, the string is filled with <code><em>n</em></code> occurrences of <code><em>char</em></code>, otherwise the characters contained in the string are unspecified.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(make-string 0) ⇒ ""
(make-string 0 #\x) ⇒ ""
(make-string 5 #\x) ⇒ "xxxxx"</code></pre>
</div>
</div>
<div id="objects:s219" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-length <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the number of characters in <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The length of a string is always an exact nonnegative integer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(string-length "abc") ⇒ 3
(string-length "") ⇒ 0
(string-length "hi there") ⇒ 8
(string-length (make-string 1000000)) ⇒ 1000000</code></pre>
</div>
</div>
<div id="objects:s220" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-ref <em>string</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the <code><em>n</em></code>th character (zero-based) of <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer less than the length of <code><em>string</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(string-ref "hi there" 0) ⇒ #\h
(string-ref "hi there" 5) ⇒ #\e</code></pre>
</div>
</div>
<div id="objects:s221" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-set! <em>string</em> <em>n</em> <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs mutable-strings)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer less than the length of <code><em>string</em></code>. <code>string-set!</code> changes the <code><em>n</em></code>th element of <code><em>string</em></code> to <code><em>char</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([str (string-copy "hi three")])
  (string-set! str 5 #\e)
  (string-set! str 6 #\r)
  str) ⇒ "hi there"</code></pre>
</div>
</div>
<div id="objects:s222" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-copy <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new copy of <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure creates a new string with the same length and contents as <code><em>string</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(string-copy "abc") ⇒ "abc"

(let ([str "abc"])
  (eq? str (string-copy str))) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s223" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-append <em>string</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new string formed by concatenating the strings <code><em>string</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(string-append) ⇒ ""
(string-append "abc" "def") ⇒ "abcdef"
(string-append "Hey " "you " "there!") ⇒ "Hey you there!"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following implementation of <code>string-append</code> recurs down the list of strings to compute the total length, then allocates the new string, then fills it up as it unwinds the recursion.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define string-append
  (lambda args
    (let f ([ls args] [n 0])
      (if (null? ls)
          (make-string n)
          (let* ([s1 (car ls)]
                 [m (string-length s1)]
                 [s2 (f (cdr ls) (+ n m))])
            (do ([i 0 (+ i 1)] [j n (+ j 1)])
                ((= i m) s2)
              (string-set! s2 j (string-ref s1 i))))))))</code></pre>
</div>
</div>
<div id="objects:s224" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(substring <em>string</em> <em>start</em> <em>end</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a copy of <code><em>string</em></code> from <code><em>start</em></code> (inclusive) to <code><em>end</em></code> (exclusive)</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>start</em></code> and <code><em>end</em></code> must be exact nonnegative integers; <code><em>start</em></code> must be less than or equal to <code><em>end</em></code>, while <code><em>end</em></code> must be less than or equal to the length of <code><em>string</em></code>. If <code><em>end</em></code> = <code><em>start</em></code>, a string of length zero is returned. <code>substring</code> may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define substring
  (lambda (s1 m n)
    (let ([s2 (make-string (- n m))])
      (do ([j 0 (+ j 1)] [i m (+ i 1)])
          ((= i n) s2)
        (string-set! s2 j (string-ref s1 i))))))

(substring "hi there" 0 1) ⇒ "h"
(substring "hi there" 3 6) ⇒ "the"
(substring "hi there" 5 5) ⇒ ""

(let ([str "hi there"])
  (let ([end (string-length str)])
    (substring str 0 end))) ⇒ "hi there"</code></pre>
</div>
</div>
<div id="objects:s225" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-fill! <em>string</em> <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs mutable-strings)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>string-fill!</code> sets every character in <code><em>string</em></code> to <code><em>char</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([str (string-copy "sleepy")])
  (string-fill! str #\Z)
  str) ⇒ "ZZZZZZ"</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>string-fill!</code> might be defined as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define string-fill!
  (lambda (s c)
    (let ([n (string-length s)])
      (do ([i 0 (+ i 1)])
          ((= i n))
          (string-set! s i c)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>An alternative definition is given on <a href="#backdoor-string-fill">page 276</a>.</p>
</div>
<div id="objects:s226" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-upcase <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the upper-case equivalent of <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-downcase <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the lower-case equivalent of <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-foldcase <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the case-folded equivalent of <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-titlecase <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the title-case equivalent of <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs unicode)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These procedures implement Unicode&#8217;s locale-independent case mappings from scalar-value sequences to scalar-value sequences. These mappings do not always map single characters to single characters, so the length of the result string may differ from the length of <code><em>string</em></code>. If the result string is the same as <code><em>string</em></code> (by <code>string=?</code>), <code><em>string</em></code> or a copy of <code><em>string</em></code> may be returned. Otherwise, the result string is newly allocated. <code>string-foldcase</code> does not use the special mappings for Turkic languages.</p>
</div>
<div class="paragraph">
<p><code>string-titlecase</code> converts the first cased character of each word in <code><em>string</em></code> to its title-case counterpart and converts each other character to its lower-case counterpart. Word breaks are recognized as specified in Unicode Standard Annex #29 <a href="#ref8">[8]</a>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(string-upcase "Hi") ⇒ "HI"
(string-downcase "Hi") ⇒ "hi"
(string-foldcase "Hi") ⇒ "hi"

(string-upcase "Straße") ⇒ "STRASSE"
(string-downcase "Straße") ⇒ "straße"
(string-foldcase "Straße") ⇒ "strasse"
(string-downcase "STRASSE")  ⇒ "strasse"

(string-downcase "&Sigma;") ⇒ "&sigma;"

(string-titlecase "kNock KNoCK") ⇒ "Knock Knock"
(string-titlecase "who's there?") ⇒ "Who's There?"
(string-titlecase "r6rs") ⇒ "R6rs"
(string-titlecase "R6RS") ⇒ "R6rs"</code></pre>
</div>
</div>
<div id="objects:s227" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-normalize-nfd <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the Unicode normalized form D of <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-normalize-nfkd <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the Unicode normalized form KD of <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-normalize-nfc <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the Unicode normalized form C of <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-normalize-nfkc <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the Unicode normalized form KC of <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs unicode)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If the result string is the same as <code><em>string</em></code> (by <code>string=?</code>), <code><em>string</em></code> or a copy of <code><em>string</em></code> may be returned. Otherwise, the result string is newly allocated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(string-normalize-nfd "\xE9;") ⇒ "e\x301;"
(string-normalize-nfc "\xE9;") ⇒ "\xE9;"
(string-normalize-nfd "\x65;\x301;") ⇒ "e\x301;"
(string-normalize-nfc "\x65;\x301;") ⇒ "\xE9;"</code></pre>
</div>
</div>
<div id="objects:s228" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-&gt;list <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a list of the characters in <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>string&#8594;list</code> allows a string to be converted into a list, so that Scheme&#8217;s list-processing operations may be applied to the processing of strings. <code>string-&gt;list</code> may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define string->list
  (lambda (s)
    (do ([i (- (string-length s) 1) (- i 1)]
         [ls '() (cons (string-ref s i) ls)])
        ((< i 0) ls))))

(string->list "") ⇒ ()
(string->list "abc") ⇒ (#\a #\b #\c)
(apply char&lt;? (string->list "abc")) ⇒ #t
(map char-upcase (string->list "abc")) ⇒ (#\A #\B #\C)</code></pre>
</div>
</div>
<div id="objects:s229" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(list-&gt;string <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a string of the characters in <code><em>list</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>list</em></code> must consist entirely of characters.</p>
</div>
<div class="paragraph">
<p><code>list-&gt;string</code> is the functional inverse of <code>string-&gt;list</code>. A program might use both procedures together, first converting a string into a list, then operating on this list to produce a new list, and finally converting the new list back into a string.</p>
</div>
<div class="paragraph">
<p><code>list-&gt;string</code> may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define list->string
  (lambda (ls)
    (let ([s (make-string (length ls))])
      (do ([ls ls (cdr ls)] [i 0 (+ i 1)])
          ((null? ls) s)
        (string-set! s i (car ls))))))

(list->string '()) ⇒ ""
(list->string '(#\a #\b #\c)) ⇒ "abc"
(list->string
  (map char-upcase
       (string->list "abc"))) ⇒ "ABC"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_6.9.">Section 6.9. Vectors</h3>
<div id="objects:s230" class="paragraph">
<p>Vectors are more convenient and efficient than lists for some applications. Whereas accessing an arbitrary element in a list requires a linear traversal of the list up to the selected element, arbitrary vector elements are accessed in constant time. The <em>length</em> of a vector is the number of elements it contains. Vectors are indexed by exact nonnegative integers, and the index of the first element of any vector is 0. The highest valid index for a given vector is one less than its length.</p>
</div>
<div class="paragraph">
<p>As with lists, the elements of a vector can be of any type, and a single vector can hold more than one type of object.</p>
</div>
<div class="paragraph">
<p>A vector is written as a sequence of objects separated by whitespace, preceded by the prefix <code>#(</code> and followed by <code>)</code>. For example, a vector consisting of the elements <code>a</code>, <code>b</code>, and <code>c</code> would be written <code>#(a b c)</code>.</p>
</div>
<div id="objects:s231" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(vector <em>obj</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a vector of the objects <code><em>obj</em> ...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(vector) ⇒ #()
(vector 'a 'b 'c) ⇒ #(a b c)</code></pre>
</div>
</div>
<div id="objects:s232" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-vector <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-vector <em>n</em> <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a vector of length <code><em>n</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer. If <code><em>obj</em></code> is supplied, each element of the vector is filled with <code><em>obj</em></code>; otherwise, the elements are unspecified.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(make-vector 0) ⇒ #()
(make-vector 0 '#(a)) ⇒ #()
(make-vector 5 '#(a)) ⇒ #(#(a) #(a) #(a) #(a) #(a))</code></pre>
</div>
</div>
<div id="objects:s233" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(vector-length <em>vector</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the number of elements in <code><em>vector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The length of a vector is always an exact nonnegative integer.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(vector-length '#()) ⇒ 0
(vector-length '#(a b c)) ⇒ 3
(vector-length (vector 1 '(2) 3 '#(4 5))) ⇒ 4
(vector-length (make-vector 300)) ⇒ 300</code></pre>
</div>
</div>
<div id="objects:s234" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(vector-ref <em>vector</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the <code><em>n</em></code>th element (zero-based) of <code><em>vector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer less than the length of <code><em>vector</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(vector-ref '#(a b c) 0) ⇒ a
(vector-ref '#(a b c) 1) ⇒ b
(vector-ref '#(x y z w) 3) ⇒ w</code></pre>
</div>
</div>
<div id="objects:s235" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(vector-set! <em>vector</em> <em>n</em> <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer less than the length of <code><em>vector</em></code>. <code>vector-set!</code> changes the <code><em>n</em></code>th element of <code><em>vector</em></code> to <code><em>obj</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([v (vector 'a 'b 'c 'd 'e)])
  (vector-set! v 2 'x)
  v) ⇒ #(a b x d e)</code></pre>
</div>
</div>
<div id="objects:s236" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(vector-fill! <em>vector</em> <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>vector-fill!</code> replaces each element of <code><em>vector</em></code> with <code><em>obj</em></code>. It may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define vector-fill!
  (lambda (v x)
    (let ([n (vector-length v)])
      (do ([i 0 (+ i 1)])
          ((= i n))
        (vector-set! v i x)))))

(let ([v (vector 1 2 3)])
  (vector-fill! v 0)
  v) ⇒ #(0 0 0)</code></pre>
</div>
</div>
<div id="objects:s237" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(vector-&gt;list <em>vector</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a list of the elements of <code><em>vector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>vector-&gt;list</code> provides a convenient method for applying list-processing operations to vectors. It may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define vector->list
  (lambda (s)
    (do ([i (- (vector-length s) 1) (- i 1)]
         [ls '() (cons (vector-ref s i) ls)])
        ((< i 0) ls))))

(vector->list (vector)) ⇒ ()
(vector->list '#(a b c)) ⇒ (a b c)

(let ((v '#(1 2 3 4 5)))
  (apply * (vector->list v))) ⇒ 120</code></pre>
</div>
</div>
<div id="objects:s238" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(list-&gt;vector <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a vector of the elements of <code><em>list</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>list-&gt;vector</code> is the functional inverse of <code>vector-&gt;list</code>. The two procedures are often used in combination to take advantage of a list-processing operation. A vector may be converted to a list with <code>vector-&gt;list</code>, this list processed in some manner to produce a new list, and the new list converted back into a vector with <code>list-&gt;vector</code>.</p>
</div>
<div class="paragraph">
<p><code>list-&gt;vector</code> may be defined without error checks as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define list->vector
  (lambda (ls)
    (let ([s (make-vector (length ls))])
      (do ([ls ls (cdr ls)] [i 0 (+ i 1)])
          ((null? ls) s)
        (vector-set! s i (car ls))))))

(list->vector '()) ⇒ #()
(list->vector '(a b c)) ⇒ #(a b c)

(let ([v '#(1 2 3 4 5)])
  (let ([ls (vector->list v)])
    (list->vector (map * ls ls)))) ⇒ #(1 4 9 16 25)</code></pre>
</div>
</div>
<div id="objects:s239" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(vector-sort <em>predicate</em> <em>vector</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a vector containing the elements of <code><em>vector</em></code>, sorted according to <code><em>predicate</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(vector-sort! <em>predicate</em> <em>vector</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs sorting)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>predicate</em></code> should be a procedure that expects two arguments and returns <code>#t</code> if its first argument must precede its second in the sorted vector. That is, if <code><em>predicate</em></code> is applied to two elements <code><em>x</em></code> and <code><em>y</em></code>, where <code><em>x</em></code> appears after <code><em>y</em></code> in the input vector, the predicate should return true only if <code><em>x</em></code> should appear before <code><em>y</em></code> in the output vector. If this constraint is met, <code>vector-sort</code> performs a stable sort, i.e., two elements are reordered only when necessary according to <code><em>predicate</em></code>. <code>vector-sort!</code> performs the sort destructively and does not necessarily perform a stable sort. Duplicate elements are not removed. <code><em>predicate</em></code> should not have any side effects.</p>
</div>
<div class="paragraph">
<p><code>vector-sort</code> may call <code><em>predicate</em></code> up to \(n\log{n}\) times, where <em>n</em> is the length of <code><em>vector</em></code>, while <code>vector-sort!</code> may call the predicate up to \(n^2\) times. The looser bound for <code>vector-sort!</code> allows an implementation to use a quicksort algorithm, which may be faster in some cases than algorithms that have the tighter \(n\log{n}\) bound.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(vector-sort < '#(3 4 2 1 2 5)) ⇒ #(1 2 2 3 4 5)
(vector-sort > '#(0.5 1/2)) ⇒ #(0.5 1/2)
(vector-sort > '#(1/2 0.5)) ⇒ #(1/2 0.5)

(let ([v (vector 3 4 2 1 2 5)])
  (vector-sort! < v)
  v) ⇒ #(1 2 2 3 4 5)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_6.10.">Section 6.10. Bytevectors</h3>
<div class="paragraph">
<p>Bytevectors are vectors of raw binary data. Although nominally organized as a sequence of exact unsigned 8-bit integers, a bytevector can be interpreted as a sequence of exact signed 8-bit integers, exact signed or unsigned 16-bit, 32-bit, 64-bit, or arbitrary-precision integers, IEEE single or double floating-point numbers, or arbitrary combinations of the above.</p>
</div>
<div class="paragraph">
<p>The length of a bytevector is the number of 8-bit bytes it stores, and indices into a bytevector are always given as byte offsets. Any data element may be aligned at any byte offset, regardless of the underlying hardware&#8217;s alignment requirements, and may be represented using a specified endianness (see below) that differs from that prescribed by the hardware. Special, typically more efficient operators are provided for 16-, 32-, and 64-bit integers and single and double floats that are in their <em>native</em> format, i.e,. with the endianness of the underlying hardware and stored at an index that is a multiple of the size in bytes of the integer or float.</p>
</div>
<div class="paragraph">
<p>The endianness of a multi-byte data value determines how it is laid out in memory. In <em>big-endian</em> format, the value is laid out with the more significant bytes at lower indices, while in <em>little-endian</em> format, the value is laid out with the more significant bytes at higher indices. When a bytevector procedure accepts an endianness argument, the argument may be the symbol <code>big</code>, representing the big-endian format, or the symbol <code>little</code>, representing the little-endian format. Implementations may extend these procedures to accept other endianness symbols. The native endianness of the implementation may be obtained via the procedure <code>native-endianness</code>.</p>
</div>
<div class="paragraph">
<p>Bytevectors are written with the <code>#vu8(</code> prefix in place of the <code>#(</code> prefix for vectors, e.g., <code>#vu8(1 2 3)</code>. The elements of a bytevector specified in this manner are always given as 8-bit unsigned exact integers, i.e., integers from 0 to 255 inclusive, written using any valid syntax for such numbers. Like strings, bytevectors are self-evaluating, so they need not be quoted.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">'#vu8(1 2 3) ⇒ #vu8(1 2 3)
#vu8(1 2 3) ⇒ #vu8(1 2 3)
#vu8(#x3f #x7f #xbf #xff) ⇒ #vu8(63 127 191 255)</code></pre>
</div>
</div>
<div id="objects:s240" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(endianness <em>symbol</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>symbol</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>symbol</em></code> must be the symbol <code>little</code>, the symbol <code>big</code>, or some other symbol recognized by the implementation as an endianness symbol. It is a syntax violation if <code><em>symbol</em></code> is not a symbol or if it is not recognized by the implementation as an endianness symbol.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(endianness little) ⇒ little
(endianness big) ⇒ big
(endianness "spam") ⇒ <em>exception</em></code></pre>
</div>
</div>
<div id="objects:s241" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(native-endianness)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a symbol naming the implementation&#8217;s native endianness</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The return value is the symbol <code>little</code>, the symbol <code>big</code>, or some other endianness symbol recognized by the implementation. It typically reflects the endianness of the underlying hardware.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(symbol? (native-endianness)) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s242" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-bytevector <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-bytevector <em>n</em> <em>fill</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new bytevector of length <code><em>n</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>fill</em></code> is supplied, each element of the bytevector is initialized to <code><em>fill</em></code>; otherwise, the elements are unspecified. The <code><em>fill</em></code> value must be a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative fill value is treated as its two&#8217;s complement equivalent.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(make-bytevector 0) ⇒ #vu8()
(make-bytevector 0 7) ⇒ #vu8()
(make-bytevector 5 7) ⇒ #vu8(7 7 7 7 7)
(make-bytevector 5 -7) ⇒ #vu8(249 249 249 249 249)</code></pre>
</div>
</div>
<div id="objects:s243" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-length <em>bytevector</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the length of <code><em>bytevector</em></code> in 8-bit bytes</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bytevector-length #vu8()) ⇒ 0
(bytevector-length #vu8(1 2 3)) ⇒ 3
(bytevector-length (make-bytevector 300)) ⇒ 300</code></pre>
</div>
</div>
<div id="objects:s244" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector=? <em>bytevector<sub>1</sub></em> <em>bytevector<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the relation holds, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Two bytevectors are equal by <code>bytevector=?</code> if and only if they have the same length and same contents.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bytevector=? #vu8() #vu8()) ⇒ #t
(bytevector=? (make-bytevector 3 0) #vu8(0 0 0)) ⇒ #t
(bytevector=? (make-bytevector 5 0) #vu8(0 0 0)) ⇒ #f
(bytevector=? #vu8(1 127 128 255) #vu8(255 128 127 1)) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s245" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-fill! <em>bytevector</em> <em>fill</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code><em>fill</em></code> value must be a signed or unsigned 8-bit value, i.e., a value in the range -128 to 255 inclusive. A negative fill value is treated as its two&#8217;s complement equivalent.</p>
</div>
<div class="paragraph">
<p><code>bytevector-fill!</code> replaces each element of <code><em>bytevector</em></code> with <code><em>fill</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([v (make-bytevector 6)])
  (bytevector-fill! v 255)
  v) ⇒ #vu8(255 255 255 255 255 255)

(let ([v (make-bytevector 6)])
  (bytevector-fill! v -128)
  v) ⇒ #vu8(128 128 128 128 128 128)</code></pre>
</div>
</div>
<div id="objects:s246" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-copy <em>bytevector</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new bytevector that is a copy of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>bytevector-copy</code> creates a new bytevector with the same length and contents as <code><em>bytevector</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bytevector-copy #vu8(1 127 128 255)) ⇒ #vu8(1 127 128 255)

(let ([v #vu8(1 127 128 255)])
  (eq? v (bytevector-copy v))) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s247" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-copy! <em>src</em> <em>src-start</em> <em>dst</em> <em>dst-start</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>src</em></code> and <code><em>dst</em></code> must be bytevectors. <code><em>src-start</em></code>, <code><em>dst-start</em></code>, and <code><em>n</em></code> must be exact nonnegative integers. The sum of <code><em>src-start</em></code> and <code><em>n</em></code> must not exceed the length of <code><em>src</em></code>, and the sum of <code><em>dst-start</em></code> and <code><em>n</em></code> must not exceed the length of <code><em>dst</em></code>.</p>
</div>
<div class="paragraph">
<p><code>bytevector-copy!</code> overwrites the <code><em>n</em></code> bytes of <code><em>dst</em></code> starting at <code><em>dst-start</em></code> with the <code><em>n</em></code> bytes of <code><em>src</em></code> starting at <code><em>src-start</em></code>. This works even if <code><em>dst</em></code> is the same bytevector as <code><em>src</em></code> and the source and destination locations overlap. That is, the destination is filled with the bytes that appeared at the source before the operation began.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define v1 #vu8(31 63 95 127 159 191 223 255))
(define v2 (make-bytevector 10 0))

(bytevector-copy! v1 2 v2 1 4)
v2 ⇒ #vu8(0 95 127 159 191 0 0 0 0 0)

(bytevector-copy! v1 5 v2 7 3)
v2 ⇒ #vu8(0 95 127 159 191 0 0 191 223 255)

(bytevector-copy! v2 3 v2 0 6)
v2 ⇒ #vu8(159 191 0 0 191 223 0 191 223 255)

(bytevector-copy! v2 0 v2 1 9)
v2 ⇒ #vu8(159 159 191 0 0 191 223 0 191 223)</code></pre>
</div>
</div>
<div id="objects:s248" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u8-ref <em>bytevector</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 8-bit unsigned byte at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer less than the length of <code><em>bytevector</em></code>.</p>
</div>
<div class="paragraph">
<p>The value is returned as an exact 8-bit unsigned integer, i.e., a value in the range 0 to 255 inclusive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bytevector-u8-ref #vu8(1 127 128 255) 0) ⇒ 1
(bytevector-u8-ref #vu8(1 127 128 255) 2) ⇒ 128
(bytevector-u8-ref #vu8(1 127 128 255) 3) ⇒ 255</code></pre>
</div>
</div>
<div id="objects:s249" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s8-ref <em>bytevector</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 8-bit signed byte at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer less than the length of <code><em>bytevector</em></code>.</p>
</div>
<div class="paragraph">
<p>The value returned is an exact 8-bit signed integer, i.e., a value in the range -128 to 127 inclusive, and is the equivalent of the stored value treated as a two&#8217;s complement value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bytevector-s8-ref #vu8(1 127 128 255) 0) ⇒ 1
(bytevector-s8-ref #vu8(1 127 128 255) 1) ⇒ 127
(bytevector-s8-ref #vu8(1 127 128 255) 2) ⇒ -128
(bytevector-s8-ref #vu8(1 127 128 255) 3) ⇒ -1</code></pre>
</div>
</div>
<div id="objects:s250" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u8-set! <em>bytevector</em> <em>n</em> <em>u8</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer less than the length of <code><em>bytevector</em></code>. <code><em>u8</em></code> must be an 8-bit unsigned value, i.e., a value in the range 0 to 255 inclusive.</p>
</div>
<div class="paragraph">
<p><code>bytevector-u8-set!</code> changes the 8-bit value at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code> to <code><em>u8</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([v (make-bytevector 5 -1)])
  (bytevector-u8-set! v 2 128)
  v) ⇒ #vu8(255 255 128 255 255)</code></pre>
</div>
</div>
<div id="objects:s251" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s8-set! <em>bytevector</em> <em>n</em> <em>s8</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer less than the length of <code><em>bytevector</em></code>. <code><em>s8</em></code> must be an 8-bit signed value, i.e., a value in the range -128 to 127 inclusive.</p>
</div>
<div class="paragraph">
<p><code>bytevector-s8-set!</code> changes the 8-bit value at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code> to the two&#8217;s complement equivalent of <code><em>s8</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([v (make-bytevector 4 0)])
  (bytevector-s8-set! v 1 100)
  (bytevector-s8-set! v 2 -100)
  v) ⇒ #vu8(0 100 156 0)</code></pre>
</div>
</div>
<div id="objects:s252" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-&gt;u8-list <em>bytevector</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a list of the 8-bit unsigned elements of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bytevector->u8-list (make-bytevector 0)) ⇒ ()
(bytevector->u8-list #vu8(1 127 128 255)) ⇒ (1 127 128 255)

(let ([v #vu8(1 2 3 255)])
  (apply * (bytevector->u8-list v))) ⇒ 1530</code></pre>
</div>
</div>
<div id="objects:s253" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(u8-list-&gt;bytevector <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new bytevector of the elements of <code><em>list</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>list</em></code> must consist entirely of exact 8-bit unsigned integers, i.e., values in the range 0 to 255 inclusive.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(u8-list->bytevector '()) ⇒ #vu8()
(u8-list->bytevector '(1 127 128 255)) ⇒ #vu8(1 127 128 255)

(let ([v #vu8(1 2 3 4 5)])
  (let ([ls (bytevector->u8-list v)])
    (u8-list->bytevector (map * ls ls)))) ⇒ #vu8(1 4 9 16 25)</code></pre>
</div>
</div>
<div id="objects:s254" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u16-native-ref <em>bytevector</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 16-bit unsigned integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s16-native-ref <em>bytevector</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 16-bit signed integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u32-native-ref <em>bytevector</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 32-bit unsigned integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s32-native-ref <em>bytevector</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 32-bit signed integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u64-native-ref <em>bytevector</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 64-bit unsigned integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s64-native-ref <em>bytevector</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 64-bit signed integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of <code><em>n</em></code> and the number of bytes occupied by the value must not exceed the length of <code><em>bytevector</em></code>. The native endianness is assumed.</p>
</div>
<div class="paragraph">
<p>The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two&#8217;s complement value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If native endianness is big:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bytevector-u16-native-ref v 2) ⇒ #xfe56
(bytevector-s16-native-ref v 2) ⇒ #x-1aa
(bytevector-s16-native-ref v 6) ⇒ #x7898

(bytevector-u32-native-ref v 0) ⇒ #x1234fe56
(bytevector-s32-native-ref v 0) ⇒ #x1234fe56
(bytevector-s32-native-ref v 4) ⇒ #x-23458768

(bytevector-u64-native-ref v 0) ⇒ #x1234fe56dcba7898
(bytevector-s64-native-ref v 0) ⇒ #x1234fe56dcba7898</code></pre>
</div>
</div>
<div class="paragraph">
<p>If native endianness is little:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bytevector-u16-native-ref v 2) ⇒ #x56fe
(bytevector-s16-native-ref v 2) ⇒ #x56fe
(bytevector-s16-native-ref v 6) ⇒ #x-6788

(bytevector-u32-native-ref v 0) ⇒ #x56fe3412
(bytevector-s32-native-ref v 0) ⇒ #x56fe3412
(bytevector-s32-native-ref v 4) ⇒ #x-67874524

(bytevector-u64-native-ref v 0) ⇒ #x9878badc56fe3412
(bytevector-s64-native-ref v 0) ⇒ #x-67874523a901cbee</code></pre>
</div>
</div>
<div id="objects:s255" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u16-native-set! <em>bytevector</em> <em>n</em> <em>u16</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s16-native-set! <em>bytevector</em> <em>n</em> <em>s16</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u32-native-set! <em>bytevector</em> <em>n</em> <em>u32</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s32-native-set! <em>bytevector</em> <em>n</em> <em>s32</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u64-native-set! <em>bytevector</em> <em>n</em> <em>u64</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s64-native-set! <em>bytevector</em> <em>n</em> <em>s64</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 2 for 16-bit values, 4 for 32-bit values, and 8 for 64-bit values. The sum of <code><em>n</em></code> and the number of bytes occupied by the value must not exceed the length <code><em>bytevector</em></code>. <code><em>u16</em></code> must be a 16-bit unsigned value, i.e., a value in the range 0 to \(2^{16} - 1\) inclusive; <code><em>s16</em></code> must be a 16-bit signed value, i.e., a value in the range \(-2^{15}\) to \(2^{15} - 1\) inclusive; <code><em>u32</em></code> must be a 32-bit unsigned value, i.e., a value in the range 0 to \(2^{32} - 1\) inclusive; <code><em>s32</em></code> must be a 32-bit signed value, i.e., a value in the range \(-2^{31}\) to \(2^{31} - 1\) inclusive; <code><em>u64</em></code> must be a 64-bit unsigned value, i.e., a value in the range \(0\) to \(2^{64} - 1\) inclusive; and <code><em>s64</em></code> must be a 64-bit signed value, i.e., a value in the range \(-2^{63}\) to \(2^{63} - 1\) inclusive. The native endianness is assumed.</p>
</div>
<div class="paragraph">
<p>These procedures store the given value in the 2, 4, or 8 bytes starting at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code>. Negative values are stored as their two&#8217;s complement equivalent.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define v (make-bytevector 8 0))
(bytevector-u16-native-set! v 0 #xfe56)
(bytevector-s16-native-set! v 2 #x-1aa)
(bytevector-s16-native-set! v 4 #x7898)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If native endianness is big:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">v ⇒ #vu8(#xfe #x56 #xfe #x56 #x78 #x98 #x00 #x00)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If native endianness is little:</p>
</div>
<div class="literalblock">
<div class="content">
<pre>[source,scheme,subs=""]</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>v ⇒ #vu8(#x56 #xfe #x56 #xfe #x98 #x78 #x00 #x00)</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define v (make-bytevector 16 0))
(bytevector-u32-native-set! v 0 #x1234fe56)
(bytevector-s32-native-set! v 4 #x1234fe56)
(bytevector-s32-native-set! v 8 #x-23458768)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If native endianness is big:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">v ⇒ #vu8(#x12 #x34 #xfe #x56 #x12 #x34 #xfe #x56
          #xdc #xba #x78 #x98 #x00 #x00 #x00 #x00)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If native endianness is little:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">v ⇒ #vu8(#x56 #xfe #x34 #x12 #x56 #xfe #x34 #x12
          #x98 #x78 #xba #xdc #x00 #x00 #x00 #x00)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define v (make-bytevector 24 0))
(bytevector-u64-native-set! v 0 #x1234fe56dcba7898)
(bytevector-s64-native-set! v 8 #x1234fe56dcba7898)
(bytevector-s64-native-set! v 16 #x-67874523a901cbee)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If native endianness is big:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">v ⇒ #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98
          #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98
          #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12)</code></pre>
</div>
</div>
<div class="paragraph">
<p>If native endianness is little:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">v ⇒ #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12
          #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12
          #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98)</code></pre>
</div>
</div>
<div id="objects:s256" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u16-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 16-bit unsigned integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s16-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 16-bit signed integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u32-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 32-bit unsigned integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s32-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 32-bit signed integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u64-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 64-bit unsigned integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s64-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the 64-bit signed integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer and indexes the starting byte of the value. The sum of <code><em>n</em></code> and the number of bytes occupied by the value (2 for 16-bit values, 4 for 32-bit values, and 8 for 32-bit values) must not exceed the length of <code><em>bytevector</em></code>. <code><em>n</em></code> need <em>not</em> be a multiple of the number of bytes occupied by the value. <code><em>eness</em></code> must be a valid endianness symbol naming the endianness.</p>
</div>
<div class="paragraph">
<p>The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two&#8217;s complement value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))
(bytevector-u16-ref v 0 (endianness big)) ⇒ #x1234
(bytevector-s16-ref v 1 (endianness big)) ⇒ #x34fe
(bytevector-s16-ref v 5 (endianness big)) ⇒ #x-4588

(bytevector-u32-ref v 2 'big) ⇒ #xfe56dcba
(bytevector-s32-ref v 3 'big) ⇒ #x56dcba78
(bytevector-s32-ref v 4 'big) ⇒ #x-23458768

(bytevector-u64-ref v 0 'big) ⇒ #x1234fe56dcba7898
(bytevector-s64-ref v 1 'big) ⇒ #x34fe56dcba78989a

(bytevector-u16-ref v 0 (endianness little)) ⇒ #x3412
(bytevector-s16-ref v 1 (endianness little)) ⇒ #x-1cc
(bytevector-s16-ref v 5 (endianness little)) ⇒ #x78ba

(bytevector-u32-ref v 2 'little) ⇒ #xbadc56fe
(bytevector-s32-ref v 3 'little) ⇒ #x78badc56
(bytevector-s32-ref v 4 'little) ⇒ #x-67874524

(bytevector-u64-ref v 0 'little) ⇒ #x9878badc56fe3412
(bytevector-s64-ref v 1 'little) ⇒ #x-6567874523a901cc</code></pre>
</div>
</div>
<div id="objects:s257" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u16-set! <em>bytevector</em> <em>n</em> <em>u16</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s16-set! <em>bytevector</em> <em>n</em> <em>s16</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u32-set! <em>bytevector</em> <em>n</em> <em>u32</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s32-set! <em>bytevector</em> <em>n</em> <em>s32</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-u64-set! <em>bytevector</em> <em>n</em> <em>u64</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-s64-set! <em>bytevector</em> <em>n</em> <em>s64</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer and indexes the starting byte of the value. The sum of <code><em>n</em></code> and the number of bytes occupied by the value must not exceed the length of <code><em>bytevector</em></code>. <code><em>n</em></code> need <em>not</em> be a multiple of the number of bytes occupied by the value. <code><em>u16</em></code> must be a 16-bit unsigned value, i.e., a value in the range \(0\) to \(2^{16} - 1\) inclusive; <code><em>s16</em></code> must be a 16-bit signed value, i.e., a value in the range \(-2^{15}\) to \(2^{15} - 1\) inclusive; <code><em>u32</em></code> must be a 32-bit unsigned value, i.e., a value in the range \(0\) to \(2^{32} - 1\) inclusive; <code><em>s32</em></code> must be a 32-bit signed value, i.e., a value in the range \(-2^{31}\) to \(2^{31} - 1\) inclusive; <code><em>u64</em></code> must be a 64-bit unsigned value, i.e., a value in the range \(0\) to \(2^{64} - 1\) inclusive; and <code><em>s64</em></code> must be a 64-bit signed value, i.e., a value in the range \(-2^{63}\) to \(2^{63} - 1\) inclusive. <code><em>eness</em></code> must be a valid endianness symbol naming the endianness.</p>
</div>
<div class="paragraph">
<p>These procedures store the given value in the 2, 4, or 8 bytes starting at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code>. Negative values are stored as their two&#8217;s complement equivalent.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define v (make-bytevector 8 0))
(bytevector-u16-set! v 0 #xfe56 (endianness big))
(bytevector-s16-set! v 3 #x-1aa (endianness little))
(bytevector-s16-set! v 5 #x7898 (endianness big))
v ⇒ #vu8(#xfe #x56 #x0 #x56 #xfe #x78 #x98 #x0)

(define v (make-bytevector 16 0))
(bytevector-u32-set! v 0 #x1234fe56 'little)
(bytevector-s32-set! v 6 #x1234fe56 'big)
(bytevector-s32-set! v 11 #x-23458768 'little)
v ⇒ #vu8(#x56 #xfe #x34 #x12 #x0 #x0
          #x12 #x34 #xfe #x56 #x0
          #x98 #x78 #xba #xdc #x0)

(define v (make-bytevector 28 0))
(bytevector-u64-set! v 0 #x1234fe56dcba7898 'little)
(bytevector-s64-set! v 10 #x1234fe56dcba7898 'big)
(bytevector-s64-set! v 19 #x-67874523a901cbee 'big)
v ⇒ #vu8(#x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0 #x0
          #x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x0
          #x98 #x78 #xba #xdc #x56 #xfe #x34 #x12 #x0)</code></pre>
</div>
</div>
<div id="objects:s258" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-uint-ref <em>bytevector</em> <em>n</em> <em>eness</em> <em>size</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the <code><em>size</em></code>-byte unsigned integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-sint-ref <em>bytevector</em> <em>n</em> <em>eness</em> <em>size</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the <code><em>size</em></code>-byte signed integer at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer and indexes the starting byte of the value. <code><em>size</em></code> must be an exact positive integer and specifies the number of bytes occupied by the value. The sum of <code><em>n</em></code> and <code><em>size</em></code> must not exceed the length of <code><em>bytevector</em></code>. <code><em>n</em></code> need <em>not</em> be a multiple of the number of bytes occupied by the value. <code><em>eness</em></code> must be a valid endianness symbol naming the endianness.</p>
</div>
<div class="paragraph">
<p>The return value is an exact integer in the appropriate range for the number of bytes occupied by the value. Signed values are the equivalent of the stored value treated as a two&#8217;s complement value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define v #vu8(#x12 #x34 #xfe #x56 #xdc #xba #x78 #x98 #x9a #x76))

(bytevector-uint-ref v 0 'big 1) ⇒ #x12
(bytevector-uint-ref v 0 'little 1) ⇒ #x12
(bytevector-uint-ref v 1 'big 3) ⇒ #x34fe56
(bytevector-uint-ref v 2 'little 7) ⇒ #x9a9878badc56fe

(bytevector-sint-ref v 2 'big 1) ⇒ #x-02
(bytevector-sint-ref v 1 'little 6) ⇒ #x78badc56fe34
(bytevector-sint-ref v 2 'little 7) ⇒ #x-6567874523a902

(bytevector-sint-ref (make-bytevector 1000 -1) 0 'big 1000) ⇒ -1</code></pre>
</div>
</div>
<div id="objects:s259" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-uint-set! <em>bytevector</em> <em>n</em> <em>uint</em> <em>eness</em> <em>size</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-sint-set! <em>bytevector</em> <em>n</em> <em>sint</em> <em>eness</em> <em>size</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer and indexes the starting byte of the value. <code><em>size</em></code> must be an exact positive integer and specifies the number of bytes occupied by the value. The sum of <code><em>n</em></code> and <code><em>size</em></code> must not exceed the length of <code><em>bytevector</em></code>. <code><em>n</em></code> need <em>not</em> be a multiple of the number of bytes occupied by the value. <code><em>uint</em></code> must be an exact integer in the range \(0\) to \(2^{size \cdot 8} - 1\) inclusive. <code><em>sint</em></code> must be an exact integer in the range \(-2^{size \cdot 8 - 1}\) to \(2^{size \cdot 8 - 1} - 1\) inclusive. <code><em>eness</em></code> must be a valid endianness symbol naming the endianness.</p>
</div>
<div class="paragraph">
<p>These procedures store the given value in the <code><em>size</em></code> bytes starting at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code>. Negative values are stored as their two&#8217;s complement equivalent.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define v (make-bytevector 5 0))
(bytevector-uint-set! v 1 #x123456 (endianness big) 3)
v ⇒ #vu8(0 #x12 #x34 #x56 0)

(define v (make-bytevector 7 -1))
(bytevector-sint-set! v 1 #x-8000000000 (endianness little) 5)
v ⇒ #vu8(#xff 0 0 0 0 #x80 #xff)</code></pre>
</div>
</div>
<div id="objects:s260" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-&gt;uint-list <em>bytevector</em> <em>eness</em> <em>size</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new list of the <code><em>size</em></code>-byte unsigned elements of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-&gt;sint-list <em>bytevector</em> <em>eness</em> <em>size</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new list of the <code><em>size</em></code>-byte signed elements of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>eness</em></code> must be a valid endianness symbol naming the endianness. <code><em>size</em></code> must be an exact positive integer and specifies the number of bytes occupied by the value. It must be a value that evenly divides the length of <code><em>bytevector</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(bytevector->uint-list (make-bytevector 0) 'little 3) ⇒ ()

(let ([v #vu8(1 2 3 4 5 6)])
  (bytevector->uint-list v 'big 3)) ⇒ (#x010203 #x040506)

(let ([v (make-bytevector 80 -1)])
  (bytevector->sint-list v 'big 20)) ⇒ (-1 -1 -1 -1)</code></pre>
</div>
</div>
<div id="objects:s261" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(uint-list-&gt;bytevector <em>list</em> <em>eness</em> <em>size</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(sint-list-&gt;bytevector <em>list</em> <em>eness</em> <em>size</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new bytevector of the elements of <code><em>list</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>eness</em></code> must be a valid endianness symbol naming the endianness. <code><em>size</em></code> must be an exact positive integer and specifies the number of bytes occupied by the value. For <code>uint-list-&gt;bytevector</code>, <code><em>list</em></code> must consist entirely of <code><em>size</em></code>-byte exact unsigned integers, i.e., values in the range \(0\) to \(2^{size \cdot 8} - 1\) inclusive. For <code>sint-list-&gt;bytevector</code>, <code><em>list</em></code> must consist entirely of <code><em>size</em></code>-byte exact signed integers, i.e., values in the range \(-2^{size \cdot 8 - 1}\) to \(2^{size \cdot 8 - 1} - 1\) inclusive. Each value occupies <code><em>size</em></code> bytes in the resulting bytevector, whose length is thus <code><em>size</em></code> times the length of <code><em>list</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(uint-list->bytevector '() 'big 25) ⇒ #vu8()
(sint-list->bytevector '(0 -1) 'big 3) ⇒ #vu8(0 0 0 #xff #xff #xff)

(define (f size)
  (let ([ls (list (- (expt 2 (- (* 8 size) 1)))
                  (- (expt 2 (- (* 8 size) 1)) 1))])
    (sint-list->bytevector ls 'little size)))
(f 6) ⇒ #vu8(#x00 #x00 #x00 #x00 #x00 #x80
              #xff #xff #xff #xff #xff #x7f)</code></pre>
</div>
</div>
<div id="objects:s262" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-ieee-single-native-ref <em>bytevector</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the single floating-point value at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-ieee-double-native-ref <em>bytevector</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the double floating-point value at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 4 for single floats, 8 for double. The sum of <code><em>n</em></code> and the number of bytes occupied by the value must not exceed the length of <code><em>bytevector</em></code>. The native endianness is assumed.</p>
</div>
<div class="paragraph">
<p>The return value is an inexact real number. Examples appear after the mutation operators below.</p>
</div>
<div id="objects:s263" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-ieee-single-native-set! <em>bytevector</em> <em>n</em> <em>x</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-ieee-double-native-set! <em>bytevector</em> <em>n</em> <em>x</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer. It indexes the starting byte of the value and must be a multiple of the number of bytes occupied by the value: 4 for single floats, 8 for double. The sum of <code><em>n</em></code> and the number of bytes occupied by the value must not exceed the length of <code><em>bytevector</em></code>. The native endianness is assumed.</p>
</div>
<div class="paragraph">
<p>These procedures store the given value as an IEEE-754 single or double floating-point value at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define v (make-bytevector 8 0))
(bytevector-ieee-single-native-set! v 0 .125)
(bytevector-ieee-single-native-set! v 4 -3/2)
(list
  (bytevector-ieee-single-native-ref v 0)
  (bytevector-ieee-single-native-ref v 4)) ⇒ (0.125 -1.5)

(bytevector-ieee-double-native-set! v 0 1e23)
(bytevector-ieee-double-native-ref v 0) ⇒ 1e23</code></pre>
</div>
</div>
<div id="objects:s264" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-ieee-single-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the single floating-point value at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-ieee-double-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the double floating-point value at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer and indexes the starting byte of the value. The sum of <code><em>n</em></code> and the number of bytes occupied by the value (4 for a single float, 8 for a double) must not exceed the length of <code><em>bytevector</em></code>. <code><em>n</em></code> need <em>not</em> be a multiple of the number of bytes occupied by the value. <code><em>eness</em></code> must be a valid endianness symbol naming the endianness.</p>
</div>
<div class="paragraph">
<p>The return value is an inexact real number. Examples appear after the mutation operators below.</p>
</div>
<div id="objects:s265" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-ieee-single-set! <em>bytevector</em> <em>n</em> <em>x</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-ieee-double-set! <em>bytevector</em> <em>n</em> <em>x</em> <em>eness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer and indexes the starting byte of the value. The sum of <code><em>n</em></code> and the number of bytes occupied by the value (4 for a single float, 8 for a double) must not exceed the length of <code><em>bytevector</em></code>. <code><em>n</em></code> need <em>not</em> be a multiple of the number of bytes occupied by the value. <code><em>eness</em></code> must be a valid endianness symbol naming the endianness.</p>
</div>
<div class="paragraph">
<p>These procedures store the given value as an IEEE-754 single or double floating-point value at index <code><em>n</em></code> (zero-based) of <code><em>bytevector</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define v (make-bytevector 10 #xc7))
(bytevector-ieee-single-set! v 1 .125 'little)
(bytevector-ieee-single-set! v 6 -3/2 'big)
(list
  (bytevector-ieee-single-ref v 1 'little)
  (bytevector-ieee-single-ref v 6 'big)) ⇒ (0.125 -1.5)
v ⇒ #vu8(#xc7 #x0 #x0 #x0 #x3e #xc7 #xbf #xc0 #x0 #x0)

(bytevector-ieee-double-set! v 1 1e23 'big)
(bytevector-ieee-double-ref v 1 'big) ⇒ 1e23</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_6.11.">Section 6.11. Symbols</h3>
<div id="objects:s266" class="paragraph">
<p>Symbols are used for a variety of purposes as symbolic names in Scheme programs. Strings could be used for most of the same purposes, but an important characteristic of symbols makes comparisons between symbols much more efficient. This characteristic is that two symbols with the same name are identical in the sense of <code>eq?</code>. The reason is that the Scheme reader (invoked by <code>get-datum</code> and <code>read</code>) and the procedure <code>string-&gt;symbol</code> catalog symbols in an internal symbol table and always return the same symbol whenever the same name is encountered. Thus, no character-by-character comparison is needed, as would be needed to compare two strings.</p>
</div>
<div class="paragraph">
<p>The property that two symbols may be compared quickly for equivalence makes them ideally suited for use as identifiers in the representation of programs, allowing fast comparison of identifiers. This property also makes symbols useful for a variety of other purposes. For example, symbols might be used as messages passed between procedures, labels for list-structured records, or names for objects stored in an association list (see <code>assq</code> in <a href="#section_6.3.">Section 6.3</a>).</p>
</div>
<div class="paragraph">
<p>Symbols are written without double quotes or other bracketing characters. Parentheses, double quotes, spaces, and most other characters with a special meaning to the Scheme reader are not allowed within the printed representation of a symbol. These and any other Unicode character may appear anywhere within the printed representation of a symbol with the syntax <code>#\x<em>n</em>;</code>, where <code><em>n</em></code> consists of one or more hexadecimal digits and represents a valid Unicode scalar value.</p>
</div>
<div class="paragraph">
<p>The grammar for symbols on <a href="#grammar:symbols">page 458</a> gives a precise definition of the syntax of symbols.</p>
</div>
<div id="objects:s268" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(symbol=? <em>symbol<sub>1</sub></em> <em>symbol<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the two symbols are the same, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Symbols can also be compared with <code>eq?</code>, which is typically more efficient than <code>symbol=?</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(symbol=? 'a 'a) ⇒ #t
(symbol=? 'a (string->symbol "a")) ⇒ #t
(symbol=? 'a 'b) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s269" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-&gt;symbol <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a symbol whose name is <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>string-&gt;symbol</code> records all symbols it creates in an internal table that it shares with the system reader. If a symbol whose name is equivalent to string (according to the predicate <code>string=?</code>) already exists in the table, this symbol is returned. Otherwise, a new symbol is created with <code><em>string</em></code> as its name; this symbol is entered into the table and returned.</p>
</div>
<div class="paragraph">
<p>The effect of modifying a string after it is used as an argument to <code>string-&gt;symbol</code> is unspecified.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(string->symbol "x") ⇒ x

(eq? (string->symbol "x") 'x) ⇒ #t
(eq? (string->symbol "X") 'x) ⇒ #f

(eq? (string->symbol "x")
     (string->symbol "x")) ⇒ #t

(string->symbol "()") ⇒ \x28;\x29;</code></pre>
</div>
</div>
<div id="objects:s270" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(symbol-&gt;string <em>symbol</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a string, the name of <code><em>symbol</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The string returned by <code>symbol-&gt;string</code> should be treated as immutable. Unpredictable behavior can result if a string passed to <code>string-&gt;symbol</code> is altered with <code>string-set!</code> or by any other means.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(symbol->string 'xyz) ⇒ "xyz"
(symbol->string 'Hi) ⇒ "Hi"
(symbol->string (string->symbol "()")) ⇒ "()"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_6.12.">Section 6.12. Booleans</h3>
<div class="paragraph">
<p>While every Scheme object has a truth value when used in a conditional context, with every object but <code>#f</code> counting as true, Scheme provides the dedicated true value <code>#t</code> for use when a value of an expression should convey nothing more than that it is true.</p>
</div>
<div id="objects:s271" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(boolean=? <em>boolean<sub>1</sub></em> <em>boolean<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the two booleans are the same, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The boolean values <code>#t</code> and <code>#f</code> may also be compared with <code>eq?</code>, which is typically more efficient than <code>boolean=?</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(boolean=? #t #t) ⇒ #t
(boolean=? #t #f) ⇒ #f
(boolean=? #t (< 3 4)) ⇒ #t</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_6.13.">Section 6.13. Hashtables</h3>
<div class="paragraph">
<p>Hashtables represent sets of associations between arbitrary Scheme values. They serve essentially the same purpose as association lists (see <a href="#page:assq">page 165</a>) but are typically much faster when large numbers of associations are involved.</p>
</div>
<div id="objects:s274" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-eq-hashtable)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-eq-hashtable <em>size</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new mutable eq hashtable</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>size</em></code> is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero <code><em>size</em></code> can help limit the amount of rehashing that must be done as the table is initially populated.</p>
</div>
<div class="paragraph">
<p>An eq hashtable compares keys using the <code>eq?</code> (pointer equality) procedure and typically employs a hash function based on object addresses. Its hash and equivalence functions are suitable for any Scheme object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define ht1 (make-eq-hashtable))
(define ht2 (make-eq-hashtable 32))</code></pre>
</div>
</div>
<div id="objects:s275" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-eqv-hashtable)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-eqv-hashtable <em>size</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new mutable eqv hashtable</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>size</em></code> is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero <code><em>size</em></code> can help limit the amount of rehashing that must be done as the table is initially populated.</p>
</div>
<div class="paragraph">
<p>An eqv hashtable compares keys using the <code>eqv?</code> procedure and typically employs a hash function based on object addresses for objects that are identifiable with <code>eq?</code>. Its hash and equivalence functions are suitable for any Scheme object.</p>
</div>
<div id="objects:s276" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-hashtable <em>hash</em> <em>equiv?</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-hashtable <em>hash</em> <em>equiv?</em> <em>size</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new mutable hashtable</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>hash</em></code> and <code><em>equiv?</em></code> must be procedures. If <code><em>size</em></code> is provided, it must be a nonnegative exact integer indicating approximately how many elements the hashtable should initially hold. Hashtables grow as needed, but when the hashtable grows it generally must rehash all of the existing elements. Providing a nonzero <code><em>size</em></code> can help limit the amount of rehashing that must be done as the table is initially populated.</p>
</div>
<div class="paragraph">
<p>The new hashtable computes hash values using <code><em>hash</em></code> and compares keys using <code><em>equiv?</em></code>, neither of which should modify the hashtable. <code><em>equiv?</em></code> should compare two keys and return false only if the two keys should be distinguished. <code><em>hash</em></code> should accept a key as an argument and return a nonnegative exact integer value that is the same each time it is called with arguments that <code><em>equiv?</em></code> does not distinguish. The <code><em>hash</em></code> and <code><em>equiv?</em></code> procedures need not accept arbitrary inputs as long as the hashtable is used only for keys that they do accept, and both procedures may assume that the keys are immutable as long as the keys are not modified while they have associations stored in the table. The hashtable operation may call <code><em>hash</em></code> and <code><em>equiv?</em></code> once, not at all, or multiple times for each hashtable operation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define ht (make-hashtable string-hash string=?))</code></pre>
</div>
</div>
<div id="objects:s277" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-mutable? <em>hashtable</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>hashtable</em></code> is mutable, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hashtables returned by one of the hashtable creation procedures above are mutable, but those created by <code>hashtable-copy</code> may be immutable. Immutable hashtables cannot be altered by any of the procedures <code>hashtable-set!</code>, <code>hashtable-update!</code>, <code>hashtable-delete!</code>, or <code>hashtable-clear!</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(hashtable-mutable? (make-eq-hashtable)) ⇒ #t
(hashtable-mutable? (hashtable-copy (make-eq-hashtable))) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s278" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-hash-function <em>hashtable</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the hash function associated with <code><em>hashtable</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-equivalence-function <em>hashtable</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the equivalence function associated with <code><em>hashtable</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>hashtable-hash-function</code> returns <code>#f</code> for eq and eqv hashtables.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define ht (make-eq-hashtable))
(hashtable-hash-function ht) ⇒ #f
(eq? (hashtable-equivalence-function ht) eq?) ⇒ #t

(define ht (make-hashtable string-hash string=?))
(eq? (hashtable-hash-function ht) string-hash) ⇒ #t
(eq? (hashtable-equivalence-function ht) string=?) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s279" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(equal-hash <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-hash <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-ci-hash <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(symbol-hash <em>symbol</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>an exact nonnegative integer hash value</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These procedures are hash functions suitable for use with the appropriate Scheme predicate: <code>equal?</code> for <code>equal-hash</code>, <code>string=?</code> for <code>string-hash</code>, <code>string-ci=?</code> for <code>string-ci-hash</code>, and <code>symbol=?</code> (or eq?) for <code>symbol-hash</code>. The hash values returned by <code>equal-hash</code>, <code>string-hash</code>, and <code>string-ci-hash</code> are typically dependent on the current structure and contents of the input values and are thus unsuitable if keys are modified while they have associations in a hashtable.</p>
</div>
<div id="objects:s280" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-set! <em>hashtable</em> <em>key</em> <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>hashtable</em></code> must be a mutable hashtable. <code><em>key</em></code> should be an appropriate key for the hashtable&#8217;s hash and equivalence functions. <code><em>obj</em></code> may be any Scheme object.</p>
</div>
<div class="paragraph">
<p><code>hashtable-set!</code> associates <code><em>key</em></code> with <code><em>obj</em></code> in <code><em>hashtable</em></code>, replacing the existing association, if any.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define ht (make-eq-hashtable))
(hashtable-set! ht 'a 73)</code></pre>
</div>
</div>
<div id="objects:s281" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-ref <em>hashtable</em> <em>key</em> <em>default</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>key</em></code> should be an appropriate key for the hashtable&#8217;s hash and equivalence functions. <code><em>default</em></code> may be any Scheme object.</p>
</div>
<div class="paragraph">
<p><code>hashtable-ref</code> returns the value associated with <code><em>key</em></code> in <code><em>hashtable</em></code>. If no value is associated with <code><em>key</em></code> in <code><em>hashtable</em></code>, <code>hashtable-ref</code> returns <code><em>default</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))

(define eqht (make-eq-hashtable))
(hashtable-set! eqht p1 73)
(hashtable-ref eqht p1 55) ⇒ 73
(hashtable-ref eqht p2 55) ⇒ 55

(define equalht (make-hashtable equal-hash equal?))
(hashtable-set! equalht p1 73)
(hashtable-ref equalht p1 55) ⇒ 73
(hashtable-ref equalht p2 55) ⇒ 73</code></pre>
</div>
</div>
<div id="objects:s282" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-contains? <em>hashtable</em> <em>key</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if an association for <code><em>key</em></code> exists in <code><em>hashtable</em></code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>key</em></code> should be an appropriate key for the hashtable&#8217;s hash and equivalence functions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 73)
(hashtable-contains? ht p1) ⇒ #t
(hashtable-contains? ht p2) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s283" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-update! <em>hashtable</em> <em>key</em> <em>procedure</em> <em>default</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>hashtable</em></code> must be a mutable hashtable. <code><em>key</em></code> should be an appropriate key for the hashtable&#8217;s hash and equivalence functions. <code><em>default</em></code> may be any Scheme object. <code><em>procedure</em></code> should accept one argument, should return one value, and should not modify <code><em>hashtable</em></code>.</p>
</div>
<div class="paragraph">
<p><code>hashtable-update!</code> applies <code><em>procedure</em></code> to the value associated with <code><em>key</em></code> in <code><em>hashtable</em></code>, or to <code><em>default</em></code> if no value is associated with <code><em>key</em></code> in <code><em>hashtable</em></code>. If <code><em>procedure</em></code> returns, <code>hashtable-update!</code> associates <code><em>key</em></code> with the value returned by <code><em>procedure</em></code>, replacing the old association, if any.</p>
</div>
<div class="paragraph">
<p>A version of <code>hashtable-update!</code> that does not verify that it receives arguments of the proper type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define hashtable-update!
  (lambda (ht key proc value)
    (hashtable-set! ht key
      (proc (hashtable-ref ht key value)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>An implementation may, however, be able to implement <code>hashtable-update!</code> more efficiently by avoiding multiple hash computations and hashtable lookups.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define ht (make-eq-hashtable))
(hashtable-update! ht 'a
  (lambda (x) (* x 2))
  55)
(hashtable-ref ht 'a 0) ⇒ 110
(hashtable-update! ht 'a
  (lambda (x) (* x 2))
  0)
(hashtable-ref ht 'a 0) ⇒ 220</code></pre>
</div>
</div>
<div id="objects:s284" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-delete! <em>hashtable</em> <em>key</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>hashtable</em></code> must be a mutable hashtable. <code><em>key</em></code> should be an appropriate key for the hashtable&#8217;s hash and equivalence functions.</p>
</div>
<div class="paragraph">
<p><code>hashtable-delete!</code> drops any association for <code><em>key</em></code> from <code><em>hashtable</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 73)
(hashtable-contains? ht p1) ⇒ #t
(hashtable-delete! ht p1)
(hashtable-contains? ht p1) ⇒ #f
(hashtable-contains? ht p2) ⇒ #f
(hashtable-delete! ht p2)</code></pre>
</div>
</div>
<div id="objects:s285" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-size <em>hashtable</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>number of entries in <code><em>hashtable</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-size ht) ⇒ 0
(hashtable-set! ht p1 73)
(hashtable-size ht) ⇒ 1
(hashtable-delete! ht p1)
(hashtable-size ht) ⇒ 0</code></pre>
</div>
</div>
<div id="objects:s286" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-copy <em>hashtable</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-copy <em>hashtable</em> <em>mutable?</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new hashtable containing the same entries as <code><em>hashtable</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>mutable?</em></code> is present and not false, the copy is mutable; otherwise, the copy is immutable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(hashtable-set! ht p1 "c")
(define ht-copy (hashtable-copy ht))
(hashtable-mutable? ht-copy) ⇒ #f
(hashtable-delete! ht p1)
(hashtable-ref ht p1 #f) ⇒ #f
(hashtable-delete! ht-copy p1) ⇒ <em>exception: not mutable</em>
(hashtable-ref ht-copy p1 #f) ⇒ "c"</code></pre>
</div>
</div>
<div id="objects:s287" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-clear! <em>hashtable</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-clear! <em>hashtable</em> <em>size</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>hashtable</em></code> must be a mutable hashtable. If <code><em>size</em></code> is provided, it must be a nonnegative exact integer.</p>
</div>
<div class="paragraph">
<p><code>hashtable-clear!</code> removes all entries from <code><em>hashtable</em></code>. If size is provided, the hashtable is reset to the given size, as if newly created by one of the hashtable creation operations with size argument <code><em>size</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 "first")
(hashtable-set! ht p2 "second")
(hashtable-size ht) ⇒ 2
(hashtable-clear! ht)
(hashtable-size ht) ⇒ 0
(hashtable-ref ht p1 #f) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s288" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-keys <em>hashtable</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a vector containing the keys in <code><em>hashtable</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The keys may appear in any order in the returned vector.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 "one")
(hashtable-set! ht p2 "two")
(hashtable-set! ht 'q "three")
(hashtable-keys ht) ⇒ #((a . b) q (a . b))</code></pre>
</div>
</div>
<div id="objects:s289" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(hashtable-entries <em>hashtable</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>two vectors: one of keys and a second of values</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs hashtables)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>hashtable-entries</code> returns two values. The first is a vector containing the keys in <code><em>hashtable</em></code>, and the second is a vector containing the corresponding values. The keys and values may appear in any order, but the order is the same for the keys and for the corresponding values.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define ht (make-eq-hashtable))
(define p1 (cons 'a 'b))
(define p2 (cons 'a 'b))
(hashtable-set! ht p1 "one")
(hashtable-set! ht p2 "two")
(hashtable-set! ht 'q "three")
(hashtable-entries ht) ⇒ #((a . b) q (a . b))
                          #("two" "three" "one")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_6.14.">Section 6.14. Enumerations</h3>
<div class="paragraph">
<p>Enumerations are ordered sets of symbols, typically used to name and manipulate options, as with the buffer modes and file options that may be specified when files are created.</p>
</div>
<div id="objects:s290" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(define-enumeration <em>name</em> (<em>symbol</em> ...) <em>constructor</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs enums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>define-enumeration</code> form is a definition and can appear anywhere any other definition can appear.</p>
</div>
<div class="paragraph">
<p>The <code>define-enumeration</code> syntax creates a new enumeration set with the specified symbols in the specified order forming the enumeration&#8217;s universe. It defines a new syntactic form named by <code><em>name</em></code> that may be used to verify that a symbol is in the universe. If <code><em>x</em></code> is in the universe, <code>(<em>name x</em>)</code> evaluates to <code><em>x</em></code>. It is a syntax violation if <code><em>x</em></code> is not in the universe.</p>
</div>
<div class="paragraph">
<p><code>define-enumeration</code> also defines a new syntactic form named by <code><em>constructor</em></code> that may be used to create subsets of the enumeration type. If <code><em>x</em> ...</code> are each in the universe, <code><em>(constructor x</em> ...)</code> evaluates to an enumeration set containing <code><em>x</em> ...</code>. Otherwise, it is a syntax violation. The same symbol may appear more than once in <code><em>x</em> ...</code>, but the resulting set contains only one occurrence of the symbol.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-enumeration weather-element
  (hot warm cold sunny rainy snowy windy)
  weather)

(weather-element hot) ⇒ hot
(weather-element fun) ⇒ _syntax violation_
(weather hot sunny windy) ⇒ #<enum-set>
(enum-set->list (weather rainy cold rainy)) ⇒ (cold rainy)</code></pre>
</div>
</div>
<div id="objects:s291" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-enumeration <em>symbol-list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>an enumeration set</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs enums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure creates a new enumeration type whose universe comprises the elements of <code><em>symbol-list</em></code>, which must be a list of symbols, in the order of their first appearance in the list. It returns the universe of the new enumeration type as an enumeration set.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define positions (make-enumeration '(top bottom above top beside)))
(enum-set->list positions) ⇒ (top bottom above beside)</code></pre>
</div>
</div>
<div id="objects:s292" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(enum-set-constructor <em>enum-set</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>an enumeration-set construction procedure</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs enums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure returns a procedure <code><em>p</em></code> that may be used to create subsets of the universe of <code><em>enum-set</em></code>. <code><em>p</em></code> must be passed a list of symbols, and each element of the list must be an element of the universe of <code><em>enum-set</em></code>. The enumeration set returned by <code><em>p</em></code> contains all and only the symbols in the list it is passed. The value returned by <code><em>p</em></code> may contain elements not in <code><em>enum-set</em></code> if the universe of <code><em>enum-set</em></code> contains those elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define e1 (make-enumeration '(one two three four)))
(define p1 (enum-set-constructor e1))
(define e2 (p1 '(one three)))
(enum-set->list e2) ⇒ (one three)
(define p2 (enum-set-constructor e2))
(define e3 (p2 '(one two four)))
(enum-set->list e3) ⇒ (one two four)</code></pre>
</div>
</div>
<div id="objects:s293" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(enum-set-universe <em>enum-set</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the universe of <code><em>enum-set</em></code>, as an enumeration set</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs enums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define e1 (make-enumeration '(a b c a b c d)))
(enum-set->list (enum-set-universe e1)) ⇒ (a b c d)
(define e2 ((enum-set-constructor e1) '(c)))
(enum-set->list (enum-set-universe e2)) ⇒ (a b c d)</code></pre>
</div>
</div>
<div id="objects:s294" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(enum-set-&gt;list <em>enum-set</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a list of the elements of <code><em>enum-set</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs enums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The symbols in the resulting list appear in the order given to them when the enumeration type of <code>enum-set</code> was created.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define e1 (make-enumeration '(a b c a b c d)))
(enum-set->list e1) ⇒ (a b c d)
(define e2 ((enum-set-constructor e1) '(d c a b)))
(enum-set->list e2) ⇒ (a b c d)</code></pre>
</div>
</div>
<div id="objects:s295" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(enum-set-subset? <em>enum-set<sub>1</sub></em> <em>enum-set<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>enum-set<sub>1</sub></em></code> is a subset of <code><em>enum-set<sub>2</sub></em></code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs enums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An enumeration set <code><em>enum-set<sub>1</sub></em></code> is a subset of an enumeration set <code><em>enum-set<sub>2</sub></em></code> if and only if the universe of <code><em>enum-set<sub>1</sub></em></code> is a subset of the universe of <code><em>enum-set<sub>2</sub></em></code> and each element of <code><em>enum-set<sub>1</sub></em></code> is an element of <code><em>enum-set<sub>2</sub></em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define e1 (make-enumeration '(a b c)))
(define e2 (make-enumeration '(a b c d e)))
(enum-set-subset? e1 e2) ⇒ #t
(enum-set-subset? e2 e1) ⇒ #f
(define e3 ((enum-set-constructor e2) '(a c)))
(enum-set-subset? e3 e1) ⇒ #f
(enum-set-subset? e3 e2) ⇒ #t</code></pre>
</div>
</div>
<div id="objects:s296" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(enum-set=? <em>enum-set<sub>1</sub></em> <em>enum-set<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>enum-set<sub>1</sub></em></code> and <code><em>enum-set<sub>2</sub></em></code> are equivalent, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs enums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Two enumeration sets <code><em>enum-set<sub>1</sub></em></code> and <code><em>enum-set<sub>2</sub></em></code> are equivalent if each is a subset of the other.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define e1 (make-enumeration '(a b c d)))
(define e2 (make-enumeration '(b d c a)))
(enum-set=? e1 e2) ⇒ #t
(define e3 ((enum-set-constructor e1) '(a c)))
(define e4 ((enum-set-constructor e2) '(a c)))
(enum-set=? e3 e4) ⇒ #t
(enum-set=? e3 e2) ⇒ #f</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>enum-set=?</code> could be defined in terms of <code>enum-set-subset?</code> as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define enum-set=?
  (lambda (e1 e2)
    (and (enum-set-subset? e1 e2) (enum-set-subset? e2 e1))))</code></pre>
</div>
</div>
<div id="objects:s297" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(enum-set-member? <em>symbol</em> <em>enum-set</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if symbol is an element of <code><em>enum-set</em></code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs enums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define e1 (make-enumeration '(a b c d e)))
(define e2 ((enum-set-constructor e1) '(d b)))
(enum-set-member? 'c e1) ⇒ #t
(enum-set-member? 'c e2) ⇒ #f</code></pre>
</div>
</div>
<div id="objects:s298" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(enum-set-union <em>enum-set<sub>1</sub></em> <em>enum-set<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the union of <code><em>enum-set<sub>1</sub></em></code> and <code><em>enum-set<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(enum-set-intersection <em>enum-set<sub>1</sub></em> <em>enum-set<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the intersection of <code><em>enum-set<sub>1</sub></em></code> and <code><em>enum-set<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(enum-set-difference <em>enum-set<sub>1</sub></em> <em>enum-set<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the difference of <code><em>enum-set<sub>1</sub></em></code> and <code><em>enum-set<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs enums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>enum-set<sub>1</sub></em></code> and <code><em>enum-set<sub>2</sub></em></code> must have the same enumeration type. Each procedure returns a new enumeration set representing the union, intersection, or difference of the two sets.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define e1 (make-enumeration '(a b c d)))
(define e2 ((enum-set-constructor e1) '(a c)))
(define e3 ((enum-set-constructor e1) '(b c)))
(enum-set->list (enum-set-union e2 e3)) ⇒ (a b c)
(enum-set->list (enum-set-intersection e2 e3)) ⇒ (c)
(enum-set->list (enum-set-difference e2 e3)) ⇒ (a)
(enum-set->list (enum-set-difference e3 e2)) ⇒ (b)
(define e4 (make-enumeration '(b d c a)))
(enum-set-union e1 e4) ⇒ <em>exception: different enumeration types</em></code></pre>
</div>
</div>
<div id="objects:s299" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(enum-set-complement <em>enum-set</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the complement of <code><em>enum-set</em></code> relative to its universe</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs enums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define e1 (make-enumeration '(a b c d)))
(enum-set->list (enum-set-complement e1)) ⇒ ()
(define e2 ((enum-set-constructor e1) '(a c)))
(enum-set->list (enum-set-complement e2)) ⇒ (b d)</code></pre>
</div>
</div>
<div id="objects:s300" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(enum-set-projection <em>enum-set<sub>1</sub></em> <em>enum-set<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the projection of <code><em>enum-set<sub>1</sub></em></code> into the universe of <code><em>enum-set<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs enums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Any elements of <code><em>enum-set<sub>1</sub></em></code> not in the universe of <code><em>enum-set<sub>2</sub></em></code> are dropped. The result is of the same enumeration type as <code><em>enum-set<sub>2</sub></em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define e1 (make-enumeration '(a b c d)))
(define e2 (make-enumeration '(a b c d e f g)))
(define e3 ((enum-set-constructor e1) '(a d)))
(define e4 ((enum-set-constructor e2) '(a c e g)))
(enum-set->list (enum-set-projection e4 e3)) ⇒ (a c)
(enum-set->list
  (enum-set-union e3
    (enum-set-projection e4 e3))) ⇒ (a c d)</code></pre>
</div>
</div>
<div id="objects:s301" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(enum-set-indexer <em>enum-set</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a procedure that returns the index of a symbol in the universe of <code><em>enum-set</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs enums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>enum-set-indexer</code> returns a procedure <code><em>p</em></code> that, when applied to a symbol in the universe of <code><em>enum-set</em></code>, returns the index of the symbol (zero-based) in the ordered set of symbols that form the universe. If applied to a symbol not in the universe, <code><em>p</em></code> returns <code>#f</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define e1 (make-enumeration '(a b c d)))
(define e2 ((enum-set-constructor e1) '(a d)))
(define p (enum-set-indexer e2))
(list (p 'a) (p 'c) (p 'e)) ⇒ (0 2 #f)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chp_input_and_output">Chapter 7. Input and Output</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/ch7.png" alt="ch7">
</div>
</div>
<div class="paragraph">
<p>All input and output operations are performed through <em>ports</em>. A port is a pointer into a (possibly infinite) stream of data (often a file), an opening through which programs may draw bytes or characters from the stream or place bytes or characters into the stream. A port may be an input port, an output port, or both simultaneously.</p>
</div>
<div class="paragraph">
<p>Ports are first-class objects, like any other object in Scheme. Like procedures, ports do not have a printed representation the way strings and numbers do. There are initially three ports: the current input port, current output port, and current error port, which are textual ports connected to the process&#8217;s standard input, standard output, and standard error streams. Several ways to open new ports are provided.</p>
</div>
<div class="paragraph">
<p>An input port often points to a finite stream, e.g., an input file stored on disk. If one of the input operations, e.g., <code>get-u8</code>, <code>get-char</code>, or <code>get-datum</code>, is asked to read from a port that has reached the end of a finite stream, it returns a special <em>eof</em> (end of file) <em>object</em>. The predicate <code>eof-object?</code> may be used to determine if the value returned from the input operation is the eof object.</p>
</div>
<div class="paragraph">
<p>Ports are either <em>binary</em> or <em>textual</em>. A binary port allows a program to read or write 8-bit unsigned bytes, or "octets," from or to the underlying stream. A textual port allows a program to read or write characters.</p>
</div>
<div class="paragraph">
<p>In many cases, the underlying stream is organized as a sequence of bytes, but these bytes should be treated as encodings for characters. In this case, a textual port may be created with a <em>transcoder</em> to decode bytes to characters (for input) or encode characters to bytes (for output). A transcoder encapsulates a <em>codec</em> that determines how characters are represented as bytes. Three standard codecs are provided: a <em>latin-1</em> codec, a Unicode <em>utf-8</em> codec, and a Unicode <em>utf-16</em> codec. For the <em>latin-1</em> encoding, each character is represented by exactly one byte. For <em>utf-8</em>, each character is represented by from one to four bytes, and for <em>utf-16</em>, each character is represented by two or four bytes.</p>
</div>
<div class="paragraph">
<p>A transcoder also encapsulates an <em>eol style</em> that determines whether and how line endings are recognized. If the eol style is <code>none</code>, no line endings are recognized. The six other standard eol styles are the following:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>lf</code>
</td>
<td class="hdlist2">
<p>line-feed character</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>cr</code>
</td>
<td class="hdlist2">
<p>carriage-return character</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>nel</code>
</td>
<td class="hdlist2">
<p>Unicode next-line character</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>ls</code>
</td>
<td class="hdlist2">
<p>Unicode line-separator character</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>crlf</code>
</td>
<td class="hdlist2">
<p>carriage return followed by line feed, and</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>crnel</code>
</td>
<td class="hdlist2">
<p>carriage return followed by next line</p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The eol style affects input and output operations differently. For input, any eol style except <code>none</code> causes each of the line-ending characters or two-character sequences to be converted into a single line-feed character. For output, any eol style except <code>none</code> causes line-feed characters to be converted into the specific one- or two-character sequence associated with the eol style. In the input direction, all eol styles except <code>none</code> are equivalent, while in the output direction, the eol styles <code>none</code> and <code>lf</code> are equivalent.</p>
</div>
<div class="paragraph">
<p>In addition to the codec and eol style, a transcoder encapsulates just one other piece of information: an <em>error-handling mode</em> that determines what happens if a decoding or encoding error occurs, i.e., if a sequence of bytes cannot be converted to a character with the encapsulated codec in the input direction or a character cannot be converted to a sequence of bytes with the encapsulated codec in the output direction. The error-handling mode is <code>ignore</code>, <code>raise</code>, or <code>replace</code>. If the error-handling mode is <code>ignore</code>, the offending sequence of bytes or the character is ignored. If the error-handling mode is <code>raise</code>, an exception with condition type <code>i/o-decoding</code> or <code>i/o-encoding</code> is raised; in the input direction, the port is positioned beyond the sequence of bytes. If the error-handling mode is <code>replace</code>, a replacement character or character encoding is produced: in the input direction, the replacement character is U+FFFD, while in the output direction, the replacement is either the encoding of U+FFFD for <code>utf-8</code> and <code>utf-16</code> codecs or the encoding of the question-mark character ( ? ) for the <code>latin-1</code> codec.</p>
</div>
<div class="paragraph">
<p>A port may be buffered for efficiency, to eliminate the overhead of a call into the operating system for each byte or character. Three standard buffer modes are supported: <em>block</em>, <em>line</em>, and <em>none</em>. With block buffering, input is drawn from a stream and output is sent to the stream in chunks of some implementation-dependent size. With line buffering, buffering is performed on a line-by-line basis or on some other implementation-dependent basis. Line buffering is typically distinguished from block buffering only for textual output ports; there are no line divisions in binary ports, and input is likely to be drawn from a stream as it becomes available. With buffer-mode none, no buffering is performed, so output is sent immediately to the stream and input is drawn only as needed.</p>
</div>
<div class="paragraph">
<p>The remainder of this chapter covers operations on transcoders, file ports, standard ports, string and bytevector ports, custom ports, general port operations, input operations, output operations, convenience I/O, filesystem operations, and conversions between bytevectors and strings.</p>
</div>
<div class="sect2">
<h3 id="section_7.1.">Section 7.1. Transcoders</h3>
<div class="paragraph">
<p>As described above, transcoders encapsulate three values: a codec, an eol style, and an error-handling mode. This section describes the procedures that create or operate on transcoders and the values that transcoders encapsulate.</p>
</div>
<div id="io:s19" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-transcoder <em>codec</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-transcoder <em>codec</em> <em>eol-style</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-transcoder <em>codec</em> <em>eol-style</em> <em>error-handling-mode</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a transcoder encapsulating <code><em>codec</em></code>, <code><em>eol-style</em></code>, and <code><em>error-handling-mode</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>eol-style</em></code> must be a valid eol-style symbol (<code>lf</code>, <code>cr</code>, <code>nel</code>, <code>ls</code>, <code>crlf</code>, <code>crnel</code>, or <code>none</code>); it defaults to the native eol-style for the platform. <code><em>error-handling-mode</em></code> must be a valid error-handling-mode symbol (<code>ignore</code>, <code>raise</code>, or <code>replace</code>) and defaults to <code>replace</code>.</p>
</div>
<div id="io:s20" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(transcoder-codec <em>transcoder</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the codec encapsulated in <code><em>transcoder</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(transcoder-eol-style <em>transcoder</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the eol-style symbol encapsulated in <code><em>transcoder</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(transcoder-error-handling-mode <em>transcoder</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the error-handling-mode symbol encapsulated in <code><em>transcoder</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="io:s21" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(native-transcoder)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the native transcoder</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The native transcoder is implementation-dependent and may vary by platform or locale.</p>
</div>
<div id="io:s22" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(latin-1-codec)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a codec for ISO 8859-1 (Latin 1) character encodings</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(utf-8-codec)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a codec for Unicode UTF-8 character encodings</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(utf-16-codec)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a codec for Unicode UTF-16 character encodings</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="io:s23" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(eol-style <em>symbol</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>symbol</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>symbol</em></code> must be one of the symbols <code>lf</code>, <code>cr</code>, <code>nel</code>, <code>ls</code>, <code>crlf</code>, <code>crnel</code>, or <code>none</code>. The expression <code>(eol-style <em>symbol</em>)</code> is equivalent to the expression <code>(quote <em>symbol</em>)</code> except the former checks at expansion time that <code><em>symbol</em></code> is one of the eol-style symbols. The <code>eol-style</code> syntax provides useful documentation as well.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(eol-style crlf) ⇒ crlf
(eol-style lfcr) ⇒ <em>syntax violation</em></code></pre>
</div>
</div>
<div id="io:s24" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(native-eol-style)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the native eol style</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The native eol style is implementation-dependent and may vary by platform or locale.</p>
</div>
<div id="io:s25" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(error-handling-mode <em>symbol</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>symbol</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>symbol</em></code> must be one of the symbols <code>ignore</code>, <code>raise</code>, or <code>replace</code>. The expression <code>(error-handling-mode <em>symbol</em>)</code> is equivalent to the expression <code>(quote <em>symbol</em>)</code> except that the former checks at expansion time that <code><em>symbol</em></code> is one of the error-handling-mode symbols. The <code>error-handling-mode</code> syntax provides useful documentation as well.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(error-handling-mode replace) ⇒ replace
(error-handling-mode relpace) ⇒ <em>syntax violation</em></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_7.2.">Section 7.2. Opening Files</h3>
<div class="paragraph">
<p>The procedures in this section are used for opening file ports. Procedures for opening other kinds of ports, e.g., string ports or custom ports, are described in subsequent sections.</p>
</div>
<div class="paragraph">
<p>Each of the file-open operations accepts a <code><em>path</em></code> argument that names the file to be opened. It must be a string or some other implementation-dependent value that names a file.</p>
</div>
<div class="paragraph">
<p>Some of the file-open procedures accept optional <code><em>options</em></code>, <code><em>b-mode</em></code>, and <code><em>?transcoder</em></code> arguments. <code><em>options</em></code> must be an enumeration set over the symbols constituting valid file options described in the <code>file-options</code> entry below, and it defaults to the value of <code>(file-options)</code>. <code><em>b-mode</em></code> must be a valid buffer mode described in the <code>buffer-mode</code> entry below, and it defaults to <code>block</code>. <code><em>?transcoder</em></code> must be a transcoder or <code>#f</code>; if it is a transcoder, the open operation returns a transcoded port for the underlying binary file, while if it is <code>#f</code> (the default), the open operation returns a binary port.</p>
</div>
<div class="paragraph">
<p>Binary ports created by the procedures in this section support the <code>port-position</code> and <code>set-port-position!</code> operations. Whether textual ports created by the procedures in this section support these operations is implementation-dependent.</p>
</div>
<div id="io:s26" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(file-options <em>symbol</em> &#8230;&#8203;)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a file-options enumeration set</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>File-options enumeration sets may be passed to file-open operations to control aspects of the open operation. There are three standard file options: <code>no-create</code>, <code>no-fail</code>, and <code>no-truncate</code>, which affect only file-open operations that create output (including input/output) ports.</p>
</div>
<div class="paragraph">
<p>With the default file options, i.e., the value of <code>(file-options)</code>, when a program attempts to open a file for output, an exception is raised with condition type <code>i/o-file-already-exists</code> if the file already exists, and the file is created if it does not already exist. If the <code>no-fail</code> option is included, no exception is raised if the file already exists; instead, the file is opened and truncated to zero length. If the <code>no-create</code> option is included, the file is not created if it does not exist; instead, an exception is raised with condition type <code>i/o-file-does-not-exist</code>. The <code>no-create</code> option implies the <code>no-fail</code> option. The <code>no-truncate</code> option is relevant only if the <code>no-fail</code> option is included or implied, in which case if an existing file is opened, it is not truncated, but the port&#8217;s position is still set to the beginning of the file.</p>
</div>
<div class="paragraph">
<p>It is perhaps easier to imagine that the default file options are the imaginary option symbols <code>create</code>, <code>fail-if-exists</code>, and <code>truncate</code>; <code>no-create</code> removes <code>create</code>, <code>no-fail</code> removes <code>fail-if-exists</code>, and <code>no-truncate</code> removes <code>truncate</code>.</p>
</div>
<div class="paragraph">
<p>Implementations may support additional file option symbols. Chez Scheme, for example, supports options that control whether the file is or should be compressed, whether it is locked for exclusive access, and what permissions are given to the file if it is created <a href="#ref9">[9]</a>.</p>
</div>
<div id="io:s27" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(buffer-mode <em>symbol</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>symbol</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>symbol</em></code> must be one of the symbols <code>block</code>, <code>line</code>, or <code>none</code>. The expression <code>(buffer-mode <em>symbol</em>)</code> is equivalent to the expression <code>(quote <em>symbol</em>)</code> except that the former checks at expansion time that <code><em>symbol</em></code> is one of the buffer-mode symbols. The <code>buffer-mode</code> syntax provides useful documentation as well.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(buffer-mode block) ⇒ block
(buffer-mode cushion) ⇒ <em>syntax violation</em></code></pre>
</div>
</div>
<div id="io:s28" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(buffer-mode? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a valid buffer mode, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(buffer-mode? 'block) ⇒ #t
(buffer-mode? 'line) ⇒ #t
(buffer-mode? 'none) ⇒ #t
(buffer-mode? 'something-else) ⇒ #f</code></pre>
</div>
</div>
<div id="io:s29" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-file-input-port <em>path</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-file-input-port <em>path</em> <em>options</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-file-input-port <em>path</em> <em>options</em> <em>b-mode</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-file-input-port <em>path</em> <em>options</em> <em>b-mode</em> <em>?transcoder</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new input port for the named file</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>?transcoder</em></code> is present and not <code>#f</code>, it must be a transcoder, and this procedure returns a textual input port whose transcoder is <code><em>?transcoder</em></code>. Otherwise, this procedure returns a binary input port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.</p>
</div>
<div id="io:s30" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-file-output-port <em>path</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-file-output-port <em>path</em> <em>options</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-file-output-port <em>path</em> <em>options</em> <em>b-mode</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-file-output-port <em>path</em> <em>options</em> <em>b-mode</em> <em>?transcoder</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new output port for the named file</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>?transcoder</em></code> is present and not <code>#f</code>, it must be a transcoder, and this procedure returns a textual output port whose transcoder is <code><em>?transcoder</em></code>. Otherwise, this procedure returns a binary output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.</p>
</div>
<div id="io:s31" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-file-input/output-port <em>path</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-file-input/output-port <em>path</em> <em>options</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-file-input/output-port <em>path</em> <em>options</em> <em>b-mode</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-file-input/output-port <em>path</em> <em>options</em> <em>b-mode</em> <em>?transcoder</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new input/output port for the named file</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>?transcoder</em></code> is present and not <code>#f</code>, it must be a transcoder, and this procedure returns a textual input/output port whose transcoder is <code><em>?transcoder</em></code>. Otherwise, this procedure returns a binary input/output port. See the lead-in to this section for a description of the constraints on and effects of the other arguments.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_7.3.">Section 7.3. Standard Ports</h3>
<div class="paragraph">
<p>The procedures described in this section return ports that are attached to a process&#8217;s standard input, standard output, and standard error streams. The first set returns "ready-made" textual ports with implementation-dependent transcoders (if any) and buffer modes. The second set creates fresh binary ports and can be used either for binary input/output or, with the help of <code>transcoded-port</code>, for textual input/output with program-supplied transcoders and buffer modes.</p>
</div>
<div id="io:s32" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(current-input-port)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the current input port</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(current-output-port)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the current output port</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(current-error-port)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the current error port</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The current-input, current-output, and current-error ports return pre-built textual ports that are initially associated with a process&#8217;s standard input, standard output, and standard error streams.</p>
</div>
<div class="paragraph">
<p>The values returned by <code>current-input-port</code> and <code>current-output-port</code> can be altered temporarily by the convenience I/O procedures <code>with-input-from-file</code> and <code>with-output-to-file</code> (<a href="#section_7.9.">Section 7.9</a>).</p>
</div>
<div id="io:s33" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(standard-input-port)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a fresh binary input port connected to the standard input stream</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(standard-output-port)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a fresh binary output port connected to the standard output stream</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(standard-error-port)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a fresh binary output port connected to the standard error stream</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Because ports may be buffered, confusion can result if operations on more than one port attached to one of a process&#8217;s standard streams are interleaved. Thus, these procedures are typically appropriate only when a program no longer needs to use any existing ports attached to the standard streams.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_7.4.">Section 7.4. String and Bytevector Ports</h3>
<div class="paragraph">
<p>The procedures in this section allow bytevectors and strings to be used as input or output streams.</p>
</div>
<div class="paragraph">
<p>Binary ports created by the procedures in this section support the <code>port-position</code> and <code>set-port-position!</code> operations. Whether textual ports created by the procedures in this section support these operations is implementation-dependent.</p>
</div>
<div id="io:s34" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-bytevector-input-port <em>bytevector</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-bytevector-input-port <em>bytevector</em> <em>?transcoder</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new input port that draws input from <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>?transcoder</em></code> is present and not <code>#f</code>, it must be a transcoder, and this procedure returns a textual input port whose transcoder is <code><em>?transcoder</em></code>. Otherwise, this procedure returns a binary input port.</p>
</div>
<div class="paragraph">
<p>The effect of modifying <code><em>bytevector</em></code> after this procedure is called is unspecified.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([ip (open-bytevector-input-port #vu8(1 2))])
  (let* ([x1 (get-u8 ip)] [x2 (get-u8 ip)] [x3 (get-u8 ip)])
    (list x1 x2 (eof-object? x3)))) ⇒ (1 2 #t)</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is no need to close a bytevector port; it&#8217;s storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open bytevector port does not tie up any operating system resources.</p>
</div>
<div id="io:s35" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-string-input-port <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new textual input port that draws input from <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The effect of modifying <code><em>string</em></code> after this procedure is called is unspecified. The new port may or may not have a transcoder, and if it does, the transcoder is implementation-dependent. While not required, implementations are encouraged to support <code>port-position</code> and <code>set-port-position!</code> for string ports.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(get-line (open-string-input-port "hi.\nwhat's up?\n")) ⇒ "hi."</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is no need to close a string port; it&#8217;s storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open string port does not tie up any operating system resources.</p>
</div>
<div id="io:s36" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-bytevector-output-port)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-bytevector-output-port <em>?transcoder</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>two values, a new output port and an extraction procedure</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>?transcoder</em></code> is present and not <code>#f</code>, it must be a transcoder, and the port value is a textual output port whose transcoder is <code><em>?transcoder</em></code>. Otherwise, the port value is a binary output port.</p>
</div>
<div class="paragraph">
<p>The extraction procedure is a procedure that, when called without arguments, creates a bytevector containing the accumulated bytes in the port, clears the port of its accumulated bytes, resets its position to zero, and returns the bytevector. The accumulated bytes include any bytes written beyond the end of the current position, if the position has been set back from its maximum extent.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let-values ([(op g) (open-bytevector-output-port)])
  (put-u8 op 15)
  (put-u8 op 73)
  (put-u8 op 115)
  (set-port-position! op 2)
  (let ([bv1 (g)])
    (put-u8 op 27)
    (list bv1 (g)))) ⇒ (#vu8(15 73 115) #vu8(27))</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is no need to close a bytevector port; it&#8217;s storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open bytevector port does not tie up any operating system resources.</p>
</div>
<div id="io:s37" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-string-output-port)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>two values, a new textual output port and an extraction procedure</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The extraction procedure is a procedure that, when called without arguments, creates a string containing the accumulated characters in the port, clears the port of its accumulated characters, resets its position to zero, and returns the string. The accumulated characters include any characters written beyond the end of the current position, if the position has been set back from its maximum extent. While not required, implementations are encouraged to support <code>port-position</code> and <code>set-port-position!</code> for string ports.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let-values ([(op g) (open-string-output-port)])
  (put-string op "some data")
  (let ([str1 (g)])
    (put-string op "new stuff")
    (list str1 (g)))) ⇒ ("some data" "new stuff")</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is no need to close a string port; it&#8217;s storage will be reclaimed automatically when it is no longer needed, as with any other object, and an open string port does not tie up any operating system resources.</p>
</div>
<div id="io:s38" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(call-with-bytevector-output-port <em>procedure</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(call-with-bytevector-output-port <em>procedure</em> <em>?transcoder</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a bytevector containing the accumulated bytes</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>?transcoder</em></code> is present and not <code>#f</code>, it must be a transcoder, and <code><em>procedure</em></code> is called with a textual bytevector output port whose transcoder is <code><em>?transcoder</em></code>. Otherwise, <code><em>procedure</em></code> is called with a binary bytevector output port. If <code><em>procedure</em></code> returns, a bytevector containing the bytes accumulated in the port is created, the accumulated bytes are cleared from the port, the port&#8217;s position is reset to zero, and the bytevector is returned from <code>call-with-bytevector-output-port</code>. These actions occur each time <code><em>procedure</em></code> returns, if it returns multiple times due to the invocation of a continuation created while <code><em>procedure</em></code> is active.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([tx (make-transcoder (latin-1-codec) (eol-style lf)
            (error-handling-mode replace))])
  (call-with-bytevector-output-port
    (lambda (p) (put-string p "abc"))
    tx)) ⇒ #vu8(97 98 99)</code></pre>
</div>
</div>
<div id="io:s39" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(call-with-string-output-port <em>procedure</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a string containing the accumulated characters</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>procedure</em></code> is called with one argument, a string output port. If <code><em>procedure</em></code> returns, a string containing the characters accumulated in the port is created, the accumulated characters are cleared from the port, the port&#8217;s position is reset to zero, and the string is returned from <code>call-with-string-output-port</code>. These actions occur each time <code><em>procedure</em></code> returns, if it returns multiple times due to the invocation of a continuation created while <code><em>procedure</em></code> is active.</p>
</div>
<div id="io:s40" class="paragraph">
<p><code>call-with-string-output-port</code> can be used along with <code>put-datum</code> to define a procedure, <code>object-&gt;string</code>, that returns a string containing the printed representation of an object.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define (object->string x)
  (call-with-string-output-port
    (lambda (p) (put-datum p x))))

(object->string (cons 'a '(b c))) ⇒ "(a b c)"</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_7.5.">Section 7.5. Opening Custom Ports</h3>
<div id="io:s41" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-custom-binary-input-port <em>id</em> <em>r!</em> <em>gp</em> <em>sp!</em> <em>close</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new custom binary input port</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-custom-binary-output-port <em>id</em> <em>w!</em> <em>gp</em> <em>sp!</em> <em>close</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new custom binary output port</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-custom-binary-input/output-port <em>id</em> <em>r!</em> <em>w!</em> <em>gp</em> <em>sp!</em> <em>close</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new custom binary input/output port</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These procedures allow programs to create ports from arbitrary byte streams. <code><em>id</em></code> must be a string naming the new port; the name is used for informational purposes only, and an implementation may choose to include it in the printed syntax, if any, of a custom port. <code><em>r!</em></code> and <code><em>w!</em></code> must be procedures, while <code><em>gp</em></code>, <code><em>sp!</em></code>, and <code><em>close</em></code> must each be a procedure or <code>#f</code>. These arguments are described below.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><em>r!</em></code></dt>
<dd>
<p>is called to draw input from the custom port, e.g., to support <code>get-u8</code> or <code>get-bytevector-n</code>. It is called with three arguments: <code><em>bytevector</em></code>, <code><em>start</em></code>, and <code><em>n</em></code>. <code><em>start</em></code> will be a nonnegative exact integer, <code><em>n</em></code> will be a positive exact integer, and the sum of <code><em>start</em></code> and <code><em>n</em></code> will not exceed the length of <code><em>bytevector</em></code>. If the byte stream is at end of file, <code><em>r!</em></code> should return exact 0. Otherwise, it should read at least one and at most <code><em>n</em></code> bytes from the stream, store these bytes in consecutive locations of <code><em>bytevector</em></code> starting at <code><em>start</em></code>, and return as an exact positive integer the number of bytes actually read.</p>
</dd>
<dt class="hdlist1"><code><em>w!</em></code></dt>
<dd>
<p>is called to send output to the port, e.g., to support <code>put-u8</code> or <code>put-bytevector</code>. It is called with three arguments: <code><em>bytevector</em></code>, <code><em>start</em></code>, and <code><em>n</em></code>. <code><em>start</em></code> and <code><em>n</em></code> will be nonnegative exact integers, and the sum of <code><em>start</em></code> and <code><em>n</em></code> will not exceed the length of <code><em>bytevector</em></code>. <code><em>w!</em></code> should write up to <code><em>n</em></code> consecutive bytes from <code><em>bytevector</em></code> starting at <code><em>start</em></code> and return, as an exact nonnegative integer, the number of bytes actually written.</p>
</dd>
<dt class="hdlist1"><code><em>gp</em></code></dt>
<dd>
<p>is called to query the port&#8217;s position. If it is <code>#f</code>, the port will not support <code>port-position</code>. If it is not <code>#f</code>, it will be passed zero arguments and should return the current position as a displacement in bytes from the start of the byte stream as an exact nonnegative integer.</p>
</dd>
<dt class="hdlist1"><code><em>sp!</em></code></dt>
<dd>
<p>is called to set the port&#8217;s position. If it is <code>#f</code>, the port will not support <code>set-port-position!</code>. If it is not <code>#f</code>, it will be passed one argument, an exact nonnegative integer representing the new position as a displacement in bytes from the start of the byte stream, and it should set the position to this value.</p>
</dd>
<dt class="hdlist1"><code><em>close</em></code></dt>
<dd>
<p>is called to close the byte stream. If it is <code>#f</code>, no action will be taken to close the byte stream when the new port is closed. If it is not <code>#f</code>, it will be passed zero arguments and should take whatever actions are necessary to close the byte stream.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>If the new port is an input/output port and does not provide either a <code><em>gp</em></code> or <code><em>sp!</em></code> procedure, it may not be possible for the implementation to position the port properly if an output operation occurs after an input operation, due to input buffering that must be done to support <code>lookahead-u8</code> and is often done anyway for efficiency. For the same reason, a call to <code>port-position</code> after an input operation may not return an accurate position if the <code><em>sp!</em></code> procedure is not provided. Thus, programs that create custom binary input/output ports should generally provide both <code><em>gp</em></code> and <code><em>sp!</em></code> procedures.</p>
</div>
<div id="io:s42" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-custom-textual-input-port <em>id</em> <em>r!</em> <em>gp</em> <em>sp!</em> <em>close</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new custom textual input port</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-custom-textual-output-port <em>id</em> <em>w!</em> <em>gp</em> <em>sp!</em> <em>close</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new custom textual output port</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-custom-textual-input/output-port <em>id</em> <em>r!</em> <em>w!</em> <em>gp</em> <em>sp!</em> <em>close</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new custom textual input/output port</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These procedures allow programs to create ports from arbitrary character streams. <code><em>id</em></code> must be a string naming the new port; the name is used for informational purposes only, and an implementation may choose to include it in the printed syntax, if any, of a custom port. <code><em>r!</em></code> and <code><em>w!</em></code> must be procedures, while <code><em>gp</em></code>, <code><em>sp!</em></code>, and <code><em>close</em></code> must each be a procedure or <code>#f</code>. These arguments are described below.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code><em>r!</em></code></dt>
<dd>
<p>is called to draw input from the port, e.g., to support <code>get-char</code> or <code>get-string-n</code>. It is called with three arguments: <code><em>string</em></code>, <code><em>start</em></code>, and <code><em>n</em></code>. <code><em>start</em></code> will be a nonnegative exact integer, <code><em>n</em></code> will be a positive exact integer, and the sum of <code><em>start</em></code> and <code><em>n</em></code> will not exceed the length of <code><em>string</em></code>. If the character stream is at end of file, <code><em>r!</em></code> should return exact 0. Otherwise, it should read at least one and at most <code><em>n</em></code> characters from the stream, store these characters in consecutive locations of <code><em>string</em></code> starting at <code><em>start</em></code>, and return as an exact positive integer the number of characters actually read.</p>
</dd>
<dt class="hdlist1"><code><em>w!</em></code></dt>
<dd>
<p>is called to send output to the port, e.g., to support <code>put-char</code> or <code>put-string</code>. It is called with three arguments: <code><em>string</em></code>, <code><em>start</em></code>, and <code><em>n</em></code>. <code><em>start</em></code> and <code><em>n</em></code> will be nonnegative exact integers, and the sum of <code><em>start</em></code> and <code><em>n</em></code> will not exceed the length of <code><em>string</em></code>. <code><em>w!</em></code> should write up to <code><em>n</em></code> consecutive characters from <code><em>string</em></code> starting at <code><em>start</em></code> and return, as an exact nonnegative integer, the number of characters actually written.</p>
</dd>
<dt class="hdlist1"><code><em>gp</em></code></dt>
<dd>
<p>is called to query the port&#8217;s position. If it is <code>#f</code>, the port will not support <code>port-position</code>. If it is not <code>#f</code>, it will be passed zero arguments and should return the current position, which may be an arbitrary value.</p>
</dd>
<dt class="hdlist1"><code><em>sp!</em></code></dt>
<dd>
<p>is called to set the port&#8217;s position. If it is <code>#f</code>, the port will not support <code>set-port-position!</code>. If it is not <code>#f</code>, it will be passed one argument, <code><em>pos</em></code>, a value representing the new position. If <code><em>pos</em></code> is the result of a previous call to <code><em>gp</em></code>, <code><em>sp!</em></code> should set the position to <code><em>pos</em></code>.</p>
</dd>
<dt class="hdlist1"><code><em>close</em></code></dt>
<dd>
<p>is called to close the character stream. If it is <code>#f</code>, no action will be taken to close the character stream when the new port is closed. If it is not <code>#f</code>, it will be passed zero arguments and should take whatever actions are necessary to close the character stream.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>If the new port is an input/output port, it may not be possible for the implementation to position the port properly if an output operation occurs after an input operation, even if the <code><em>gp</em></code> and <code><em>sp!</em></code> procedures are provided, due to input buffering that must be done to support <code>lookahead-char</code> and is often done anyway for efficiency. Since the representations of port positions are not specified, it is not possible for the implementation to adjust the <code><em>gp</em></code> return value to account for the number of buffered characters. For the same reason, a call to <code>port-position</code> after an input operation may not return an accurate position, even if the <code><em>sp!</em></code> procedure is provided.</p>
</div>
<div class="paragraph">
<p>It should, however, be possible to perform output reliably after reading if the position is reset to the starting position. Thus, programs that create custom textual input/output ports should generally provide both <code><em>gp</em></code> and <code><em>sp!</em></code> procedures, and consumers of these ports should obtain the starting position via <code>port-position</code> before any input operations and reset the position back to the starting position before doing any output operations.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_7.6.">Section 7.6. Port Operations</h3>
<div class="paragraph">
<p>This section describes a variety of operations on ports that do not directly involve either reading from or writing to a port. The input and output operations are described in subsequent sections.</p>
</div>
<div id="io:s43" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(port? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a port, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="io:s44" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(input-port? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is an input or input/output port, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(output-port? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is an output or input/output port, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="io:s45" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(binary-port? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a binary port, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(textual-port? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a textual port, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="io:s46" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(close-port <em>port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>port</em></code> is not already closed, <code>close-port</code> closes it, first flushing any buffered bytes or characters to the underlying stream if the port is an output port. Once a port has been closed, no more input or output operations may be performed on the port. Because the operating system may place limits on the number of file ports open at one time or restrict access to an open file, it is good practice to close any file port that will no longer be used for input or output. If the port is an output port, closing the port explicitly also ensures that buffered data is written to the underlying stream. Some Scheme implementations close file ports automatically after they become inaccessible to the program or when the Scheme program exits, but it is best to close file ports explicitly whenever possible. Closing a port that has already been closed has no effect.</p>
</div>
<div id="io:s47" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(transcoded-port <em>binary-port</em> <em>transcoder</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new textual port with the same byte stream as <code><em>binary-port</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure returns a new textual port with transcoder <code><em>transcoder</em></code> and the same underlying byte stream as <code><em>binary-port</em></code>, positioned at the current position of <code><em>binary-port</em></code>.</p>
</div>
<div class="paragraph">
<p>As a side effect of creating the textual port, <code><em>binary-port</em></code> is closed to prevent read or write operations on <code><em>binary-port</em></code> from interfering with read and write operations on the new textual port. The underlying byte stream remains open, however, until the textual port is closed.</p>
</div>
<div id="io:s48" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(port-transcoder <em>port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the transcoder associated with <code><em>port</em></code> if any, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure always returns <code>#f</code> for binary ports and may return <code>#f</code> for some textual ports.</p>
</div>
<div id="io:s49" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(port-position <em>port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the port&#8217;s current position</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(port-has-port-position? <em>port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the port supports <code>port-position</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A port may allow queries to determine its current position in the underlying stream of bytes or characters. If so, the procedure <code>port-has-port-position?</code> returns <code>#t</code> and <code>port-position</code> returns the current position. For binary ports, the position is always an exact nonnegative integer byte displacement from the start of the byte stream. For textual ports, the representation of a position is unspecified; it may not be an exact nonnegative integer and, even if it is, it may not represent either a byte or character displacement in the underlying stream. The position may be used at some later time to reset the position if the port supports <code>set-port-position!</code>. If <code>port-position</code> is called on a port that does not support it, an exception with condition type <code>&amp;assertion</code> is raised.</p>
</div>
<div id="io:s50" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(set-port-position! <em>port</em> <em>pos</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(port-has-set-port-position!? <em>port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the port supports <code>set-port-position!</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A port may allow its current position to be moved directly to a different position in the underlying stream of bytes or characters. If so, the procedure <code>port-has-set-port-position!?</code> returns <code>#t</code> and <code>set-port-position!</code> changes the current position. For binary ports, the position <code><em>pos</em></code> must be an exact nonnegative integer byte displacement from the start of the byte stream. For textual ports, the representation of a position is unspecified, as described in the entry for <code>port-position</code> above, but <code><em>pos</em></code> must be an appropriate position for the textual port, which is usually guaranteed to be the case only if it was obtained from a call to <code>port-position</code> on the same port. If <code>set-port-position!</code> is called on a port that does not support it, an exception with condition type <code>&amp;assertion</code> is raised.</p>
</div>
<div class="paragraph">
<p>If <code><em>port</em></code> is a binary output port and the position is set beyond the current end of the data in the underlying stream, the stream is not extended until new data is written at that position. If new data is written at that position, the contents of each intervening position is unspecified. Binary ports created with <code>open-file-output-port</code> and <code>open-file-input/output-port</code> can always be extended in this manner within the limits of the underlying operating system. In other cases, attempts to set the port beyond the current end of data in the underlying object may result in an exception with condition type <code>&amp;i/o-invalid-position</code>.</p>
</div>
<div id="desc:call-with-port" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(call-with-port <em>port</em> <em>procedure</em>)</code> <a id="io:s51"></a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values returned by <code><em>procedure</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>call-with-port</code> calls <code><em>procedure</em></code> with <code><em>port</em></code> as the only argument. If <code><em>procedure</em></code> returns, <code>call-with-port</code> closes the port and returns the values returned by <code><em>procedure</em></code>.</p>
</div>
<div class="paragraph">
<p><code>call-with-port</code> does not automatically close the port if a continuation created outside of <code><em>procedure</em></code> is invoked, since it is possible that another continuation created inside of <code><em>procedure</em></code> will be invoked at a later time, returning control to <code><em>procedure</em></code>. If <code><em>procedure</em></code> does not return, an implementation is free to close the port only if it can prove that the output port is no longer accessible.</p>
</div>
<div class="paragraph">
<p>The example below copies the contents of infile to outfile, overwriting outfile if it exists. Unless an error occurs, the ports are closed after the copy has been completed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(call-with-port (open-file-input-port "infile" (file-options)
                  (buffer-mode block) (native-transcoder))
  (lambda (ip)
    (call-with-port (open-file-output-port "outfile"
                      (file-options no-fail)
                      (buffer-mode block)
                      (native-transcoder))
      (lambda (op)
        (do ([c (get-char ip) (get-char ip)])
            ((eof-object? c))
          (put-char op c))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>A definition of <code>call-with-port</code> is given on <a href="#defn:call-with-port">page 135</a>.</p>
</div>
<div id="io:s52" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(output-port-buffer-mode <em>port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the symbol representing the buffer mode of <code><em>port</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="section_7.7.">Section 7.7. Input Operations</h3>
<div class="paragraph">
<p>Procedures whose primary purpose is to read data from an input port are described in this section, along with related procedures for recognizing or creating end-of-file (eof) objects.</p>
</div>
<div id="io:s53" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(eof-object? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is an eof object, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The end-of-file object is returned by input operations, e.g., <code>get-datum</code>, when an input port has reached the end of input.</p>
</div>
<div id="io:s54" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(eof-object)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(eof-object? (eof-object)) ⇒ #t</code></pre>
</div>
</div>
<div id="io:s55" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(get-u8 <em>binary-input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the next byte from <code><em>binary-input-port</em></code>, or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>binary-input-port</em></code> is at end of file, the eof object is returned. Otherwise, the next available byte is returned as an unsigned 8-bit quantity, i.e., an exact unsigned integer less than or equal to 255, and the port&#8217;s position is advanced one byte.</p>
</div>
<div id="io:s56" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(lookahead-u8 <em>binary-input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the next byte from <code><em>binary-input-port</em></code>, or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>binary-input-port</em></code> is at end of file, the eof object is returned. Otherwise, the next available byte is returned as an unsigned 8-bit quantity, i.e., an exact unsigned integer less than or equal to 255. In contrast to <code>get-u8</code>, <code>lookahead-u8</code> does not consume the byte it reads from the port, so if the next operation on the port is a call to <code>lookahead-u8</code> or <code>get-u8</code>, the same byte is returned.</p>
</div>
<div id="io:s57" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(get-bytevector-n <em>binary-input-port</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a nonempty bytevector containing up to <code><em>n</em></code> bytes, or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer. If <code><em>binary-input-port</em></code> is at end of file, the eof object is returned. Otherwise, <code>get-bytevector-n</code> reads (as if with <code>get-u8</code>) as many bytes, up to <code><em>n</em></code>, as are available before the port is at end of file, and returns a new (nonempty) bytevector containing these bytes. The port&#8217;s position is advanced past the bytes read.</p>
</div>
<div id="io:s58" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(get-bytevector-n! <em>binary-input-port</em> <em>bytevector</em> <em>start</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the count of bytes read or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>start</em></code> and <code><em>n</em></code> must be exact nonnegative integers, and the sum of <code><em>start</em></code> and <code><em>n</em></code> must not exceed the length of <code><em>bytevector</em></code>.</p>
</div>
<div class="paragraph">
<p>If <code><em>binary-input-port</em></code> is at end of file, the eof object is returned. Otherwise, <code>get-bytevector-n!</code> reads (as if with <code>get-u8</code>) as many bytes, up to <code><em>n</em></code>, as are available before the port is at end of file, stores the bytes in consecutive locations of <code><em>bytevector</em></code> starting at <code><em>start</em></code>, and returns the count of bytes read as an exact positive integer. The port&#8217;s position is advanced past the bytes read.</p>
</div>
<div id="io:s59" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(get-bytevector-some <em>binary-input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a nonempty bytevector or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>binary-input-port</em></code> is at end of file, the eof object is returned. Otherwise, <code>get-bytevector-some</code> reads (as if with <code>get-u8</code>) at least one byte and possibly more, and returns a bytevector containing these bytes. The port&#8217;s position is advanced past the bytes read. The maximum number of bytes read by this operation is implementation-dependent.</p>
</div>
<div id="io:s60" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(get-bytevector-all <em>binary-input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a nonempty bytevector or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>binary-input-port</em></code> is at end of file, the eof object is returned. Otherwise, <code>get-bytevector-all</code> reads (as if with <code>get-u8</code>) all of the bytes available before the port is at end of file and returns a bytevector containing these bytes. The port&#8217;s position is advanced past the bytes read.</p>
</div>
<div id="io:s61" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(get-char <em>textual-input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the next character from <code><em>textual-input-port</em></code>, or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>textual-input-port</em></code> is at end of file, the eof object is returned. Otherwise, the next available character is returned and the port&#8217;s position is advanced one character. If <code><em>textual-input-port</em></code> is a transcoded port, the position in the underlying byte stream may advance by more than one byte.</p>
</div>
<div id="io:s62" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(lookahead-char <em>textual-input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the next character from <code><em>textual-input-port</em></code>, or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>textual-input-port</em></code> is at end of file, the eof object is returned. Otherwise, the next available character is returned. In contrast to <code>get-char</code>, <code>lookahead-char</code> does not consume the character it reads from the port, so if the next operation on the port is a call to <code>lookahead-char</code> or <code>get-char</code>, the same character is returned.</p>
</div>
<div class="paragraph">
<p><code>lookahead-char</code> is provided for applications requiring one character of lookahead. The procedure <code>get-word</code> defined below returns the next word from a textual input port as a string, where a word is defined to be a sequence of alphabetic characters. Since <code>get-word</code> does not know until it sees one character beyond the word that it has read the entire word, it uses <code>lookahead-char</code> to determine the next character and <code>get-char</code> to consume the character.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define get-word
  (lambda (p)
    (list->string
      (let f ()
        (let ([c (lookahead-char p)])
          (cond
            [(eof-object? c) '()]
            [(char-alphabetic? c) (get-char p) (cons c (f))]
            [else '()]))))))</code></pre>
</div>
</div>
<div id="io:s63" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(get-string-n <em>textual-input-port</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a nonempty string containing up to <code><em>n</em></code> characters, or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>n</em></code> must be an exact nonnegative integer. If <code><em>textual-input-port</em></code> is at end of file, the eof object is returned. Otherwise, <code>get-string-n</code> reads (as if with <code>get-char</code>) as many characters, up to <code><em>n</em></code>, as are available before the port is at end of file, and returns a new (nonempty) string containing these characters. The port&#8217;s position is advanced past the characters read.</p>
</div>
<div id="io:s64" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(get-string-n! <em>textual-input-port</em> <em>string</em> <em>start</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the count of characters read or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>start</em></code> and <code><em>n</em></code> must be exact nonnegative integers, and the sum of <code><em>start</em></code> and <code><em>n</em></code> must not exceed the length of <code><em>string</em></code>.</p>
</div>
<div class="paragraph">
<p>If <code><em>textual-input-port</em></code> is at end of file, the eof object is returned. Otherwise, <code>get-string-n!</code> reads (as if with <code>get-char</code>) as many characters, up to <code><em>n</em></code>, as are available before the port is at end of file, stores the characters in consecutive locations of <code><em>string</em></code> starting at <code><em>start</em></code>, and returns the count of characters read as an exact positive integer. The port&#8217;s position is advanced past the characters read.</p>
</div>
<div class="paragraph">
<p><code>get-string-n!</code> may be used to implement <code>string-set!</code> and <code>string-fill!</code>, as illustrated below, although this is not its primary purpose.</p>
</div>
<div id="backdoor-string-fill" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define string-set!
  (lambda (s i c)
    (let ([sip (open-string-input-port (string c))])
      (get-string-n! sip s i 1)
     ; return unspecified values:
      (if #f #f))))

(define string-fill!
  (lambda (s c)
    (let ([n (string-length s)])
      (let ([sip (open-string-input-port (make-string n c))])
        (get-string-n! sip s 0 n)
       ; return unspecified values:
        (if #f #f)))))

(let ([x (make-string 3)])
  (string-fill! x #\-)
  (string-set! x 2 #\))
  (string-set! x 0 #\;)
  x) ⇒ ";-)"</code></pre>
</div>
</div>
<div id="io:s65" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(get-string-all <em>textual-input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a nonempty string or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>textual-input-port</em></code> is at end of file, the eof object is returned. Otherwise, <code>get-string-all</code> reads (as if with <code>get-char</code>) all of the characters available before the port is at end of file and returns a string containing these characters. The port&#8217;s position is advanced past the characters read.</p>
</div>
<div id="io:s66" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(get-line <em>textual-input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a string or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>textual-input-port</em></code> is at end of file, the eof object is returned. Otherwise, <code>get-line</code> reads (as if with <code>get-char</code>) all of the characters available before the port is at end of file or a line-feed character has been read and returns a string containing all but the line-feed character of the characters read. The port&#8217;s position is advanced past the characters read.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([sip (open-string-input-port "one\ntwo\n")])
  (let* ([s1 (get-line sip)] [s2 (get-line sip)])
    (list s1 s2 (port-eof? sip)))) ⇒ ("one" "two" #t)

(let ([sip (open-string-input-port "one\ntwo")])
  (let* ([s1 (get-line sip)] [s2 (get-line sip)])
    (list s1 s2 (port-eof? sip)))) ⇒ ("one" "two" #t)</code></pre>
</div>
</div>
<div id="io:s67" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(get-datum <em>textual-input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a Scheme datum object or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure scans past whitespace and comments to find the start of the external representation of a datum. If <code><em>textual-input-port</em></code> reaches end of file before the start of the external representation of a datum is found, the eof object is returned.</p>
</div>
<div class="paragraph">
<p>Otherwise, <code>get-datum</code> reads as many characters as necessary, and no more, to parse a single datum, and returns a newly allocated object whose structure is determined by the external representation. The port&#8217;s position is advanced past the characters read. If an end-of-file is reached before the external representation of the datum is complete, or an unexpected character is read, an exception is raised with condition types <code>&amp;lexical</code> and <code>i/o-read</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([sip (open-string-input-port "; a\n\n one (two)\n")])
  (let* ([x1 (get-datum sip)]
         [c1 (lookahead-char sip)]
         [x2 (get-datum sip)])
    (list x1 c1 x2 (port-eof? sip)))) ⇒ (one #\space (two) #f)</code></pre>
</div>
</div>
<div id="io:s68" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(port-eof? <em>input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>input-port</em></code> is at end-of-file, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure is similar to <code>lookahead-u8</code> on a binary input port or <code>lookahead-char</code> on a textual input port, except that instead of returning the next byte/character or eof object, it returns a boolean value to indicate whether the value would be the eof object.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_7.8.">Section 7.8. Output Operations</h3>
<div class="paragraph">
<p>Procedures whose primary purpose is to send data to an output port are described in this section.</p>
</div>
<div id="io:s69" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(put-u8 <em>binary-output-port</em> <em>octet</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>octet</em></code> must be an exact nonnegative integer less than or equal to 255. This procedure writes <code><em>octet</em></code> to <code><em>binary-output-port</em></code>, advancing the port&#8217;s position by one byte.</p>
</div>
<div id="io:s70" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(put-bytevector <em>binary-output-port</em> <em>bytevector</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(put-bytevector <em>binary-output-port</em> <em>bytevector</em> <em>start</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(put-bytevector <em>binary-output-port</em> <em>bytevector</em> <em>start</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>start</em></code> and <code><em>n</em></code> must be nonnegative exact integers, and the sum of <code><em>start</em></code> and <code><em>n</em></code> must not exceed the length of <code><em>bytevector</em></code>. If not supplied, <code><em>start</em></code> defaults to zero and <code><em>n</em></code> defaults to the difference between the length of <code><em>bytevector</em></code> and <code><em>start</em></code>.</p>
</div>
<div class="paragraph">
<p>This procedure writes the <code><em>n</em></code> bytes of <code><em>bytevector</em></code> starting at <code><em>start</em></code> to the port and advances the its position past the end of the bytes written.</p>
</div>
<div id="io:s71" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(put-char <em>textual-output-port</em> <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure writes <code><em>char</em></code> to <code><em>textual-output-port</em></code>, advancing the port&#8217;s position by one character. If <code><em>textual-output-port</em></code> is a transcoded port, the position in the underlying byte stream may advance by more than one byte.</p>
</div>
<div id="io:s72" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(put-string <em>textual-output-port</em> <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(put-string <em>textual-output-port</em> <em>string</em> <em>start</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(put-string <em>textual-output-port</em> <em>string</em> <em>start</em> <em>n</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>start</em></code> and <code><em>n</em></code> must be nonnegative exact integers, and the sum of <code><em>start</em></code> and <code><em>n</em></code> must not exceed the length of <code><em>string</em></code>. If not supplied, <code><em>start</em></code> defaults to zero and <code><em>n</em></code> defaults to the difference between the length of <code><em>string</em></code> and <code><em>start</em></code>.</p>
</div>
<div class="paragraph">
<p>This procedure writes the <code><em>n</em></code> characters of <code><em>string</em></code> starting at <code><em>start</em></code> to the port and advances the its position past the end of the characters written.</p>
</div>
<div id="io:s73" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(put-datum <em>textual-output-port</em> <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure writes an external representation of <code><em>obj</em></code> to <code><em>textual-output-port</em></code>. If <code><em>obj</em></code> does not have an external representation as a datum, the behavior is unspecified. The precise external representation is implementation-dependent, but when <code><em>obj</em></code> does have an external representation as a datum, <code>put-datum</code> should produce a sequence of characters that can later be read by <code>get-datum</code> as an object equivalent (in the sense of <code>equal?</code>) to <code><em>obj</em></code>. See <a href="#section_12.5.">Section 12.5</a> for an implementation of <code>put-datum</code>, <code>write</code>, and <code>display</code>.</p>
</div>
<div id="io:s74" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(flush-output-port <em>output-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure forces any bytes or characters in the buffer associated with <code><em>output-port</em></code> to be sent immediately to the underlying stream.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_7.9.">Section 7.9. Convenience I/O</h3>
<div class="paragraph">
<p>The procedures in this section are referred to as "convenience" I/O operators because they present a somewhat simplified interface for creating and interacting with textual ports. They also provide backward compatibility with the Revised<sup>5</sup> Report, which did not support separate binary and textual I/O.</p>
</div>
<div class="paragraph">
<p>The convenience input/output procedures may be called with or without an explicit port argument. If called without an explicit port argument, the current input or output port is used, as appropriate. For example, <code>(read-char)</code> and <code>(read-char (current-input-port))</code> both return the next character from the current input port.</p>
</div>
<div id="io:s75" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-input-file <em>path</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new input port</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>path</em></code> must be a string or some other implementation-dependent value that names a file. <code>open-input-file</code> creates a new textual input port for the file named by <code><em>path</em></code>, as if by <code>open-file-input-port</code> with default options, an implementation-dependent buffer mode, and an implementation-dependent transcoder.</p>
</div>
<div class="paragraph">
<p>The following shows the use of <code>open-input-file</code>, <code>read</code>, and <code>close-port</code> in an expression that gathers a list of objects from the file named by "myfile.ss."</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([p (open-input-file "myfile.ss")])
  (let f ([x (read p)])
    (if (eof-object? x)
        (begin
          (close-port p)
          '())
        (cons x (f (read p))))))</code></pre>
</div>
</div>
<div id="io:s76" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(open-output-file <em>path</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a new output port</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>path</em></code> must be a string or some other implementation-dependent value that names a file. <code>open-output-file</code> creates a new output port for the file named by <code><em>path</em></code>, as if by <code>open-file-output-port</code> with default options, an implementation-dependent buffer mode, and an implementation-dependent transcoder.</p>
</div>
<div class="paragraph">
<p>The following shows the use of <code>open-output-file</code> to write a list of objects (the value of <code>list-to-be-printed</code>), separated by newlines, to the file named by "myfile.ss."</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([p (open-output-file "myfile.ss")])
  (let f ([ls list-to-be-printed])
    (if (not (null? ls))
        (begin
          (write (car ls) p)
          (newline p)
          (f (cdr ls)))))
  (close-port p))</code></pre>
</div>
</div>
<div id="io:s77" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(call-with-input-file <em>path</em> <em>procedure</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values returned by <code><em>procedure</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>path</em></code> must be a string or some other implementation-dependent value that names a file. <code><em>procedure</em></code> should accept one argument.</p>
</div>
<div class="paragraph">
<p><code>call-with-input-file</code> creates a new input port for the file named by <code><em>path</em></code>, as if with <code>open-input-file</code>, and passes this port to <code><em>procedure</em></code>. If <code><em>procedure</em></code> returns, <code>call-with-input-file</code> closes the input port and returns the values returned by <code><em>procedure</em></code>.</p>
</div>
<div class="paragraph">
<p><code>call-with-input-file</code> does not automatically close the input port if a continuation created outside of <code><em>procedure</em></code> is invoked, since it is possible that another continuation created inside of <code><em>procedure</em></code> will be invoked at a later time, returning control to <code><em>procedure</em></code>. If <code><em>procedure</em></code> does not return, an implementation is free to close the input port only if it can prove that the input port is no longer accessible. As shown in <a href="#section_5.6.">Section 5.6</a>, <code>dynamic-wind</code> may be used to ensure that the port is closed if a continuation created outside of <code><em>procedure</em></code> is invoked.</p>
</div>
<div class="paragraph">
<p>The following example shows the use of <code>call-with-input-file</code> in an expression that gathers a list of objects from the file named by "myfile.ss." It is functionally equivalent to the example given for <code>open-input-file</code> above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(call-with-input-file "myfile.ss"
  (lambda (p)
    (let f ([x (read p)])
      (if (eof-object? x)
          '()
          (cons x (f (read p)))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>call-with-input-file</code> might be defined without error checking as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define call-with-input-file
  (lambda (filename proc)
    (let ([p (open-input-file filename)])
      (let-values ([v* (proc p)])
        (close-port p)
        (apply values v*)))))</code></pre>
</div>
</div>
<div id="io:s78" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(call-with-output-file <em>path</em> <em>procedure</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values returned by <code><em>procedure</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>path</em></code> must be a string or some other implementation-dependent value that names a file. <code><em>procedure</em></code> should accept one argument.</p>
</div>
<div class="paragraph">
<p><code>call-with-output-file</code> creates a new output port for the file named by <code><em>path</em></code>, as if with <code>open-output-file</code>, and passes this port to <code><em>procedure</em></code>. If <code><em>procedure</em></code> returns, <code>call-with-output-file</code> closes the output port and returns the values returned by <code><em>procedure</em></code>.</p>
</div>
<div class="paragraph">
<p><code>call-with-output-file</code> does not automatically close the output port if a continuation created outside of <code><em>procedure</em></code> is invoked, since it is possible that another continuation created inside of <code><em>procedure</em></code> will be invoked at a later time, returning control to <code><em>procedure</em></code>. If <code><em>procedure</em></code> does not return, an implementation is free to close the output port only if it can prove that the output port is no longer accessible. As shown in <a href="#section_5.6.">Section 5.6</a>, <code>dynamic-wind</code> may be used to ensure that the port is closed if a continuation created outside of <code><em>procedure</em></code> is invoked.</p>
</div>
<div class="paragraph">
<p>The following shows the use of <code>call-with-output-file</code> to write a list of objects (the value of <code>list-to-be-printed</code>), separated by newlines, to the file named by "myfile.ss." It is functionally equivalent to the example given for <code>open-output-file</code> above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(call-with-output-file "myfile.ss"
  (lambda (p)
    (let f ([ls list-to-be-printed])
      (unless (null? ls)
        (write (car ls) p)
        (newline p)
        (f (cdr ls))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>call-with-output-file</code> might be defined without error checking as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define call-with-output-file
  (lambda (filename proc)
    (let ([p (open-output-file filename)])
      (let-values ([v* (proc p)])
        (close-port p)
        (apply values v*)))))</code></pre>
</div>
</div>
<div id="io:s79" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(with-input-from-file <em>path</em> <em>thunk</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values returned by <code><em>thunk</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>path</em></code> must be a string or some other implementation-dependent value that names a file. <code><em>thunk</em></code> must be a procedure and should accept zero arguments.</p>
</div>
<div class="paragraph">
<p><code>with-input-from-file</code> temporarily changes the current input port to be the result of opening the file named by <code><em>path</em></code>, as if with <code>open-input-file</code>, during the application of <code><em>thunk</em></code>. If <code><em>thunk</em></code> returns, the port is closed and the current input port is restored to its old value.</p>
</div>
<div class="paragraph">
<p>The behavior of <code>with-input-from-file</code> is unspecified if a continuation created outside of <code><em>thunk</em></code> is invoked before <code><em>thunk</em></code> returns. An implementation may close the port and restore the current input port to its old value---but it may not.</p>
</div>
<div id="io:s80" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(with-output-to-file <em>path</em> <em>thunk</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values returned by <code><em>thunk</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>path</em></code> must be a string or some other implementation-dependent value that names a file. <code><em>thunk</em></code> must be a procedure and should accept zero arguments.</p>
</div>
<div class="paragraph">
<p><code>with-output-to-file</code> temporarily rebinds the current output port to be the result of opening the file named by <code><em>path</em></code>, as if with <code>open-output-file</code>, during the application of <code><em>thunk</em></code>. If <code><em>thunk</em></code> returns, the port is closed and the current output port is restored to its old value.</p>
</div>
<div class="paragraph">
<p>The behavior of <code>with-output-to-file</code> is unspecified if a continuation created outside of <code><em>thunk</em></code> is invoked before <code><em>thunk</em></code> returns. An implementation may close the port and restore the current output port to its old value---but it may not.</p>
</div>
<div id="io:s81" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(read)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(read <em>textual-input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a Scheme datum object or the eof object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>textual-input-port</em></code> is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to <code>get-datum</code>.</p>
</div>
<div id="io:s82" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(read-char)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(read-char <em>textual-input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the next character from <code><em>textual-input-port</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>textual-input-port</em></code> is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to <code>get-char</code>.</p>
</div>
<div id="io:s83" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(peek-char)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(peek-char <em>textual-input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the next character from <code><em>textual-input-port</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>textual-input-port</em></code> is not supplied, it defaults to the current input port. This procedure is otherwise equivalent to <code>lookahead-char</code>.</p>
</div>
<div id="io:s84" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(write <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(write <em>obj</em> <em>textual-output-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>textual-output-port</em></code> is not supplied, it defaults to the current output port. This procedure is otherwise equivalent to <code>put-datum</code>, with the arguments reversed. See <a href="#section_12.5.">Section 12.5</a> for an implementation of <code>put-datum</code>, <code>write</code>, and <code>display</code>.</p>
</div>
<div id="io:s85" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(display <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(display <em>obj</em> <em>textual-output-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>textual-output-port</em></code> is not supplied, it defaults to the current output port.</p>
</div>
<div class="paragraph">
<p><code>display</code> is similar to <code>write</code> or <code>put-datum</code> but prints strings and characters found within <code><em>obj</em></code> directly. Strings are printed without quotation marks or escapes for special characters, as if by <code>put-string</code>, and characters are printed without the <code>#\</code> notation, as if by <code>put-char</code>. With <code>display</code>, the three-element list <code>(a b c)</code> and the two-element list <code>("a b" c)</code> both print as <code>(a b c)</code>. Because of this, <code>display</code> should not be used to print objects that are intended to be read with <code>read</code>. <code>display</code> is useful primarily for printing messages, with <code><em>obj</em></code> most often being a string. See <a href="#section_12.5.">Section 12.5</a> for an implementation of <code>put-datum</code>, <code>write</code>, and <code>display</code>.</p>
</div>
<div id="io:s86" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(write-char <em>char</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(write-char <em>char</em> <em>textual-output-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>textual-output-port</em></code> is not supplied, it defaults to the current output port. This procedure is otherwise equivalent to <code>put-char</code>, with the arguments reversed.</p>
</div>
<div id="io:s87" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(newline)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(newline <em>textual-output-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If <code><em>textual-output-port</em></code> is not supplied, it defaults to the current output port. <code>newline</code> sends a line-feed character to the port.</p>
</div>
<div id="io:s88" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(close-input-port <em>input-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(close-output-port <em>output-port</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io simple)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>close-input-port</code> closes an input port, and <code>close-output-port</code> closes an output port. These procedures are provided for backward compatibility with the Revised<sup>5</sup> Report; they are not actually more convenient to use than <code>close-port</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_7.10.">Section 7.10. Filesystem Operations</h3>
<div class="paragraph">
<p>Scheme has two standard operations, beyond file input/output, for interacting with the filesystem: <code>file-exists?</code> and <code>delete-file</code>. Most implementations support additional operations.</p>
</div>
<div id="io:s89" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(file-exists? <em>path</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the file named by <code><em>path</em></code> exists, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs files)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>path</em></code> must be a string or some other implementation-dependent value that names a file. Whether <code>file-exists?</code> follows symbolic links is unspecified.</p>
</div>
<div id="io:s90" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(delete-file <em>path</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>unspecified</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs files)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>path</em></code> must be a string or some other implementation-dependent value that names a file. <code>delete-file</code> removes the file named by <code><em>path</em></code> if it exists and can be deleted, otherwise it raises an exception with condition type <code>&amp;i/o-filename</code>. Whether <code>delete-file</code> follows symbolic links is unspecified.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_7.11.">Section 7.11. Bytevector/String Conversions</h3>
<div class="paragraph">
<p>The procedures described in this section encode or decode character sequences, converting from strings to bytevectors or bytevectors to strings. They do not necessarily involve input/output, though they might be implemented using bytevector input and output ports.</p>
</div>
<div class="paragraph">
<p>The first two procedures, <code>bytevector-&gt;string</code> and <code>string-&gt;bytevector</code>, take an explicit transcoder argument that determines the character encodings, eol styles, and error-handling modes. The others perform specific Unicode conversions with an implicit eol-style of <code>none</code> and error-handling mode of <code>replace</code>.</p>
</div>
<div id="io:s91" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bytevector-&gt;string <em>bytevector</em> <em>transcoder</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a string containing the characters encoded in <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This operation, at least in effect, creates a bytevector input port with the specified <code><em>transcoder</em></code> from which all of the available characters are read, as if by <code>get-string-all</code>, and placed into the output string.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([tx (make-transcoder (utf-8-codec) (eol-style lf)
            (error-handling-mode replace))])
  (bytevector->string #vu8(97 98 99) tx)) ⇒ "abc"</code></pre>
</div>
</div>
<div id="io:s92" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-&gt;bytevector <em>string</em> <em>transcoder</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a bytevector containing the encodings of the characters in <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This operation, at least in effect, creates a bytevector output port with the specified <code><em>transcoder</em></code> to which all of the characters of <code><em>string</em></code> are written, then extracts a bytevector containing the accumulated bytes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([tx (make-transcoder (utf-8-codec) (eol-style none)
            (error-handling-mode raise))])
  (string->bytevector "abc" tx)) ⇒ #vu8(97 98 99)</code></pre>
</div>
</div>
<div id="io:s93" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-&gt;utf8 <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a bytevector containing the UTF-8 encoding of <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="io:s94" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-&gt;utf16 <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-&gt;utf16 <em>string</em> <em>endianness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-&gt;utf32 <em>string</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(string-&gt;utf32 <em>string</em> <em>endianness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a bytevector containing the specified encoding of <code><em>string</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>endianness</em></code> must be one of the symbols <code>big</code> or <code>little</code>. If <code><em>endianness</em></code> is not provided or is the symbol <code>big</code>, <code>string-&gt;utf16</code> returns the UTF-16BE encoding of <code><em>string</em></code> and <code>string-&gt;utf32</code> returns the UTF-32BE encoding of <code><em>string</em></code>. If <code><em>endianness</em></code> is the symbol <code>little</code>, <code>string-&gt;utf16</code> returns the UTF-16LE encoding of <code><em>string</em></code> and <code>string-&gt;utf32</code> returns the UTF-32LE encoding of <code><em>string</em></code>. No byte-order mark is included in the encoding.</p>
</div>
<div id="io:s95" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(utf8-&gt;string <em>bytevector</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a string containing the UTF-8 decoding of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div id="io:s96" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(utf16-&gt;string <em>bytevector</em> <em>endianness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(utf16-&gt;string <em>bytevector</em> <em>endianness</em> <em>endianness-mandatory?</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(utf32-&gt;string <em>bytevector</em> <em>endianness</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(utf32-&gt;string <em>bytevector</em> <em>endianness</em> <em>endianness-mandatory?</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a string containing the specified decoding of <code><em>bytevector</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs bytevectors)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>endianness</em></code> must be one of the symbols <code>big</code> or <code>little</code>. These procedures return a UTF-16 or UTF-32 decoding of <code><em>bytevector</em></code>, with the endianness of the representation determined from the endianness argument or byte-order mark (BOM). If <code><em>endianness-mandatory?</em></code> is not provided or is <code>#f</code>, the endianness is determined by a BOM at the front of <code><em>bytevector</em></code> or, if no BOM is present, by <code><em>endianness</em></code>. If <code><em>endianness-mandatory?</em></code> is <code>#t</code>, the endianness is determined by <code><em>endianness</em></code>, and, if a BOM appears at the front of <code><em>bytevector</em></code>, it is treated as a regular character encoding.</p>
</div>
<div class="paragraph">
<p>The UTF-16 BOM is the two-byte sequence <code>#xFE</code>, <code>#xFF</code> specifying "big" or the two-byte sequence <code>#xFF</code>, <code>#xFE</code> specifying "little." The UTF-32 BOM is the four-byte sequence <code>#x00</code>, <code>#x00</code>, <code>#xFE</code>, <code>#xFF</code> specifying "big" or the four-byte sequence <code>#xFF</code>, <code>#xFE</code>, <code>#x00</code>, <code>#x00</code> specifying "little."</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chp_syntactic_extension">Chapter 8. Syntactic Extension</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/ch8.png" alt="ch8">
</div>
</div>
<div class="paragraph">
<p><em>Syntactic extensions</em>, or <em>macros</em>, are used to simplify and regularize repeated patterns in a program, to introduce syntactic forms with new evaluation rules, and to perform transformations that help make programs more efficient.</p>
</div>
<div class="paragraph">
<p>A syntactic extension most often takes the form <code>(<em>keyword</em> <em>subform</em> ...)</code>, where <code><em>keyword</em></code> is the identifier that names the syntactic extension. The syntax of each <code><em>subform</em></code> varies from one syntactic extension to another. Syntactic extensions can also take the form of improper lists or even singleton identifiers.</p>
</div>
<div class="paragraph">
<p>New syntactic extensions are defined by associating keywords with transformation procedures, or <em>transformers</em>. Syntactic extensions are defined using <code>define-syntax</code> forms or using <code>let-syntax</code> or <code>letrec-syntax</code>. Transformers may be created using <code>syntax-rules</code>, which allows simple pattern-based transformations to be performed. They may also be ordinary procedures that accept one argument and perform arbitrary computations. In this case, <code>syntax-case</code> is normally used to destructure the input and <code>syntax</code> is normally used to construct the output. The <code>identifier-syntax</code> form and <code>make-variable-transformer</code> procedure allow the creation of transformers that match singleton identifiers and assignments to those identifiers, the former being restricted to simple patterns like <code>syntax-rules</code> and the latter allowing arbitrary computations to be performed.</p>
</div>
<div class="paragraph">
<p>Syntactic extensions are expanded into core forms at the start of evaluation (before compilation or interpretation) by a syntax <em>expander</em>. If the expander encounters a syntactic extension, it invokes the associated transformer to expand the syntactic extension, then repeats the expansion process for the form returned by the transformer. If the expander encounters a core syntactic form, it recursively processes the subforms, if any, and reconstructs the form from the expanded subforms. Information about identifier bindings is maintained during expansion to enforce lexical scoping for variables and keywords.</p>
</div>
<div class="paragraph">
<p>The syntactic extension mechanisms described in this chapter are part of the "syntax-case" system. A portable implementation of the system that also supports libraries and top-level programs is available at <a href="http://www.cs.indiana.edu/syntax-case/" class="bare">http://www.cs.indiana.edu/syntax-case/</a>. A description of the motivations behind and implementation of the system can be found in the article "Syntactic Abstraction in Scheme" <a href="#ref12">[12]</a>. Additional features that have not yet been standardized, including <code>modules</code>, local <code>import</code>, and meta definitions, are described in the <em>Chez Scheme User&#8217;s Guide</em> <a href="#ref9">[9]</a>.</p>
</div>
<div class="sect2">
<h3 id="section_8.1.">Section 8.1. Keyword Bindings</h3>
<div class="paragraph">
<p>This section describes forms that establish bindings between keywords and transformers. Keyword bindings may be established within a top-level program or library body using <code>define-syntax</code> and in any local scope using <code>define-syntax</code>, <code>let-syntax</code>, or <code>letrec-syntax</code>.</p>
</div>
<div id="syntax:s12" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(define-syntax <em>keyword</em> <em>expr</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>expr</em></code> must evaluate to a transformer.</p>
</div>
<div class="paragraph">
<p>The following example defines <code>let*</code> as a syntactic extension, specifying the transformer with <code>syntax-rules</code> (see <a href="#section_8.2.">Section 8.2</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax let*
  (syntax-rules ()
    [(_ () b1 b2 ...) (let () b1 b2 ...)]
    [(_ ((i1 e1) (i2 e2) ...) b1 b2 ...)
     (let ([i1 e1])
       (let* ([i2 e2] ...) b1 b2 ...))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>All bindings established by a set of internal definitions, whether keyword or variable definitions, are visible everywhere within the immediately enclosing body, including within the definitions themselves. For example, the expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ()
  (define even?
    (lambda (x)
      (or (= x 0) (odd? (- x 1)))))
  (define-syntax odd?
    (syntax-rules ()
      [(_ x) (not (even? x))]))
  (even? 10))</code></pre>
</div>
</div>
<div class="paragraph">
<p>is valid and should evaluate to <code>#t</code>.</p>
</div>
<div id="body-expansion" class="paragraph">
<p>The expander processes the initial forms in a <code>library</code>, <code>lambda</code>, or other body from left to right. If it encounters a variable definition, it records the fact that the defined identifier is a variable but defers expansion of the right-hand-side expression until after all of the definitions have been processed. If it encounters a keyword definition, it expands and evaluates the right-hand-side expression and binds the keyword to the resulting transformer. If it encounters an expression, it fully expands all deferred right-hand-side expressions along with the current and remaining body expressions.</p>
</div>
<div class="paragraph">
<p>An implication of the left-to-right processing order is that one internal definition can affect whether a subsequent form is also a definition. For example, the expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ()
  (define-syntax bind-to-zero
    (syntax-rules ()
      [(_ id) (define id 0)]))
  (bind-to-zero x)
  x)</code></pre>
</div>
</div>
<div class="paragraph">
<p>evaluates to <code>0</code>, regardless of any binding for <code>bind-to-zero</code> that might appear outside of the <code>let</code> expression.</p>
</div>
<div id="syntax:s13" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(let-syntax ((<em>keyword</em> <em>expr</em>) ...) <em>form<sub>1</sub></em> <em>form<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(letrec-syntax ((<em>keyword</em> <em>expr</em>) ...) <em>form<sub>1</sub></em> <em>form<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each <code><em>expr</em></code> must evaluate to a transformer. For <code>let-syntax</code> and <code>letrec-syntax</code> both, each <code><em>keyword</em></code> is bound within the forms <code><em>form<sub>1</sub></em> <em>form<sub>2</sub></em> ...</code>. For <code>letrec-syntax</code> the binding scope also includes each <code><em>expr</em></code>.</p>
</div>
<div id="letsyntaximplicitbegin" class="paragraph">
<p>A <code>let-syntax</code> or <code>letrec-syntax</code> form may expand into one or more expressions anywhere expressions are permitted, in which case the resulting expressions are treated as if enclosed in a <code>begin</code> expression. It may also expand into zero or more definitions anywhere definitions are permitted, in which case the definitions are treated as if they appeared in place of the <code>let-syntax</code> or <code>letrec-syntax</code> form.</p>
</div>
<div class="paragraph">
<p>The following example highlights how <code>let-syntax</code> and <code>letrec-syntax</code> differ.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([f (lambda (x) (+ x 1))])
  (let-syntax ([f (syntax-rules ()
                       [(_ x) x])]
               [g (syntax-rules ()
                       [(_ x) (f x)])])
    (list (f 1) (g 1)))) ⇒ (1 2)

(let ([f (lambda (x) (+ x 1))])
  (letrec-syntax ([f (syntax-rules ()
                       [(_ x) x])]
                  [g (syntax-rules ()
                       [(_ x) (f x)])])
    (list (f 1) (g 1)))) ⇒ (1 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The two expressions are identical except that the <code>let-syntax</code> form in the first expression is a <code>letrec-syntax</code> form in the second. In the first expression, the <code>f</code> occurring in <code>g</code> refers to the <code>let</code>-bound variable <code>f</code>, whereas in the second it refers to the keyword <code>f</code> whose binding is established by the <code>letrec-syntax</code> form.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_8.2.">Section 8.2. Syntax-Rules Transformers</h3>
<div class="paragraph">
<p>The <code>syntax-rules</code> form described in this section permits simple transformers to be specified in a convenient manner. These transformers may be bound to keywords using the mechanisms described in <a href="#section_8.1.">Section 8.1</a>. While it is much less expressive than the mechanism described in <a href="#section_8.3.">Section 8.3</a>, it is sufficient for defining many common syntactic extensions.</p>
</div>
<div id="syntax:s14" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(syntax-rules (<em>literal</em> ...) <em>clause</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a transformer</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each <code><em>literal</em></code> must be an identifier other than an underscore ( <code>_</code> ) or ellipsis ( <code>...</code> ). Each clause must take the form below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(<em>pattern</em> <em>template</em>))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each <code><em>pattern</em></code> specifies one possible syntax that the input form might take, and the corresponding <code><em>template</em></code> specifies how the output should appear.</p>
</div>
<div class="paragraph">
<p>Patterns consist of list structure, vector structure, identifiers, and constants. Each identifier within a pattern is either a <code><em>literal</em></code>, a <em>pattern variable</em>, an <em>underscore</em>, or an <em>ellipsis</em>. The identifier <code>_</code> is an underscore, and the identifier <code>...</code> is an ellipsis. Any identifier other than <code>_</code> or <code>...</code> is a literal if it appears in the list of literals <code>(<em>literal</em> ...)</code>; otherwise, it is a pattern variable. Literals serve as auxiliary keywords, such as <code>else</code> in <code>case</code> and <code>cond</code> expressions. List and vector structure within a pattern specifies the basic structure required of the input, the underscore and pattern variables specify arbitrary substructure, and literals and constants specify atomic pieces that must match exactly. Ellipses specify repeated occurrences of the subpatterns they follow.</p>
</div>
<div id="patterns" class="paragraph">
<p>An input form <code><em>F</em></code> matches a pattern <code><em>P</em></code> if and only if</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><em>P</em></code> is an underscore or pattern variable,</p>
</li>
<li>
<p><code><em>P</em></code> is a literal identifier and <code><em>F</em></code> is an identifier with the same binding as determined by the predicate <code>free-identifier=?</code> (<a href="#section_8.3.">Section 8.3</a>),</p>
</li>
<li>
<p><code><em>P</em></code> is of the form <code>(<em>P<sub>1</sub></em> ... <em>P<sub>n</sub></em>)</code> and <code><em>F</em></code> is a list of <em>n</em> elements that match <code><em>P<sub>1</sub></em></code> through <code><em>P<sub>n</sub></em></code>,</p>
</li>
<li>
<p><code><em>P</em></code> is of the form <code>(<em>P<sub>1</sub></em> ... <em>P<sub>n</sub></em> . <em>P<sub>x</sub></em>)</code> and <code><em>F</em></code> is a list or improper list of <em>n</em> or more elements whose first <em>n</em> elements match <code><em>P<sub>1</sub></em></code> through <code><em>P<sub>n</sub></em></code> and whose <em>n</em>th cdr matches <code><em>P<sub>x</sub></em></code>,</p>
</li>
<li>
<p><code><em>P</em></code> is of the form <code>(<em>P<sub>1</sub></em> ... <em>P<sub>k</sub></em> <em>P<sub>e</sub></em> <em>ellipsis</em> <em>P<sub>m+1</sub></em> ... <em>P<sub>n</sub></em>)</code>, where <code><em>ellipsis</em></code> is the identifier <code>...</code> and <code><em>F</em></code> is a proper list of <em>n</em> elements whose first <em>k</em> elements match <code><em>P<sub>1</sub></em></code> through <code><em>P<sub>k</sub></em></code>, whose next <em>m</em> - <em>k</em> elements each match <code><em>P<sub>e</sub></em></code>, and whose remaining <em>n</em> - <em>m</em> elements match <code><em>P<sub>m+1</sub></em></code> through <code><em>P<sub>n</sub></em></code>,</p>
</li>
<li>
<p><code><em>P</em></code> is of the form <code>(<em>P<sub>1</sub></em> ... <em>P<sub>k</sub></em> <em>P<sub>e</sub></em> <em>ellipsis</em> <em>P<sub>m+1</sub></em> ... <em>P<sub>n</sub></em> . <em>P<sub>x</sub></em>)</code>, where <code><em>ellipsis</em></code> is the identifier <code>...</code> and <code><em>F</em></code> is a list or improper list of <em>n</em> elements whose first <em>k</em> elements match <code><em>P<sub>1</sub></em></code> through <code><em>P<sub>k</sub></em></code>, whose next <em>m</em> - <em>k</em> elements each match <code><em>P<sub>e</sub></em></code>, whose next <em>n</em> - <em>m</em> elements match <code><em>P<sub>m+1</sub></em></code> through <code><em>P<sub>n</sub></em></code>, and whose <em>n</em>th and final cdr matches <code><em>P<sub>x</sub></em></code>,</p>
</li>
<li>
<p><code><em>P</em></code> is of the form <code>#(<em>P<sub>1</sub></em> ... <em>P<sub>n</sub></em>)</code> and <code><em>F</em></code> is a vector of <em>n</em> elements that match <code><em>P<sub>1</sub></em></code> through <code><em>P<sub>n</sub></em></code>,</p>
</li>
<li>
<p><code><em>P</em></code> is of the form <code>#(<em>P<sub>1</sub></em> ... <em>P<sub>k</sub></em> <em>P<sub>e</sub></em> <em>ellipsis</em> <em>P<sub>m+1</sub></em> ... <em>P<sub>n</sub></em>)</code>, where <code><em>ellipsis</em></code> is the identifier <code>...</code> and <code><em>F</em></code> is a vector of <em>n</em> elements whose first <em>k</em> elements match <code><em>P<sub>1</sub></em></code> through <code><em>P<sub>k</sub></em></code>, whose next <em>m</em> - <em>k</em> elements each match <code><em>P<sub>e</sub></em></code>, and whose remaining <em>n</em> - <em>m</em> elements match <code><em>P<sub>m+1</sub></em></code> through <code><em>P<sub>n</sub></em></code>, or</p>
</li>
<li>
<p><code><em>P</em></code> is a pattern datum (any nonlist, nonvector, nonsymbol object) and <code><em>F</em></code> is equal to <code><em>P</em></code> in the sense of the <code>equal?</code> procedure.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The outermost structure of a <code>syntax-rules</code> <code><em>pattern</em></code> must actually be in one of the list-structured forms above, although subpatterns of the pattern may be in any of the above forms. Furthermore, the first element of the outermost pattern is ignored, since it is always assumed to be the keyword naming the syntactic form. (These statements do not apply to <code>syntax-case</code>; see <a href="#section_8.3.">Section 8.3</a>.)</p>
</div>
<div class="paragraph">
<p>If an input form passed to a <code>syntax-rules</code> transformer matches the pattern for a given clause, the clause is accepted and the form is transformed as specified by the associated template. As this transformation takes place, pattern variables appearing in the pattern are bound to the corresponding input subforms. Pattern variables appearing within a subpattern followed by one or more ellipses may be bound to a sequence or sequences of zero or more input subforms.</p>
</div>
<div id="syntax:s23" class="paragraph">
<p>A template is a pattern variable, an identifier that is not a pattern variable, a pattern datum, a list of subtemplates <code>(<em>S<sub>1</sub></em> ... <em>S<sub>n</sub></em>)</code>, an improper list of subtemplates <code>(<em>S<sub>1</sub></em> <em>S<sub>2</sub></em> ... <em>S<sub>n</sub></em> . <em>T</em>)</code>, or a vector of subtemplates <code>#(<em>S<sub>1</sub></em> ... <em>S<sub>n</sub></em>)</code>. Each subtemplate <code><em>S<sub>i</sub></em></code> is a template followed by zero or more ellipses. The final element <code><em>T</em></code> of an improper subtemplate list is a template.</p>
</div>
<div class="paragraph">
<p>Pattern variables appearing within a template are replaced in the output by the input subforms to which they are bound. Pattern data and identifiers that are not pattern variables are inserted directly into the output. List and vector structure within the template remains list and vector structure in the output. A subtemplate followed by an ellipsis expands into zero or more occurrences of the subtemplate. The subtemplate must contain at least one pattern variable from a subpattern followed by an ellipsis. (Otherwise, the expander could not determine how many times the subform should be repeated in the output.) Pattern variables that occur in subpatterns followed by one or more ellipses may occur only in subtemplates that are followed by (at least) as many ellipses. These pattern variables are replaced in the output by the input subforms to which they are bound, distributed as specified. If a pattern variable is followed by more ellipses in the template than in the associated pattern, the input form is replicated as necessary.</p>
</div>
<div class="paragraph">
<p>A template of the form <code>(... <em>template</em>)</code> is identical to <code><em>template</em></code>, except that ellipses within the template have no special meaning. That is, any ellipses contained within <code><em>template</em></code> are treated as ordinary identifiers. In particular, the template <code>(... ...)</code> produces a single ellipsis, <code>...</code>. This allows syntactic extensions to expand into forms containing ellipses, including <code>syntax-rules</code> or <code>syntax-case</code> patterns and templates.</p>
</div>
<div class="paragraph">
<p>The definition of <code>or</code> below demonstrates the use of <code>syntax-rules</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax or
  (syntax-rules ()
    [(_) #f]
    [(_ e) e]
    [(_ e1 e2 e3 ...)
     (let ([t e1]) (if t t (or e2 e3 ...)))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The input patterns specify that the input must consist of the keyword and zero or more subexpressions. An underscore ( <code>_</code> ), which is a special pattern symbol that matches any input, is often used for the keyword position to remind the programmer and anyone reading the definition that the keyword position never fails to contain the expected keyword and need not be matched. (In fact, as mentioned above, <code>syntax-rules</code> ignores what appears in the keyword position.) If more than one subexpression is present (third clause), the expanded code both tests the value of the first subexpression and returns the value if it is not false. To avoid evaluating the expression twice, the transformer introduces a binding for the temporary variable <code>t</code>.</p>
</div>
<div class="paragraph">
<p>The expansion algorithm maintains lexical scoping automatically by renaming local identifiers as necessary. Thus, the binding for <code>t</code> introduced by the transformer is visible only within code introduced by the transformer and not within subforms of the input. Similarly, the references to the identifiers <code>let</code> and <code>if</code> are unaffected by any bindings present in the context of the input.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([if #f])
  (let ([t 'okay])
    (or if t))) ⇒ okay</code></pre>
</div>
</div>
<div class="paragraph">
<p>This expression is transformed during expansion to the equivalent of the expression below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">((lambda (if1)
   ((lambda (t1)
      ((lambda (t2)
         (if t2 t2 t1))
       if1))
    'okay))
 #f) ⇒ okay</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this sample expansion, <code>if1</code>, <code>t1</code>, and <code>t2</code> represent identifiers to which <code>if</code> and <code>t</code> in the original expression and <code>t</code> in the expansion of <code>or</code> have been renamed.</p>
</div>
<div class="paragraph">
<p>The definition of a simplified version of <code>cond</code> below (simplified because it requires at least one output expression per clause and does not support the auxiliary keyword <code>=&gt;</code>) demonstrates how auxiliary keywords such as <code>else</code> are recognized in the input to a transformer, via inclusion in the list of literals.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax cond
  (syntax-rules (else)
    [(_ (else e1 e2 ...)) (begin e1 e2 ...)]
    [(_ (e0 e1 e2 ...)) (if e0 (begin e1 e2 ...))]
    [(_ (e0 e1 e2 ...) c1 c2 ...)
     (if e0 (begin e1 e2 ...) (cond c1 c2 ...))]))</code></pre>
</div>
</div>
<div id="syntax:s26" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>_</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>...</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs syntax-case)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These identifiers are auxiliary keywords for <code>syntax-rules</code>, <code>identifier-syntax</code>, and <code>syntax-case</code>. The second ( <code>...</code> ) is also an auxiliary keyword for <code>syntax</code> and <code>quasisyntax</code>. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.</p>
</div>
<div id="syntax:s27" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(identifier-syntax <em>tmpl</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(identifier-syntax (<em>id<sub>1</sub></em> <em>tmpl<sub>1</sub></em>) set! <em>id<sub>2</sub></em> <em>e<sub>2</sub></em>) <em>tmpl<sub>2</sub></em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a transformer</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When a keyword is bound to a transformer produced by the first form of <code>identifier-syntax</code>, references to the keyword within the scope of the binding are replaced by <code><em>tmpl</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ()
  (define-syntax a (identifier-syntax car))
  (list (a '(1 2 3)) a)) ⇒ (1 #&lt;procedure&gt;)</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the first form of <code>identifier-syntax</code>, an apparent assignment of the associated keyword with <code>set!</code> is a syntax violation. The second, more general, form of <code>identifier-syntax</code> permits the transformer to specify what happens when <code>set!</code> is used.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([ls (list 0)])
  (define-syntax a
    (identifier-syntax
      [id (car ls)]
      [(set! id e) (set-car! ls e)]))
  (let ([before a])
    (set! a 1)
    (list before a ls))) ⇒ (0 1 (1))</code></pre>
</div>
</div>
<div id="syntax:s28" class="paragraph">
<p>A definition of <code>identifier-syntax</code> in terms of <code>make-variable-transformer</code> is shown on <a href="#defn:identifier-syntax">page 307</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_8.3.">Section 8.3. Syntax-Case Transformers</h3>
<div class="paragraph">
<p>This section describes a more expressive mechanism for creating transformers, based on <code>syntax-case</code>, a generalized version of <code>syntax-rules</code>. This mechanism permits arbitrarily complex transformations to be specified, including transformations that "bend" lexical scoping in a controlled manner, allowing a much broader class of syntactic extensions to be defined. Any transformer that may be defined using <code>syntax-rules</code> may be rewritten easily to use <code>syntax-case</code> instead; in fact, <code>syntax-rules</code> itself may be defined as a syntactic extension in terms of <code>syntax-case</code>, as demonstrated within the description of <code>syntax</code> below.</p>
</div>
<div id="syntax:s29" class="paragraph">
<p>With this mechanism, transformers are procedures of one argument. The argument is a <em>syntax object</em> representing the form to be processed. The return value is a syntax object representing the output form. A syntax object may be any of the following.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a nonpair, nonvector, nonsymbol value,</p>
</li>
<li>
<p>a pair of syntax objects,</p>
</li>
<li>
<p>a vector of syntax objects, or</p>
</li>
<li>
<p>a wrapped object.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>wrap</em> on a wrapped syntax object contains contextual information about a form in addition to its structure. This contextual information is used by the expander to maintain lexical scoping. The wrap may also contain information used by the implementation to correlate source and object code, e.g., track file, line, and character information through the expansion and compilation process.</p>
</div>
<div class="paragraph">
<p>The contextual information must be present for all identifiers, which is why the definition of syntax object above does not allow symbols unless they are wrapped. A syntax object representing an identifier is itself referred to as an identifier; thus, the term <em>identifier</em> may refer either to the syntactic entity (symbol, variable, or keyword) or to the concrete representation of the syntactic entity as a syntax object.</p>
</div>
<div class="paragraph">
<p>Transformers normally destructure their input with <code>syntax-case</code> and rebuild their output with <code>syntax</code>. These two forms alone are sufficient for defining many syntactic extensions, including any that can be defined using <code>syntax-rules</code>. They are described below along with a set of additional forms and procedures that provide added functionality.</p>
</div>
<div id="syntax:s30" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(syntax-case <em>expr</em> (<em>literal</em> ...) <em>clause</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs syntax-case)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each <code><em>literal</em></code> must be an identifier. Each <code><em>clause</em></code> must take one of the following two forms.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(<em>pattern</em> <em>output-expression</em>)
(<em>pattern</em> <em>fender</em> <em>output-expression</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>syntax-case</code> patterns may be in any of the forms described in <a href="#section_8.2.">Section 8.2</a>.</p>
</div>
<div class="paragraph">
<p><code>syntax-case</code> first evaluates <code><em>expr</em></code>, then attempts to match the resulting value against the pattern from the first <code><em>clause</em></code>. This value may be any Scheme object. If the value matches the pattern and no <code><em>fender</em></code> is present, <code><em>output-expression</em></code> is evaluated and its values returned as the values of the <code>syntax-case</code> expression. If the value does not match the pattern, the value is compared against the next clause, and so on. It is a syntax violation if the value does not match any of the patterns.</p>
</div>
<div class="paragraph">
<p>If the optional <code><em>fender</em></code> is present, it serves as an additional constraint on acceptance of a clause. If the value of the <code>syntax-case</code> <code><em>expr</em></code> matches the pattern for a given clause, the corresponding <code><em>fender</em></code> is evaluated. If <code><em>fender</em></code> evaluates to a true value, the clause is accepted; otherwise, the clause is rejected as if the input had failed to match the pattern. Fenders are logically a part of the matching process, i.e., they specify additional matching constraints beyond the basic structure of an expression.</p>
</div>
<div id="syntax:s32" class="paragraph">
<p>Pattern variables contained within a clause&#8217;s <code><em>pattern</em></code> are bound to the corresponding pieces of the input value within the clause&#8217;s <code><em>fender</em></code> (if present) and <code><em>output-expression</em></code>. Pattern variables occupy the same namespace as program variables and keywords; pattern variable bindings created by <code>syntax-case</code> can shadow (and be shadowed by) program variable and keyword bindings as well as other pattern variable bindings. Pattern variables, however, can be referenced only within <code>syntax</code> expressions.</p>
</div>
<div class="paragraph">
<p>See the examples following the description of <code>syntax</code>.</p>
</div>
<div id="syntax:s33" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(syntax <em>template</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>#'<em>template</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs syntax-case)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>#'<em>template</em></code> is equivalent to <code>(syntax <em>template</em>)</code>. The abbreviated form is converted into the longer form when a program is read, prior to macro expansion.</p>
</div>
<div class="paragraph">
<p>A <code>syntax</code> expression is like a <code>quote</code> expression except that the values of pattern variables appearing within <code><em>template</em></code> are inserted into <code><em>template</em></code>, and contextual information associated both with the input and with the template is retained in the output to support lexical scoping. A <code>syntax</code> <code><em>template</em></code> is identical to a <code>syntax-rules</code> <code><em>template</em></code> and is treated similarly.</p>
</div>
<div class="paragraph">
<p>List and vector structures within the template become true lists or vectors (suitable for direct application of list or vector operations, like <code>map</code> or <code>vector-ref</code>) to the extent that the list or vector structures must be copied to insert the values of pattern variables, and empty lists are never wrapped. For example, <code>#'(x ...)</code>, <code>#'(a b c)</code>, <code>#'()</code> are all lists if <code>x</code>, <code>a</code>, <code>b</code>, and <code>c</code> are pattern variables.</p>
</div>
<div class="paragraph">
<p>The definition of <code>or</code> below is equivalent to the one given in <a href="#section_8.2.">Section 8.2</a> except that it employs <code>syntax-case</code> and <code>syntax</code> in place of <code>syntax-rules</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax or
  (lambda (x)
    (syntax-case x ()
      [(_) #'#f]
      [(_ e) #'e]
      [(_ e1 e2 e3 ...)
       #'(let ([t e1]) (if t t (or e2 e3 ...)))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this version, the <code>lambda</code> expression that produces the transformer is explicit, as are the <code>syntax</code> forms in the output part of each clause. Any <code>syntax-rules</code> form can be expressed with <code>syntax-case</code> by making the <code>lambda</code> expression and <code>syntax</code> expressions explicit. This observation leads to the following definition of <code>syntax-rules</code> in terms of <code>syntax-case</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax syntax-rules
  (lambda (x)
    (syntax-case x ()
      [(_ (i ...) ((keyword . pattern) template) ...)
       #'(lambda (x)
           (syntax-case x (i ...)
             [(_ . pattern) #'template] ...))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>An underscore is used in place of each <code>keyword</code> since the first position of each <code>syntax-rules</code> pattern is always ignored.</p>
</div>
<div class="paragraph">
<p>Since the <code>lambda</code> and <code>syntax</code> expressions are implicit in a <code>syntax-rules</code> form, definitions expressed with <code>syntax-rules</code> are often shorter than the equivalent definitions expressed with <code>syntax-case</code>. The choice of which to use when either suffices is a matter of taste, but many transformers that can be written easily with <code>syntax-case</code> cannot be written easily or at all with <code>syntax-rules</code> (see <a href="#section_8.4.">Section 8.4</a>).</p>
</div>
<div id="syntax:s35" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(identifier? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is an identifier, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs syntax-case)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>identifier?</code> is often used within fenders to verify that certain subforms of an input form are identifiers, as in the definition of unnamed <code>let</code> below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax let
  (lambda (x)
    (define ids?
      (lambda (ls)
        (or (null? ls)
            (and (identifier? (car ls))
                 (ids? (cdr ls))))))
    (syntax-case x ()
      [(_ ((i e) ...) b1 b2 ...)
       (ids? #'(i ...))
       #'((lambda (i ...) b1 b2 ...) e ...)])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Syntactic extensions ordinarily take the form <code>(<em>keyword</em> <em>subform</em> ...)</code>, but the <code>syntax-case</code> system permits them to take the form of singleton identifiers as well. For example, the keyword <code>pcar</code> in the expression below may be used both as an identifier (in which case it expands into a call to <code>car</code>) or as a structured form (in which case it expands into a call to <code>set-car!</code>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([p (cons 0 #f)])
  (define-syntax pcar
    (lambda (x)
      (syntax-case x ()
        [_ (identifier? x) #'(car p)]
        [(_ e) #'(set-car! p e)])))
  (let ([a pcar])
    (pcar 1)
    (list a pcar))) ⇒ (0 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The fender <code>(identifier? x)</code> is used to recognize the singleton identifier case.</p>
</div>
<div id="syntax:s37" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(free-identifier=? <em>identifier<sub>1</sub></em> <em>identifier<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(bound-identifier=? <em>identifier<sub>1</sub></em> <em>identifier<sub>2</sub></em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs syntax-case)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Symbolic names alone do not distinguish identifiers unless the identifiers are to be used only as symbolic data. The predicates <code>free-identifier=?</code> and <code>bound-identifier=?</code> are used to compare identifiers according to their <em>intended use</em> as free references or bound identifiers in a given context.</p>
</div>
<div class="paragraph">
<p><code>free-identifier=?</code> is used to determine whether two identifiers would be equivalent if they were to appear as free identifiers in the output of a transformer. Because identifier references are lexically scoped, this means <code>(free-identifier=? <em>id<sub>1</sub></em> <em>id<sub>2</sub></em>)</code> is true if and only if the identifiers <code><em>id<sub>1</sub></em></code> and <code><em>id<sub>2</sub></em></code> refer to the same binding. (For this comparison, two like-named identifiers are assumed to have the same binding if neither is bound.) Literal identifiers (auxiliary keywords) appearing in <code>syntax-case</code> patterns (such as <code>else</code> in <code>case</code> and <code>cond</code>) are matched with <code>free-identifier=?</code>.</p>
</div>
<div class="paragraph">
<p>Similarly, <code>bound-identifier=?</code> is used to determine whether two identifiers would be equivalent if they were to appear as bound identifiers in the output of a transformer. In other words, if <code>bound-identifier=?</code> returns true for two identifiers, a binding for one will capture references to the other within its scope. In general, two identifiers are <code>bound-identifier=?</code> only if both are present in the original program or both are introduced by the same transformer application (perhaps implicitly---see <code>datum-&gt;syntax</code>). <code>bound-identifier=?</code> can be used for detecting duplicate identifiers in a binding construct or for other preprocessing of a binding construct that requires detecting instances of the bound identifiers.</p>
</div>
<div class="paragraph">
<p>The definition below is equivalent to the earlier definition of a simplified version of <code>cond</code> with <code>syntax-rules</code>, except that <code>else</code> is recognized via an explicit call to <code>free-identifier?</code> within a fender rather than via inclusion in the literals list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax cond
  (lambda (x)
    (syntax-case x ()
      [(_ (e0 e1 e2 ...))
       (and (identifier? #'e0) (free-identifier=? #'e0 #'else))
       #'(begin e1 e2 ...)]
      [(_ (e0 e1 e2 ...)) #'(if e0 (begin e1 e2 ...))]
      [(_ (e0 e1 e2 ...) c1 c2 ...)
       #'(if e0 (begin e1 e2 ...) (cond c1 c2 ...))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>With either definition of <code>cond</code>, <code>else</code> is not recognized as an auxiliary keyword if an enclosing lexical binding for <code>else</code> exists. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([else #f])
  (cond [else (write "oops")]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>does <em>not</em> write <code>"oops"</code>, since <code>else</code> is bound lexically and is therefore not the same <code>else</code> that appears in the definition of <code>cond</code>.</p>
</div>
<div class="paragraph">
<p>The following definition of unnamed <code>let</code> uses <code>bound-identifier=?</code> to detect duplicate identifiers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax let
  (lambda (x)
    (define ids?
      (lambda (ls)
        (or (null? ls)
            (and (identifier? (car ls)) (ids? (cdr ls))))))
    (define unique-ids?
      (lambda (ls)
        (or (null? ls)
            (and (not (memp
                        (lambda (x) (bound-identifier=? x (car ls)))
                        (cdr ls)))
                 (unique-ids? (cdr ls))))))
    (syntax-case x ()
      [(_ ((i e) ...) b1 b2 ...)
       (and (ids? #'(i ...)) (unique-ids? #'(i ...)))
       #'((lambda (i ...) b1 b2 ...) e ...)])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the definition of <code>let</code> above, the expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([a 3] [a 4]) (+ a a))</code></pre>
</div>
</div>
<div class="paragraph">
<p>is a syntax violation, whereas</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([a 0])
  (let-syntax ([dolet (lambda (x)
                        (syntax-case x ()
                          [(_ b)
                           #'(let ([a 3] [b 4]) (+ a b))]))])
    (dolet a)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>evaluates to <code>7</code> since the identifier <code>a</code> introduced by <code>dolet</code> and the identifier <code>a</code> extracted from the input form are not <code>bound-identifier=?</code>. Since both occurrences of <code>a</code>, however, if left as free references, would refer to the same binding for <code>a</code>, <code>free-identifier=?</code> would not distinguish them.</p>
</div>
<div class="paragraph">
<p>Two identifiers that are <code>free-identifier=?</code> may not be <code>bound-identifier=?</code>. An identifier introduced by a transformer may refer to the same enclosing binding as an identifier not introduced by the transformer, but an introduced binding for one will not capture references to the other. On the other hand, identifiers that are <code>bound-identifier=?</code> are <code>free-identifier=?</code>, as long as the identifiers have valid bindings in the context where they are compared.</p>
</div>
<div id="syntax:s38" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(with-syntax ((<em>pattern</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the values of the final body expression</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs syntax-case)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is sometimes useful to construct a transformer&#8217;s output in separate pieces, then put the pieces together. <code>with-syntax</code> facilitates this by allowing the creation of local pattern bindings.</p>
</div>
<div class="paragraph">
<p><code><em>pattern</em></code> is identical in form to a <code>syntax-case</code> pattern. The value of each <code><em>expr</em></code> is computed and destructured according to the corresponding <code><em>pattern</em></code>, and pattern variables within the <code><em>pattern</em></code> are bound as with <code>syntax-case</code> to appropriate portions of the value within the body <code><em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...</code>, which is processed and evaluated like a <code>lambda</code> body.</p>
</div>
<div class="paragraph">
<p><code>with-syntax</code> may be defined as a syntactic extension in terms of <code>syntax-case</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax with-syntax
  (lambda (x)
    (syntax-case x ()
      [(_ ((p e) ...) b1 b2 ...)
       #'(syntax-case (list e ...) ()
           [(p ...) (let () b1 b2 ...)])])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following definition of full <code>cond</code> demonstrates the use of <code>with-syntax</code> to support transformers that employ recursion internally to construct their output.</p>
</div>
<div id="defn:cond" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax cond
  (lambda (x)
    (syntax-case x ()
      [(_ c1 c2 ...)
       (let f ([c1 #'c1] [cmore #'(c2 ...)])
         (if (null? cmore)
             (syntax-case c1 (else =>)
               [(else e1 e2 ...) #'(begin e1 e2 ...)]
               [(e0) #'(let ([t e0]) (if t t))]
               [(e0 => e1) #'(let ([t e0]) (if t (e1 t)))]
               [(e0 e1 e2 ...) #'(if e0 (begin e1 e2 ...))])
             (with-syntax ([rest (f (car cmore) (cdr cmore))])
               (syntax-case c1 (=>)
                 [(e0) #'(let ([t e0]) (if t t rest))]
                 [(e0 => e1) #'(let ([t e0]) (if t (e1 t) rest))]
                 [(e0 e1 e2 ...)
                  #'(if e0 (begin e1 e2 ...) rest)]))))])))</code></pre>
</div>
</div>
<div id="syntax:s40" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(quasisyntax <em>template</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>#`<em>template</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(unsyntax <em>template</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>#,<em>template</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(unsyntax-splicing <em>template</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>#,@<em>template</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs syntax-case)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>#`<em>template</em></code> is equivalent to <code>(quasisyntax <em>template</em>)</code>, while <code>#,<em>template</em></code> is equivalent to <code>(unsyntax <em>template</em>)</code>, and <code>#,@<em>template</em></code> to <code>(unsyntax-splicing <em>template</em>)</code>. The abbreviated forms are converted into the longer forms when the program is read, prior to macro expansion.</p>
</div>
<div class="paragraph">
<p><code>quasisyntax</code> is similar to <code>syntax</code>, but it allows parts of the quoted text to be evaluated, in a manner similar to <code>quasiquote</code> (<a href="#section_6.1.">Section 6.1</a>).</p>
</div>
<div class="paragraph">
<p>Within a <code>quasisyntax</code> <code><em>template</em></code>, subforms of <code>unsyntax</code> and <code>unsyntax-splicing</code> forms are evaluated, and everything else is treated as ordinary template material, as with <code>syntax</code>. The value of each <code>unsyntax</code> subform is inserted into the output in place of the <code>unsyntax</code> form, while the value of each <code>unsyntax-splicing</code> subform is spliced into the surrounding list or vector structure. <code>unsyntax</code> and <code>unsyntax-splicing</code> are valid only within <code>quasisyntax</code> expressions.</p>
</div>
<div class="paragraph">
<p><code>quasisyntax</code> expressions may be nested, with each <code>quasisyntax</code> introducing a new level of syntax quotation and each <code>unsyntax</code> or <code>unsyntax-splicing</code> taking away a level of quotation. An expression nested within <em>n</em> <code>quasisyntax</code> expressions must be within <em>n</em> <code>unsyntax</code> or <code>unsyntax-splicing</code> expressions to be evaluated.</p>
</div>
<div class="paragraph">
<p><code>quasisyntax</code> can be used in place of <code>with-syntax</code> in many cases. For example, the following definition of <code>case</code> employs <code>quasisyntax</code> to construct its output, using internal recursion in a manner similar to the definition of <code>cond</code> given under the description of <code>with-syntax</code> above.</p>
</div>
<div id="defn:case" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax case
  (lambda (x)
    (syntax-case x ()
      [(_ e c1 c2 ...)
       #`(let ([t e])
           #,(let f ([c1 #'c1] [cmore #'(c2 ...)])
               (if (null? cmore)
                   (syntax-case c1 (else)
                     [(else e1 e2 ...) #'(begin e1 e2 ...)]
                     [((k ...) e1 e2 ...)
                      #'(if (memv t '(k ...)) (begin e1 e2 ...))])
                   (syntax-case c1 ()
                     [((k ...) e1 e2 ...)
                      #`(if (memv t '(k ...))
                            (begin e1 e2 ...)
                            #,(f (car cmore) (cdr cmore)))]))))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>unsyntax</code> and <code>unsyntax-splicing</code> forms that contain zero or more than one subform are valid only in splicing (list or vector) contexts. <code>(unsyntax <em>template</em> ...)</code> is equivalent to <code>(unsyntax <em>template</em>) ...</code>, and <code>(unsyntax-splicing <em>template</em> ...)</code> is equivalent to <code>(unsyntax-splicing <em>template</em>) ...</code>. These forms are primarily useful as intermediate forms in the output of the <code>quasisyntax</code> expander. They support certain useful nested quasiquotation (<code>quasisyntax</code>) idioms <a href="#ref3">[3]</a>, such as <code>#,@#,@</code>, which has the effect of a doubly indirect splicing when used within a doubly nested and doubly evaluated <code>quasisyntax</code> expression, as with the nested <code>quasiquote</code> examples shown in <a href="#section_6.1.">Section 6.1</a>.</p>
</div>
<div class="paragraph">
<p><code>unsyntax</code> and <code>unsyntax-splicing</code> are auxiliary keywords for <code>quasisyntax</code>. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.</p>
</div>
<div id="desc:make-variable-transformer" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-variable-transformer <em>procedure</em>)</code> <a id="syntax:s42"></a></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a variable transformer</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs syntax-case)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As described in the lead-in to this section, transformers may simply be procedures that accept one argument, a syntax object representing the input form, and return a new syntax object representing the output form. The form passed to a transformer usually represents a parenthesized form whose first subform is the keyword bound to the transformer or just the keyword itself. <code>make-variable-transformer</code> may be used to convert a procedure into a special kind of transformer to which the expander also passes <code>set!</code> forms in which the keyword appears just after the <code>set!</code> keyword, as if it were a variable to be assigned. This allows the programmer to control what happens when the keyword appears in such contexts. The argument, <code><em>procedure</em></code>, should accept one argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([ls (list 0)])
  (define-syntax a
    (make-variable-transformer
      (lambda (x)
        (syntax-case x ()
          [id (identifier? #'id) #'(car ls)]
          [(set! _ e) #'(set-car! ls e)]
          [(_ e ...) #'((car ls) e ...)]))))
  (let ([before a])
    (set! a 1)
    (list before a ls))) ⇒ (0 1 (1))</code></pre>
</div>
</div>
<div id="syntax:s43" class="paragraph">
<p>This syntactic abstraction can be defined more succinctly using <code>identifier-syntax</code>, as shown in <a href="#section_8.2.">Section 8.2</a>, but <code>make-variable-transformer</code> can be used to create transformers that perform arbitrary computations, while <code>identifier-syntax</code> is limited to simple term rewriting, like <code>syntax-rules</code>. <code>identifier-syntax</code> can be defined in terms of <code>make-variable-transformer</code>, as shown below.</p>
</div>
<div id="defn:identifier-syntax" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax identifier-syntax
  (lambda (x)
    (syntax-case x (set!)
      [(_ e)
       #'(lambda (x)
           (syntax-case x ()
             [id (identifier? #'id) #'e]
             [(_ x (... ...)) #'(e x (... ...))]))]
      [(_ (id exp1) ((set! var val) exp2))
       (and (identifier? #'id) (identifier? #'var))
       #'(make-variable-transformer
           (lambda (x)
             (syntax-case x (set!)
               [(set! var val) #'exp2]
               [(id x (... ...)) #'(exp1 x (... ...))]
               [id (identifier? #'id) #'exp1])))])))</code></pre>
</div>
</div>
<div id="syntax:s44" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(syntax-&gt;datum <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code><em>obj</em></code> stripped of syntactic information</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs syntax-case)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The procedure <code>syntax-&gt;datum</code> strips all syntactic information from a syntax object and returns the corresponding Scheme "datum." Identifiers stripped in this manner are converted to their symbolic names, which can then be compared with <code>eq?</code>. Thus, a predicate <code>symbolic-identifier=?</code> might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define symbolic-identifier=?
  (lambda (x y)
    (eq? (syntax->datum x)
         (syntax->datum y))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Two identifiers that are <code>free-identifier=?</code> need not be <code>symbolic-identifier=?</code>: two identifiers that refer to the same binding usually have the same name, but the <code>rename</code> and <code>prefix</code> subforms of the library&#8217;s <code>import</code> form (<a href="#desc:import">page 345</a>) may result in two identifiers with different names but the same binding.</p>
</div>
<div id="syntax:s45" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(datum-&gt;syntax <em>template-identifier</em> <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a syntax object</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs syntax-case)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>datum-&gt;syntax</code> constructs a syntax object from <code><em>obj</em></code> that contains the same contextual information as <code><em>template-identifier</em></code>, with the effect that the syntax object behaves as if it were introduced into the code when <code><em>template-identifier</em></code> was introduced. The template identifier is often the keyword of an input form, extracted from the form, and the object is often a symbol naming an identifier to be constructed.</p>
</div>
<div class="paragraph">
<p><code>datum-&gt;syntax</code> allows a transformer to "bend" lexical scoping rules by creating <em>implicit identifiers</em> that behave as if they were present in the input form, thus permitting the definition of syntactic extensions that introduce visible bindings for or references to identifiers that do not appear explicitly in the input form. For example, we can define a <code>loop</code> expression that binds the variable <code>break</code> to an escape procedure within the loop body.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax loop
  (lambda (x)
    (syntax-case x ()
      [(k e ...)
       (with-syntax ([break (datum->syntax #'k 'break)])
         #'(call/cc
             (lambda (break)
               (let f () e ... (f)))))])))

(let ([n 3] [ls '()])
  (loop
    (if (= n 0) (break ls))
    (set! ls (cons 'a ls))
    (set! n (- n 1)))) ⇒ (a a a)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Were we to define <code>loop</code> as</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax loop
  (lambda (x)
    (syntax-case x ()
      [(_ e ...)
       #'(call/cc
           (lambda (break)
             (let f () e ... (f))))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>the variable <code>break</code> would not be visible in <code>e ...</code>.</p>
</div>
<div class="paragraph">
<p>It is also useful for <code><em>obj</em></code> to represent an arbitrary Scheme form, as demonstrated by the following definition of <code>include</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax include
  (lambda (x)
    (define read-file
      (lambda (fn k)
        (let ([p (open-input-file fn)])
          (let f ([x (read p)])
            (if (eof-object? x)
                (begin (close-port p) '())
                (cons (datum->syntax k x) (f (read p))))))))
    (syntax-case x ()
      [(k filename)
       (let ([fn (syntax->datum #'filename)])
         (with-syntax ([(expr ...) (read-file fn #'k)])
           #'(begin expr ...)))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>(include "filename")</code> expands into a <code>begin</code> expression containing the forms found in the file named by <code>"filename"</code>. For example, if the file <code>f-def.ss</code> contains the expression <code>(define f (lambda () x))</code>, the expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x "okay"])
  (include "f-def.ss")
  (f))</code></pre>
</div>
</div>
<div class="paragraph">
<p>evaluates to <code>"okay"</code>.</p>
</div>
<div class="paragraph">
<p>The definition of <code>include</code> uses <code>datum-&gt;syntax</code> to convert the objects read from the file into syntax objects in the proper lexical context, so that identifier references and definitions within those expressions are scoped where the <code>include</code> form appears.</p>
</div>
<div id="syntax:s49" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(generate-temporaries <em>list</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a list of distinct generated identifiers</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs syntax-case)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Transformers can introduce a fixed number of identifiers into their output by naming each identifier. In some cases, however, the number of identifiers to be introduced depends upon some characteristic of the input expression. A straightforward definition of <code>letrec</code>, for example, requires as many temporary identifiers as there are binding pairs in the input expression. The procedure <code>generate-temporaries</code> is used to construct lists of temporary identifiers.</p>
</div>
<div class="paragraph">
<p><code><em>list</em></code> may be any list; its contents are not important. The number of temporaries generated is the number of elements in <code><em>list</em></code>. Each temporary is guaranteed to be different from all other identifiers.</p>
</div>
<div class="paragraph">
<p>A definition of <code>letrec</code> that uses <code>generate-temporaries</code> is shown below.</p>
</div>
<div id="defn:letrec" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax letrec
  (lambda (x)
    (syntax-case x ()
      [(_ ((i e) ...) b1 b2 ...)
       (with-syntax ([(t ...) (generate-temporaries #'(i ...))])
         #'(let ([i #f] ...)
             (let ([t e] ...)
               (set! i t)
               ...
               (let () b1 b2 ...))))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Any transformer that uses <code>generate-temporaries</code> in this fashion can be rewritten to avoid using it, albeit with a loss of clarity. The trick is to use a recursively defined intermediate form that generates one temporary per expansion step and completes the expansion after enough temporaries have been generated. <a id="fullletvalues"></a> Here is a definition of <code>let-values</code> (<a href="#desc:let-values">page 99</a>) that uses this technique to support multiple sets of bindings.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax let-values
  (syntax-rules ()
    [(_ () f1 f2 ...) (let () f1 f2 ...)]
    [(_ ((fmls1 expr1) (fmls2 expr2) ...) f1 f2 ...)
     (lvhelp fmls1 () () expr1 ((fmls2 expr2) ...) (f1 f2 ...))]))

(define-syntax lvhelp
  (syntax-rules ()
    [(_ (x1 . fmls) (x ...) (t ...) e m b)
     (lvhelp fmls (x ... x1) (t ... tmp) e m b)]
    [(_ () (x ...) (t ...) e m b)
     (call-with-values
       (lambda () e)
       (lambda (t ...)
         (let-values m (let ([x t] ...) . b))))]
    [(_ xr (x ...) (t ...) e m b)
     (call-with-values
       (lambda () e)
       (lambda (t ... . tmpr)
         (let-values m (let ([x t] ... [xr tmpr]) . b))))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation of <code>lvhelp</code> is complicated by the need to evaluate all of the right-hand-side expressions before creating any of the bindings and by the need to support improper formals lists.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_8.4.">Section 8.4. Examples</h3>
<div class="paragraph">
<p>This section presents a series of illustrative syntactic extensions defined with either <code>syntax-rules</code> or <code>syntax-case</code>, starting with a few simple but useful syntactic extensions and ending with a fairly complex mechanism for defining structures with automatically generated constructors, predicates, field accessors, and field setters.</p>
</div>
<div class="paragraph">
<p>The simplest example in this section is the following definition of <code>rec</code>. <code>rec</code> is a syntactic extension that permits internally recursive anonymous (not externally named) procedures to be created with minimal effort.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax rec
  (syntax-rules ()
    [(_ x e) (letrec ([x e]) x)]))

(map (rec sum
       (lambda (x)
         (if (= x 0)
             0
             (+ x (sum (- x 1))))))
     '(0 1 2 3 4 5)) ⇒ (0 1 3 6 10 15)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using <code>rec</code>, we can define the full <code>let</code> (both unnamed and named) as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax let
  (syntax-rules ()
    [(_ ((x e) ...) b1 b2 ...)
     ((lambda (x ...) b1 b2 ...) e ...)]
    [(_ f ((x e) ...) b1 b2 ...)
     ((rec f (lambda (x ...) b1 b2 ...)) e ...)]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can also define <code>let</code> directly in terms of <code>letrec</code>, although the definition is a bit less clear.</p>
</div>
<div id="defn:let" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax let
  (syntax-rules ()
    [(_ ((x e) ...) b1 b2 ...)
     ((lambda (x ...) b1 b2 ...) e ...)]
    [(_ f ((x e) ...) b1 b2 ...)
     ((letrec ([f (lambda (x ...) b1 b2 ...)]) f) e ...)]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>These definitions rely upon the fact that the first pattern cannot match a named <code>let</code>, since the first subform of a named <code>let</code> must be an identifier, not a list of bindings. The following definition uses a fender to make this check more robust.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax let
  (lambda (x)
    (syntax-case x ()
      [(_ ((x e) ...) b1 b2 ...)
       #'((lambda (x ...) b1 b2 ...) e ...)]
      [(_ f ((x e) ...) b1 b2 ...)
       (identifier? #'f)
       #'((rec f (lambda (x ...) b1 b2 ...)) e ...)])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the fender, we can even put the clauses in the opposite order.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax let
  (lambda (x)
    (syntax-case x ()
      [(_ f ((x e) ...) b1 b2 ...)
       (identifier? #'f)
       #'((rec f (lambda (x ...) b1 b2 ...)) e ...)]
      [(_ ((x e) ...) b1 b2 ...)
       #'((lambda (x ...) b1 b2 ...) e ...)])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>To be completely robust, the <code>ids?</code> and <code>unique-ids?</code> checks employed in the definition of unnamed <code>let</code> in <a href="#section_8.3.">Section 8.3</a> should be employed here as well.</p>
</div>
<div class="paragraph">
<p>Both variants of <code>let</code> are easily described by simple one-line patterns, but <code>do</code> requires a bit more work. The precise syntax of <code>do</code> cannot be expressed directly with a single pattern because some of the bindings in a <code>do</code> expression&#8217;s binding list may take the form <code>(var val)</code> while others take the form <code>(var val update)</code>. The following definition of <code>do</code> uses <code>syntax-case</code> internally to parse the bindings separately from the overall form.</p>
</div>
<div id="defn:do" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax do
  (lambda (x)
    (syntax-case x ()
      [(_ (binding ...) (test res ...) expr ...)
       (with-syntax ([((var val update) ...)
                      (map (lambda (b)
                             (syntax-case b ()
                               [(var val) #'(var val var)]
                               [(var val update) #'(var val update)]))
                           #'(binding ...))])
         #'(let doloop ([var val] ...)
             (if test
                 (begin (if #f #f) res ...)
                 (begin expr ... (doloop update ...)))))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The odd-looking expression <code>(if #f #f)</code> is inserted before the result expressions <code>res ...</code> in case no result expressions are provided, since <code>begin</code> requires at least one subexpression. The value of <code>(if #f #f)</code> is unspecified, which is what we want since the value of <code>do</code> is unspecified if no result expressions are provided. At the expense of a bit more code, we could use <code>syntax-case</code> to determine whether any result expressions are provided and to produce a loop with either a one- or two-armed <code>if</code> as appropriate. The resulting expansion would be cleaner but semantically equivalent.</p>
</div>
<div class="paragraph">
<p>As mentioned in <a href="#section_8.2.">Section 8.2</a>, ellipses lose their special meaning within templates of the form <code>(... <em>template</em>)</code>. This fact allows syntactic extensions to expand into syntax definitions containing ellipses. This usage is illustrated by the definition below of <code>be-like-begin</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax be-like-begin
  (syntax-rules ()
    [(_ name)
     (define-syntax name
       (syntax-rules ()
         [(_ e0 e1 (... ...))
          (begin e0 e1 (... ...))]))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>With <code>be-like-begin</code> defined in this manner, <code>(be-like-begin sequence)</code> has the same effect as the following definition of <code>sequence</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax sequence
  (syntax-rules ()
    [(_ e0 e1 ...) (begin e0 e1 ...)]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>That is, a <code>sequence</code> form becomes equivalent to a <code>begin</code> form so that, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(sequence (display "Say what?") (newline))</code></pre>
</div>
</div>
<div class="paragraph">
<p>prints "Say what?" followed by a newline.</p>
</div>
<div class="paragraph">
<p>The following example shows how one might restrict <code>if</code> expressions within a given expression to require the "else" (alternative) subexpression by defining a local <code>if</code> in terms of the built-in <code>if</code>. Within the body of the <code>let-syntax</code> binding below, two-armed <code>if</code> works as always:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let-syntax ([if (lambda (x)
                   (syntax-case x ()
                     [(_ e1 e2 e3)
                      #'(if e1 e2 e3)]))])
  (if (< 1 5) 2 3)) ⇒ 2</code></pre>
</div>
</div>
<div class="paragraph">
<p>but one-armed if results in a syntax error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let-syntax ([if (lambda (x)
                   (syntax-case x ()
                     [(_ e1 e2 e3)
                      #'(if e1 e2 e3)]))])
  (if (< 1 5) 2)) ⇒ <em>syntax violation</em></code></pre>
</div>
</div>
<div class="paragraph">
<p>Although this local definition of <code>if</code> looks simple enough, there are a few subtle ways in which an attempt to write it might go wrong. If <code>letrec-syntax</code> were used in place of <code>let-syntax</code>, the identifier <code>if</code> inserted into the output would refer to the local <code>if</code> rather than the built-in <code>if</code>, and expansion would loop indefinitely.</p>
</div>
<div class="paragraph">
<p>Similarly, if the underscore were replaced with the identifier <code>if</code>, expansion would again loop indefinitely. The <code>if</code> appearing in the template <code>(if e1 e2 e3)</code> would be treated as a pattern variable bound to the corresponding identifier <code>if</code> from the input form, which denotes the local version of <code>if</code>.</p>
</div>
<div class="paragraph">
<p>Placing <code>if</code> in the list of literals in an attempt to patch up the latter version would not work either. This would cause <code>syntax-case</code> to compare the literal <code>if</code> in the pattern, which would be scoped outside the <code>let-syntax</code> expression, with the <code>if</code> in the input expression, which would be scoped inside the <code>let-syntax</code>. Since they would not refer to the same binding, they would not be <code>free-identifier=?</code>, and a syntax violation would result.</p>
</div>
<div class="paragraph">
<p>The conventional use of underscore ( <code>_</code> ) helps the programmer avoid situations like these in which the wrong identifier is matched against or inserted by accident.</p>
</div>
<div class="paragraph">
<p>It is a syntax violation to generate a reference to an identifier that is not present within the context of an input form, which can happen if the "closest enclosing lexical binding" for an identifier inserted into the output of a transformer does not also enclose the input form. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let-syntax ([divide (lambda (x)
                       (let ([/ +])
                         (syntax-case x ()
                           [(_ e1 e2) #'(/ e1 e2)])))])
  (let ([/ *]) (divide 2 1)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>should result in a syntax violation with a message to the effect that <code>/</code> is referenced in an invalid context, since the occurrence of <code>/</code> in the output of <code>divide</code> is a reference to the variable <code>/</code> bound by the <code>let</code> expression within the transformer.</p>
</div>
<div id="syntax:s60" class="paragraph">
<p>The next example defines a <code>define-integrable</code> form that is similar to <code>define</code> for procedure definitions except that it causes the code for the procedure to be <em>integrated</em>, or inserted, wherever a direct call to the procedure is found.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax define-integrable
  (syntax-rules (lambda)
    [(_ name (lambda formals form1 form2 ...))
     (begin
       (define xname (lambda formals form1 form2 ...))
       (define-syntax name
         (lambda (x)
           (syntax-case x ()
             [_ (identifier? x) #'xname]
             [(_ arg (... ...))
              #'((lambda formals form1 form2 ...)
                 arg
                 (... ...))]))))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The form <code>(define-integrable <em>name</em> <em>lambda-expression</em>)</code> expands into a pair of definitions: a syntax definition of <code><em>name</em></code> and a variable definition of <code>xname</code>. The transformer for <code><em>name</em></code> converts apparent calls to <code><em>name</em></code> into direct calls to <code><em>lambda-expression</em></code>. Since the resulting forms are merely direct <code>lambda</code> applications (the equivalent of <code>let</code> expressions), the actual parameters are evaluated exactly once and before evaluation of the procedure&#8217;s body, as required. All other references to <code><em>name</em></code> are replaced with references to <code>xname</code>. The definition of <code>xname</code> binds it to the value of <code><em>lambda-expression</em></code>. This allows the procedure to be used as a first-class value. The <code>define-integrable</code> transformer does nothing special to maintain lexical scoping within the <code>lambda</code> expression or at the call site, since lexical scoping is maintained automatically by the expander. Also, because <code>xname</code> is introduced by the transformer, the binding for <code>xname</code> is not visible anywhere except where references to it are introduced by the the transformer for <code><em>name</em></code>.</p>
</div>
<div class="paragraph">
<p>The above definition of <code>define-integrable</code> does not work for recursive procedures, since a recursive call would cause an indefinite number of expansion steps, likely resulting in exhaustion of memory at expansion time. A solution to this problem for directly recursive procedures is to wrap each occurrence of the <code>lambda</code> expression with a <code>let-syntax</code> binding that unconditionally expands <code><em>name</em></code> to <code>xname</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax define-integrable
  (syntax-rules (lambda)
    [(_ name (lambda formals form1 form2 ...))
     (begin
       (define xname
         (let-syntax ([name (identifier-syntax xname)])
           (lambda formals form1 form2 ...)))
       (define-syntax name
         (lambda (x)
           (syntax-case x ()
             [_ (identifier? x) #'xname]
             [(_ arg (... ...))
              #'((let-syntax ([name (identifier-syntax xname)])
                   (lambda formals form1 form2 ...))
                  arg (... ...))]))))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This problem can be solved for mutually recursive procedures by replacing the <code>let-syntax</code> forms with the nonstandard <code>fluid-let-syntax</code> form, which is described in the <em>Chez Scheme User&#8217;s Guide</em> <a href="#ref9">[9]</a>.</p>
</div>
<div class="paragraph">
<p>Both definitions of <code>define-integrable</code> treat the case where an identifier appears in the first position of a structured expression differently from the case where it appears elsewhere, as does the <code>pcar</code> example given in the description for <code>identifier?</code>. In other situations, both cases must be treated the same. The form <code>identifier-syntax</code> can make doing so more convenient.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 0])
  (define-syntax x++
    (identifier-syntax
      (let ([t x])
        (set! x (+ t 1)) t)))
  (let ([a x++]) (list a x))) ⇒ (0 1)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following example uses <code>identifier-syntax</code>, <code>datum-&gt;syntax</code>, and local syntax definitions to define a form of <em>method</em>, one of the basic building blocks of object-oriented programming (OOP) systems. A <code>method</code> expression is similar to a <code>lambda</code> expression, except that in addition to the formal parameters and body, a <code>method</code> expression also contains a list of instance variables <code>(ivar ...)</code>. When a method is invoked, it is always passed an <em>object</em> (<em>instance</em>), represented as a vector of <em>fields</em> corresponding to the instance variables, and zero or more additional arguments. Within the method body, the object is bound implicitly to the identifier <code>self</code> and the additional arguments are bound to the formal parameters. The fields of the object may be accessed or altered within the method body via instance variable references or assignments.</p>
</div>
<div id="defn:method" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax method
  (lambda (x)
    (syntax-case x ()
      [(k (ivar ...) formals b1 b2 ...)
       (with-syntax ([(index ...)
                      (let f ([i 0] [ls #'(ivar ...)])
                        (if (null? ls)
                            '()
                            (cons i (f (+ i 1) (cdr ls)))))]
                     [self (datum->syntax #'k 'self)]
                     [set! (datum->syntax #'k 'set!)])
         #'(lambda (self . formals)
             (let-syntax ([ivar (identifier-syntax
                                  (vector-ref self index))]
                          ...)
               (let-syntax ([set!
                             (syntax-rules (ivar ...)
                               [(_ ivar e) (vector-set! self index e)]
                               ...
                               [(_ x e) (set! x e)])])
                 b1 b2 ...))))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Local bindings for <code>ivar ...</code> and for <code>set!</code> make the fields of the object appear to be ordinary variables, with references and assignments translated into calls to <code>vector-ref</code> and <code>vector-set!</code>. <code>datum-&gt;syntax</code> is used to make the introduced bindings of <code>self</code> and <code>set!</code> visible in the method body. Nested <code>let-syntax</code> expressions are needed so that the identifiers <code>ivar ...</code> serving as auxiliary keywords for the local version of <code>set!</code> are scoped properly.</p>
</div>
<div id="syntax:s68" class="paragraph">
<p>By using the general form of <code>identifier-syntax</code> to handle <code>set!</code> forms more directly, we can simplify the definition of <code>method</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax method
  (lambda (x)
    (syntax-case x ()
      [(k (ivar ...) formals b1 b2 ...)
       (with-syntax ([(index ...)
                      (let f ([i 0] [ls #'(ivar ...)])
                        (if (null? ls)
                            '()
                            (cons i (f (+ i 1) (cdr ls)))))]
                     [self (datum->syntax #'k 'self)])
         #'(lambda (self . formals)
             (let-syntax ([ivar (identifier-syntax
                                  [_ (vector-ref self index)]
                                  [(set! _ e)
                                   (vector-set! self index e)])]
                          ...)
               b1 b2 ...)))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The examples below demonstrate simple uses of <code>method</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([m (method (a) (x) (list a x self))])
  (m #(1) 2)) ⇒ (1 2 #(1))

(let ([m (method (a) (x)
           (set! a x)
           (set! x (+ a x))
           (list a x self))])
  (m #(1) 2)) ⇒ (2 4 #(2))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In a complete OOP system based on <code>method</code>, the instance variables <code>ivar ...</code> would likely be drawn from class declarations, not listed explicitly in the <code>method</code> forms, although the same techniques would be used to make instance variables appear as ordinary variables within method bodies.</p>
</div>
<div id="syntax:s69" class="paragraph">
<p>The final example of this section defines a simple structure definition facility that represents structures as vectors with named fields. Structures are defined with <code>define-structure</code>, which takes the form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-structure <em>name</em> <em>field</em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code><em>name</em></code> names the structure and <code><em>field</em> ...</code> names its fields. <code>define-structure</code> expands into a series of generated definitions: a constructor <code>make-<em>name</em></code>, a type predicate <code><em>name</em>?</code>, and one accessor <code><em>name</em>-<em>field</em></code> and setter <code>set-<em>name</em>-<em>field</em>!</code> per field name.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax define-structure
  (lambda (x)
    (define gen-id
      (lambda (template-id . args)
        (datum->syntax template-id
          (string->symbol
            (apply string-append
              (map (lambda (x)
                     (if (string? x)
                         x
                         (symbol->string (syntax->datum x))))
                   args))))))
    (syntax-case x ()
      [(_ name field ...)
       (with-syntax ([constructor (gen-id #'name "make-" #'name)]
                     [predicate (gen-id #'name #'name "?")]
                     [(access ...)
                      (map (lambda (x) (gen-id x #'name "-" x))
                           #'(field ...))]
                     [(assign ...)
                      (map (lambda (x)
                             (gen-id x "set-" #'name "-" x "!"))
                           #'(field ...))]
                     [structure-length (+ (length #'(field ...)) 1)]
                     [(index ...)
                      (let f ([i 1] [ids #'(field ...)])
                        (if (null? ids)
                            '()
                            (cons i (f (+ i 1) (cdr ids)))))])
         #'(begin
             (define constructor
               (lambda (field ...)
                 (vector 'name field ...)))
             (define predicate
               (lambda (x)
                 (and (vector? x)
                      (= (vector-length x) structure-length)
                      (eq? (vector-ref x 0) 'name))))
             (define access
               (lambda (x)
                 (vector-ref x index)))
             ...
             (define assign
               (lambda (x update)
                 (vector-set! x index update)))
             ...))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The constructor accepts as many arguments as there are fields in the structure and creates a vector whose first element is the symbol <code><em>name</em></code> and whose remaining elements are the argument values. The type predicate returns true if its argument is a vector of the expected length whose first element is <code><em>name</em></code>.</p>
</div>
<div class="paragraph">
<p>Since a <code>define-structure</code> form expands into a <code>begin</code> containing definitions, it is itself a definition and can be used wherever definitions are valid.</p>
</div>
<div class="paragraph">
<p>The generated identifiers are created with <code>datum-&gt;syntax</code> to allow the identifiers to be visible where the <code>define-structure</code> form appears.</p>
</div>
<div class="paragraph">
<p>The examples below demonstrate the use of <code>define-structure</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-structure tree left right)
(define t
  (make-tree
    (make-tree 0 1)
    (make-tree 2 3)))

t ⇒ #(tree #(tree 0 1) #(tree 2 3))
(tree? t) ⇒ #t
(tree-left t) ⇒ #(tree 0 1)
(tree-right t) ⇒ #(tree 2 3)
(set-tree-left! t 0)
t ⇒ #(tree 0 #(tree 2 3))</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chp_records">Chapter 9. Records</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/ch9.png" alt="ch9">
</div>
</div>
<div class="paragraph">
<p>This chapter describes the means by which the programmer may define new data types, or <em>records types</em>, each distinct from all other types. A record type determines the number and names of the fields each instance of the type has. Records are defined via the <code>define-record-type</code> form or the <code>make-record-type-descriptor</code> procedure.</p>
</div>
<div class="sect2">
<h3 id="section_9.1.">Section 9.1. Defining Records</h3>
<div class="paragraph">
<p>A <code>define-record-type</code> form defines a record type and, along with it, a constructor procedure for records of the type, a type predicate that returns true only for records of the type, an access procedure for each field, and an assignment procedure for each mutable field. For example, the definition</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type point (fields x y))</code></pre>
</div>
</div>
<div class="paragraph">
<p>creates a <code>point</code> record type with two fields, <code>x</code> and <code>y</code>, and defines the following procedures:</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>(make-point <em>x</em> <em>y</em>)</code>
</td>
<td class="hdlist2">
<p>constructor</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>(point? <em>obj</em>)</code>
</td>
<td class="hdlist2">
<p>predicate</p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>(point-x <em>p</em>)</code>
</td>
<td class="hdlist2">
<p>accessor for field <code>x</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
<code>(point-y <em>p</em>)</code>
</td>
<td class="hdlist2">
<p>accessor for field <code>y</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>With this definition in place, we can use these procedures to create and manipulate records of the <code>point</code> type, as illustrated below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define p (make-point 36 -17))
(point? p) ⇒ #t
(point? '(cons 36 -17)) ⇒ #f
(point-x p) ⇒ 36
(point-y p) ⇒ -17</code></pre>
</div>
</div>
<div class="paragraph">
<p>Fields are immutable by default, but may be declared mutable. In the alternate definition of <code>point</code> below, the <code>x</code> field is mutable while <code>y</code> remains immutable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type point (fields (mutable x) y))</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this case, <code>define-record-type</code> defines a mutator for the <code>x</code> field in addition to the other products shown above.</p>
</div>
<div class="hdlist">
<table>
<tr>
<td class="hdlist1">
<code>(point-x-set! <em>p</em> <em>x</em>)</code>
</td>
<td class="hdlist2">
<p>mutator for field <code>x</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The mutator can be used to change the contents of the <code>x</code> field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define p (make-point 36 -17))
(point-x-set! p (- (point-x p) 12))
(point-x p) ⇒ 24</code></pre>
</div>
</div>
<div class="paragraph">
<p>A field may be declared immutable explicitly for clarity; the definition of <code>point</code> below is equivalent to the second definition above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type point (fields (mutable x) (immutable y)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The names of the procedures defined by <code>define-record-type</code> follow the regular naming convention illustrated by the examples above, by default, but the programmer can override the defaults if desired. With the following definition of <code>point</code>, the constructor is <code>mkpoint</code>, the predicate is <code>ispoint?</code>, and the accessors for <code>x</code> and <code>y</code> are <code>x-val</code> and <code>y-val</code>. The mutator for <code>x</code> is <code>set-x-val!</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type (point mkpoint ispoint?)
  (fields (mutable x x-val set-x-val!)
          (immutable y y-val)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, a record definition creates a new type each time it is evaluated, as illustrated by the example below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define (f p)
  (define-record-type point (fields x y))
  (if (eq? p 'make) (make-point 3 4) (point? p)))
(f (f 'make)) ⇒ #f</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first (inner) call to <code>f</code> returns a point <code><em>p</em></code>, which is passed to <code>f</code> in the second (outer) call, which applies <code>point?</code> to <code><em>p</em></code>. This <code>point?</code> is looking for points of the type created by the second call, while <code><em>p</em></code> is a point of the type created by the first call. So <code>point?</code> returns <code>#f</code>.</p>
</div>
<div class="paragraph">
<p>This default <em>generative</em> behavior may be overridden by including a <code>nongenerative</code> clause in the record definition.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define (f p)
  (define-record-type point (fields x y) (nongenerative))
  (if (eq? p 'make) (make-point 3 4) (point? p)))
(define p (f 'make))
(f p) ⇒ #t</code></pre>
</div>
</div>
<div class="paragraph">
<p>Record types created in this manner are still distinct from record types created by a definition appearing in a different part of the program, even if the definitions are syntactically identical:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define (f)
  (define-record-type point (fields x y) (nongenerative))
  (make-point 3 4))
(define (g p)
  (define-record-type point (fields x y) (nongenerative))
  (point? p))
(g (f)) ⇒ #f</code></pre>
</div>
</div>
<div id="page:record-uid" class="paragraph">
<p>Even this can be overridden by including a uid (unique id) in the <code>nongenerative</code> clause: <a id="records:s6"></a></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define (f)
  (define-record-type point (fields x y)
    (nongenerative really-the-same-point))
  (make-point 3 4))
(define (g p)
  (define-record-type point (fields x y)
    (nongenerative really-the-same-point))
  (point? p))
(g (f)) ⇒ #t</code></pre>
</div>
</div>
<div class="paragraph">
<p>The uid may be any identifier, but programmers are encouraged to select uids from the RFC 4122 UUID namespace <a href="#ref20">[20]</a>, possibly with the record-type name as a prefix.</p>
</div>
<div id="page:parent-type" class="paragraph">
<p>A record type may be defined as a subtype of an existing "parent" type with a <code>parent</code> clause that declares the name of the existing record type. If a parent is specified, the new "child" record type inherits the parent record&#8217;s fields, and each instance of the child type is considered to be an instance of the parent type, so that accessors and mutators for the parent type may be used on instances of the child type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type point (fields x y))
(define-record-type cpoint (parent point) (fields color))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The child type has all of the fields of the parent type, plus the additional fields declared in the child&#8217;s definition. This is reflected in the constructor for <code>cpoint</code>, which now takes three arguments, with the parent arguments followed by the child argument.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define cp (make-cpoint 3 4 'red))</code></pre>
</div>
</div>
<div class="paragraph">
<p>A record of the child type is considered a record of the parent type, but a record of the parent type is not a record of the new type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(point? (make-cpoint 3 4 'red)) ⇒ #t
(cpoint? (make-point 3 4)) ⇒ #f</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only one new accessor is created for <code>cpoint</code>, the one for the new field <code>color</code>. The existing accessors and mutators for the parent type may be used to access and modify the parent fields of the child type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define cp (make-cpoint 3 4 'red))
(point-x cp) ⇒ 3
(point-y cp) ⇒ 4
(cpoint-color cp) ⇒ red</code></pre>
</div>
</div>
<div id="page:protocols" class="paragraph">
<p>As the examples given so far illustrate, the default constructor defined by <code>define-record-type</code> accepts as many arguments as the record has fields, including parent fields, and parent&#8217;s parent fields, and so on. The programmer may override the default and specify the arguments to the constructor for the new type and how it determines the initial values of the constructed record&#8217;s fields, via the <code>protocol</code> clause. The following definition creates a <code>point</code> record with three fields: <code>x</code>, <code>y</code>, and <code>d</code>, where <code>d</code> represents the displacement from the origin. The constructor still takes only two arguments, the <code>x</code> and <code>y</code> values, and initializes <code>d</code> to the square root of the sum of the squares of <code>x</code> and <code>y</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type point
  (fields x y d)
  (protocol
    (lambda (new)
      (lambda (x y)
        (new x y (sqrt (+ (* x x) (* y y))))))))

(define p (make-point 3 4))
(point-x p) ⇒ 3
(point-y p) ⇒ 4
(point-d p) ⇒ 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>The procedure value of the expression within the <code>protocol</code> clause receives as an argument a primitive constructor <code><em>new</em></code> and returns a final constructor <code><em>c</em></code>. There are essentially no limits on what <code><em>c</em></code> is allowed to do, but if it returns, it should return the result of calling <code><em>new</em></code>. Before it does so, it may modify the new record instance (if the record type has mutable fields), register it with some external handler, print messages, etc. In this case, <code><em>c</em></code> accepts two arguments, <code><em>x</em></code> and <code><em>y</em></code>, and applies <code><em>new</em></code> to <code><em>x</em></code>, <code><em>y</em></code>, and the result of computing the origin displacement based on <code><em>x</em></code> and <code><em>y</em></code>.</p>
</div>
<div class="paragraph">
<p>If a parent record is specified, the construction protocol becomes more involved. The following definition of <code>cpoint</code> assumes that <code>point</code> has been defined as shown just above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type cpoint
  (parent point)
  (fields color)
  (protocol
    (lambda (pargs->new)
      (lambda (c x y)
        ((pargs->new x y) c)))))

(define cp (make-cpoint 'red 3 4))
(point-x cp) ⇒ 3
(point-y cp) ⇒ 4
(point-d cp) ⇒ 5
(cpoint-color cp) ⇒ red</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because a parent clause is present, the procedure value of the expression within the <code>protocol</code> clause receives a procedure <code><em>pargs</em>-&gt;<em>new</em></code> that, when applied to parent arguments, returns a <code><em>new</em></code> procedure. The <code><em>new</em></code> procedure, when passed the values of the child fields, returns the result of applying the parent protocol to an appropriate <code><em>new</em></code> procedure of its own. In this case, <code><em>pargs</em>-&gt;<em>new</em></code> is passed the values of the child constructor&#8217;s second and third arguments (the <code><em>x</em></code> and <code><em>y</em></code> values) and the resulting <code><em>new</em></code> procedure is passed the value of the child constructor&#8217;s first argument (the color). Thus, the protocol supplied in this example effectively reverses the normal order of arguments in which the parent arguments come before the child arguments, while arranging to pass along the arguments needed by the parent protocol.</p>
</div>
<div id="records:s12" class="paragraph">
<p>The default protocol is equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (new) new)</code></pre>
</div>
</div>
<div class="paragraph">
<p>for record types with no parents, while for record types with parents, the default protocol is equivalent to the following</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(lambda (pargs->new)
  (lambda (<em>x<sub>1</sub></em> ... <em>x<sub>n</sub></em> <em>y<sub>1</sub></em> ... <em>y<sub>m</sub></em>)
    ((pargs->new <em>x<sub>1</sub></em> ... <em>x<sub>n</sub></em>) <em>y<sub>1</sub></em> ... <em>y<sub>m</sub></em>)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code><em>n</em></code> is the number of parent (including grandparent, etc.) fields and <code><em>m</em></code> is the number of child fields.</p>
</div>
<div class="paragraph">
<p>Use of the <code>protocol</code> clause insulates the child record definition from some changes to the parent record type. The parent definition may be modified to add or remove fields, or even add, remove, or change a parent, yet the child protocol and constructor need not change as long as the parent protocol does not change.</p>
</div>
<div class="paragraph">
<p>Additional details and options for <code>define-record-type</code> are given in its formal description below.</p>
</div>
<div id="records:s13" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(define-record-type <em>record-name</em> <em>clause</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(define-record-type (<em>record-name</em> <em>constructor</em> <em>pred</em>) <em>clause</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records syntactic)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>define-record-type</code> form, or <em>record definition</em>, is a definition and may appear anywhere other definitions may appear. It defines a record type identified by <code><em>record-name</em></code>, plus a predicate, constructor, accessors, and mutators for the record type. If the record definition takes the first form above, the names of the constructor and predicate are derived from <code><em>record-name</em></code>: <code>make-<em>record-name</em></code> for the constructor and <code><em>record-name</em>?</code> for the predicate. If the record definition takes the second form above, the name of the constructor is <code><em>constructor</em></code> and the name of the predicate is <code><em>pred</em></code>. All names defined by a record definition are scoped where the record definition appears.</p>
</div>
<div class="paragraph">
<p>The clauses <code><em>clause</em> ...</code> of the record definition determine the fields of the record type and the names of their accessors and mutators; its parent type, if any; its construction protocol; whether it is nongenerative and, if so, whether its uid is specified; whether it is sealed; and whether it is opaque. The syntax and impact of each clause is described below.</p>
</div>
<div class="paragraph">
<p>None of the clauses is required; thus, the simplest record definition is</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type <em>record-name</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>which defines a new, generative, non-sealed, non-opaque record type with no parent and no fields, plus a constructor of no arguments and a predicate.</p>
</div>
<div class="paragraph">
<p>At most one of each kind of clause may be present in the set of clauses, and if a <code>parent</code> clause is present, a <code>parent-rtd</code> clause must not be present. The clauses that appear may appear in any order.</p>
</div>
<div class="paragraph">
<p><strong>Fields clause.</strong>  A <code>(fields <em>field-spec</em> ...)</code> clause declares the fields of the record type. Each <code><em>field-spec</em></code> must take one of the following forms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs"><em>field-name</em>
(immmutable <em>field-name</em>)
(mutable <em>field-name</em>)
(immmutable <em>field-name</em> <em>accessor-name</em>)
(mutable <em>field-name</em> <em>accessor-name</em> <em>mutator-name</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code><em>field-name</em></code>, <code><em>accessor-name</em></code>, and <code><em>mutator-name</em></code> are identifiers. The first form, <code><em>field-name</em></code>, is equivalent to <code>(immutable <em>field-name</em>)</code>. The value of a field declared immutable may not be changed, and no mutator is created for it. With the first three forms, the name of the accessor is <code><em>rname</em>-<em>fname</em></code>, where <code><em>rname</em></code> is the record name and <code><em>fname</em></code> is the field name. With the third form, the name of the accessor is <code><em>rname</em>-<em>fname</em>-set!</code>. The fourth and fifth forms explicitly declare the accessor and mutator names.</p>
</div>
<div class="paragraph">
<p>If no <code>fields</code> clause is present or the list <code><em>field-spec</em> ...</code> is empty, the record type has no fields (other than parent fields, if any).</p>
</div>
<div class="paragraph">
<p><strong>Parent clause.</strong>  A <code>(parent <em>parent-name</em>)</code> clause declares the parent record type; <code><em>parent-name</em></code> must be the name of a non-sealed record type previously defined via <code>define-record-type</code>. Instances of a record type are also considered instances of its parent record type and have all the fields of its parent record type in addition to those declared via the <code>fields</code> clause.</p>
</div>
<div class="paragraph">
<p><strong>Nongenerative clause.</strong>  A <code>nongenerative</code> clause may take one of two forms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(nongenerative)
(nongenerative <em>uid</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code><em>uid</em></code> is a symbol. The first form is equivalent to the second, with a uid generated by the implementation at macro-expansion time. When a <code>define-record-type</code> form with a nongenerative clause is evaluated, a new type is created if and only if the uid is not the uid of an existing record type.</p>
</div>
<div class="paragraph">
<p>If it is the uid of an existing record type, the parent, field-names, sealed property, and opaque property must match as follows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a parent is specified, the existing record type must have the same parent rtd (by <code>eqv?</code>). If a parent is not specified, the existing record type must not have a parent.</p>
</li>
<li>
<p>The same number of fields must be provided, with the same names and in the same order, and the mutability of each field must be the same.</p>
</li>
<li>
<p>If a <code>(sealed #t)</code> clause is present, the existing record type must be sealed. Otherwise, the existing record type must not be sealed.</p>
</li>
<li>
<p>If an <code>(opaque #t)</code> clause is present, the existing record type must be opaque. Otherwise, the existing record type must be opaque if and only if an opaque parent type is specified.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If these constraints are met, no new record type is created, and the other products of the record-type definition (constructor, predicate, accessors, and mutators) operate on records of the existing type. If these constraints are not met, the implementation may treat it as a syntax violation, or it may raise a run-time exception with condition type <code>&amp;assertion</code>.</p>
</div>
<div class="paragraph">
<p>With the first form of <code>nongenerative</code> clause, the generated uid can be the uid of an existing record type only if the same definition is executed multiple times, e.g., if it appears in the body of a procedure that is invoked multiple times.</p>
</div>
<div class="paragraph">
<p>If <code><em>uid</em></code> is not the uid of an existing record type, or if no <code>nongenerative</code> clause is present, a new record type is created.</p>
</div>
<div class="paragraph">
<p><strong>Protocol clause.</strong>  A <code>(protocol <em>expression</em>)</code> determines the protocol that the generated constructor uses to construct instances of the record type. It must evaluate to a procedure, and this procedure should be an appropriate protocol for the record type, as described on <a href="#page:protocols">page 326</a>.</p>
</div>
<div id="page:sealed" class="paragraph">
<p><strong>Sealed clause.</strong>  A <code>sealed</code> clause of the form <code>(sealed #t)</code> declares that the record type is <em>sealed</em>. This means that it cannot be extended, i.e., cannot be used as the parent for another record definition or <code>make-record-type-descriptor</code> call. If no <code>sealed</code> clause is present or if one of the form <code>(sealed #f)</code> is present, the record type is not sealed.</p>
</div>
<div id="page:opaque" class="paragraph">
<p><strong>Opaque clause.</strong>  An <code>opaque</code> clause of the form <code>(opaque #t)</code> declares that the record type is <em>opaque</em>. Instances of an opaque record type are not considered records by the <code>record?</code> predicate or, more importantly, the rtd-extraction procedure <code>record-rtd</code>, which are both described in <a href="#section_9.3.">Section 9.3</a>. Thus, it is not possible for code that does not have access to the <code>record-name</code>, accessors, or mutators to access or modify any of the fields of an opaque record type. A record type is also opaque if its parent is opaque. If no <code>opaque</code> clause is present or if one of the form <code>(opaque #f)</code> is present, and the parent, if any, is not opaque, the record type is not opaque.</p>
</div>
<div class="paragraph">
<p><strong>Parent-rtd clause.</strong>  A <code>(parent-rtd <em>parent-rtd</em> <em>parent-rcd</em>)</code> clause is an alternative to the <code>parent</code> clause for specifying the parent record type, along with a parent record constructor descriptor. It is primarily useful when the parent rtd and rcd were obtained via calls to <code>make-record-type-descriptor</code> and <code>make-record-constructor-descriptor</code>.</p>
</div>
<div class="paragraph">
<p><code><em>parent-rtd</em></code> must evaluate to an rtd or <code>#f</code>. If <code><em>parent-rtd</em></code> evaluates to <code>#f</code>, <code><em>parent-rcd</em></code> must also evaluate to <code>#f</code>. Otherwise, <code><em>parent-rcd</em></code> must evaluate to an rcd or <code>#f</code>. If <code><em>parent-rcd</em></code> evaluates to an rcd, it must encapsulate an rtd equivalent (by <code>eqv?</code>) to the value of <code><em>parent-rtd</em></code>. If the value of <code><em>parent-rcd</em></code> is <code>#f</code>, it is treated as an rcd for the value of <code><em>parent-rtd</em></code> with a default protocol.</p>
</div>
<div class="paragraph">
<p>The <code>define-record-type</code> form is designed in such a way that it is normally possible for a compiler to determine the shapes of the record types it defines, including the offsets for all fields. This guarantee does not hold, however, when the <code>parent-rtd</code> clause is used, since the parent rtd might not be determinable until run time. Thus, the <code>parent</code> clause is preferred over the <code>parent-rtd</code> clause whenever the <code>parent</code> clause suffices.</p>
</div>
<div id="records:s16" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>fields</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>mutable</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>immutable</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>parent</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>protocol</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>sealed</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>opaque</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>nongenerative</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>parent-rtd</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records syntactic)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These identifiers are auxiliary keywords for <code>define-record-type</code>. It is a syntax violation to reference these identifiers except in contexts where they are recognized as auxiliary keywords.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_9.2.">Section 9.2. Procedural Interface</h3>
<div class="paragraph">
<p>The procedural (<code>make-record-type-descriptor</code>) interface may also be used to create new record types. The procedural interface is more flexible than the syntactic interface, but this flexibility can lead to less readable and efficient programs, so programmers should use the syntactic interface whenever it suffices.</p>
</div>
<div id="records:s20" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-record-type-descriptor <em>name</em> <em>parent</em> <em>uid</em> <em>s?</em> <em>o?</em> <em>fields</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a record-type descriptor (rtd) for a new or existing record type</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records procedural)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>name</em></code> must be a symbol, <code><em>parent</em></code> must be <code>#f</code> or the rtd of a non-sealed record type, <code><em>uid</em></code> must be <code>#f</code> or a symbol, and <code><em>fields</em></code> must be a vector, each element of which is a two-element list of the form <code>(mutable <em>field-name</em>)</code> or <code>(immutable <em>field-name</em>)</code>. The field names <code><em>field-name</em> ...</code> must be symbols and need not be distinct from each other.</p>
</div>
<div class="paragraph">
<p>If <code><em>uid</em></code> is <code>#f</code> or is not the uid of an existing record type, this procedure creates a new record type and returns a record-type descriptor (rtd) for the new type. The type has the parent type (<a href="#page:parent-type">page 325</a>) described by <code><em>parent</em></code>, if nonfalse; the uid specified by <code><em>uid</em></code>, if nonfalse; and the fields specified by <code><em>fields</em></code>. It is sealed (<a href="#page:sealed">page 330</a>) if <code><em>s?</em></code> is nonfalse. It is opaque (<a href="#page:sealed">page 330</a>) if <code><em>opaque</em></code> is nonfalse or the parent (if specified) is opaque. The name of the new record type is <code><em>name</em></code> and the names of the fields are <code><em>field-name</em> ...</code>.</p>
</div>
<div class="paragraph">
<p>If <code><em>uid</em></code> is nonfalse and is the uid (<a href="#page:parent-type">page 325</a>) of an existing record type, the <code><em>parent</em></code>, <code><em>fields</em></code>, <code><em>s?</em></code>, and <code><em>o?</em></code> arguments must match the corresponding characteristics of the existing record type. That is, <code><em>parent</em></code> must be the same (by <code>eqv?</code>); the number of fields must be the same; the fields must have the same names, be in the same order, and have the same mutability; <code><em>s?</em></code> must be false if and only if the existing record type is sealed; and, if a parent is not specified or is not opaque, <code><em>o?</em></code> must be false if and only if the existing record type is opaque. If this is the case, <code>make-record-type-descriptor</code> returns the rtd for the existing record type. Otherwise, an exception with condition type <code>&amp;assertion</code> is raised.</p>
</div>
<div class="paragraph">
<p>Using the rtd returned by <code>make-record-type-descriptor</code>, programs can generate constructors, type predicates, field accessors, and field mutators dynamically. The following code demonstrates how the procedural interface might be used to create a <code>point</code> record type and associated definitions similar to those of the second <code>point</code> record definition in <a href="#section_9.1.">Section 9.1</a>, with a mutable <code>x</code> field and an immutable <code>y</code> field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define point-rtd (make-record-type-descriptor 'point #f #f #f #f
                '#((mutable x) (immutable y))))
(define point-rcd (make-record-constructor-descriptor point-rtd
                    #f #f))
(define make-point (record-constructor point-rcd))
(define point? (record-predicate point-rtd))
(define point-x (record-accessor point-rtd 0))
(define point-y (record-accessor point-rtd 1))
(define point-x-set! (record-mutator point-rtd 0))</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the additional examples given at the end of this section.</p>
</div>
<div id="records:s23" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-type-descriptor? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#f</code> if <code><em>obj</em></code> is a record-type descriptor, otherwise <code>#f</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records procedural)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>See the examples given at the end of this section.</p>
</div>
<div id="records:s24" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-record-constructor-descriptor <em>rtd</em> <em>parent-rcd</em> <em>protocol</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a record-constructor descriptor (rcd)</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records procedural)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An rtd alone is sufficient to create predicates, accessors, and mutators. To create a constructor, however, it is first necessary to create a record-constructor descriptor (rcd) for the record type. An rcd encapsulates three pieces of information: the rtd of the record type for which the rcd has been created, the parent rcd (if any), and the protocol.</p>
</div>
<div class="paragraph">
<p>The <code><em>parent-rcd</em></code> argument must be an rcd or <code>#f</code>. If it is an rcd, <code><em>rtd</em></code> must have a parent rtd, and the parent rtd must be the same as the rtd encapsulated within <code><em>parent-rcd</em></code>. If <code><em>parent-rcd</em></code> is false, either <code><em>rtd</em></code> has no parent or an rcd with a default protocol is assumed for the parent.</p>
</div>
<div class="paragraph">
<p>The <code><em>protocol</em></code> argument must be a procedure or <code>#f</code>. If it is <code>#f</code>, a default protocol is assumed. Protocols are discussed on <a href="#page:protocols">page 326</a>.</p>
</div>
<div class="paragraph">
<p>See the examples given at the end of this section.</p>
</div>
<div id="records:s28" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(record-type-descriptor <em>record-name</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the rtd for the record type identified by <code>record-name</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(record-constructor-descriptor <em>record-name</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the rcd for the record type identified by <code>record-name</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records syntactic)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Each record definition creates, behind the scenes, an rtd and rcd for the defined record type. These procedures allow the rtd and rcd to be obtained and used like any other rtd or rcd. <code><em>record-name</em></code> must be the name of a record previously defined via <code>define-record-type</code>.</p>
</div>
<div id="records:s29" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-constructor <em>rcd</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a record constructor for the record type encapsulated within <code><em>rcd</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records procedural)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The behavior of the record constructor is determined by the protocol and parent rcd (if any) also encapsulated within <code><em>rcd</em></code>.</p>
</div>
<div class="paragraph">
<p>See the examples given at the end of this section.</p>
</div>
<div id="records:s30" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-predicate <em>rtd</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a predicate for <code><em>rtd</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records procedural)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure returns a predicate that accepts one argument and returns <code>#t</code> if the argument is an instance of the record-type described by <code><em>rtd</em></code>, <code>#f</code> otherwise.</p>
</div>
<div class="paragraph">
<p>See the examples given at the end of this section.</p>
</div>
<div id="records:s31" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-accessor <em>rtd</em> <em>idx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>an accessor for the field of <code><em>rtd</em></code> specified by <code><em>idx</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records procedural)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>idx</em></code> must be a nonnegative integer less than the number of fields of <code><em>rtd</em></code>, not counting parent fields. An <code><em>idx</em></code> value of 0 specifies the first field given in the <code>define-record-type</code> form or <code>make-record-type-descriptor</code> call that created the record type, 1 specifies the second, and so on.</p>
</div>
<div class="paragraph">
<p>A child rtd cannot be used directly to create accessors for parent fields. To create an accessor for a parent field, the record-type descriptor of the parent must be used instead.</p>
</div>
<div class="paragraph">
<p>See the examples given at the end of this section.</p>
</div>
<div id="records:s32" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-mutator <em>rtd</em> <em>idx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a mutator for the field of <code><em>rtd</em></code> specified by <code><em>idx</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records procedural)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>idx</em></code> must be a nonnegative integer less than the number of fields of <code><em>rtd</em></code>, not counting parent fields. An <code><em>idx</em></code> value of 0 specifies the first field given in the <code>define-record-type</code> form or <code>make-record-type-descriptor</code> call that created the record type, 1 specifies the second, and so on. The indicated field must be mutable; otherwise, an exception with condition type <code>&amp;assertion</code> is raised.</p>
</div>
<div class="paragraph">
<p>A child rtd cannot be used directly to create mutators for parent fields. To create a mutator for a parent field, the record-type descriptor of the parent must be used instead.</p>
</div>
<div class="paragraph">
<p>The following example illustrates the creation of parent and child record types, predicates, accessors, mutators, and constructors using the procedures described in this section.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define rtd/parent
  (make-record-type-descriptor 'parent #f #f #f #f
    '#((mutable x))))

(record-type-descriptor? rtd/parent) ⇒ #t
(define parent? (record-predicate rtd/parent))
(define parent-x (record-accessor rtd/parent 0))
(define set-parent-x! (record-mutator rtd/parent 0))

(define rtd/child
  (make-record-type-descriptor 'child rtd/parent #f #f #f
    '#((mutable x) (immutable y))))

(define child? (record-predicate rtd/child))
(define child-x (record-accessor rtd/child 0))
(define set-child-x! (record-mutator rtd/child 0))
(define child-y (record-accessor rtd/child 1))

(record-mutator rtd/child 1) ⇒ <em>exception: immutable field</em>

(define rcd/parent
  (make-record-constructor-descriptor rtd/parent #f
    (lambda (new) (lambda (x) (new (* x x))))))

(record-type-descriptor? rcd/parent) ⇒ #f

(define make-parent (record-constructor rcd/parent))

(define p (make-parent 10))
(parent? p) ⇒ #t
(parent-x p) ⇒ 100
(set-parent-x! p 150)
(parent-x p) ⇒ 150

(define rcd/child
  (make-record-constructor-descriptor rtd/child rcd/parent
    (lambda (pargs->new)
      (lambda (x y)
        ((pargs->new x) (+ x 5) y)))))

(define make-child (record-constructor rcd/child))
(define c (make-child 10 'cc))
(parent? c) ⇒ #t
(child? c) ⇒ #t
(child? p) ⇒ #f

(parent-x c) ⇒ 100
(child-x c) ⇒ 15
(child-y c) ⇒ cc

(child-x p) ⇒ <em>exception: invalid argument type</em></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_9.3.">Section 9.3. Inspection</h3>
<div class="paragraph">
<p>This section describes various procedures for asking questions about or extracting information from record-type descriptors (rtds). It also describes the <code>record-rtd</code> procedure, with which the rtd of a non-opaque record instance may be extracted, allowing the record type of the instance to be inspected and, via record accessors and mutators generated from the rtd, the record itself to be inspected or modified. This is a powerful feature that permits the coding of portable record printers and inspectors.</p>
</div>
<div id="records:s33" class="paragraph">
<p>The record-type descriptor cannot be extracted from an instance of an opaque record type; this is the feature that distinguishes opaque from non-opaque record types.</p>
</div>
<div id="records:s34" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-type-name <em>rtd</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the name associated with <code><em>rtd</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records inspection)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define record->name
  (lambda (x)
    (and (record? x) (record-type-name (record-rtd x)))))

(define-record-type dim (fields w l h))
(record->name (make-dim 10 15 6)) ⇒ dim

(define-record-type dim (fields w l h) (opaque #t))
(record->name (make-dim 10 15 6)) ⇒ #f</code></pre>
</div>
</div>
<div id="records:s35" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-type-parent <em>rtd</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the parent of <code><em>rtd</em></code>, or <code>#f</code> if it has no parent</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records inspection)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type point (fields x y))
(define-record-type cpoint (parent point) (fields color))
(record-type-parent (record-type-descriptor point)) ⇒ #f
(record-type-parent (record-type-descriptor cpoint)) ⇒ #&lt;rtd&gt;</code></pre>
</div>
</div>
<div id="records:s36" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-type-uid <em>rtd</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the uid of <code><em>rtd</em></code>, or <code>#f</code> if it has no uid</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records inspection)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Whether a record type created without a programmer-supplied uid actually has one anyway is left up to the implementation, so this procedure is never guaranteed to return <code>#f</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type point (fields x y))
(define-record-type cpoint
  (parent point)
  (fields color)
  (nongenerative e40cc926-8cf4-4559-a47c-cac636630314))
(record-type-uid (record-type-descriptor point)) ⇒ <em>unspecified</em>
(record-type-uid (record-type-descriptor cpoint)) ⇒
                             e40cc926-8cf4-4559-a47c-cac636630314</code></pre>
</div>
</div>
<div id="records:s37" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-type-generative? <em>rtd</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the record type described by <code><em>rtd</em></code> is generative, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-type-sealed? <em>rtd</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the record type described by <code><em>rtd</em></code> is sealed, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-type-opaque? <em>rtd</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if the record type described by <code><em>rtd</em></code> is opaque, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records inspection)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type table
  (fields keys vals)
  (opaque #t))
(define rtd (record-type-descriptor table))
(record-type-generative? rtd) ⇒ #t
(record-type-sealed? rtd) ⇒ #f
(record-type-opaque? rtd) ⇒ #t

(define-record-type cache-table
  (parent table)
  (fields key val)
  (nongenerative))
(define rtd (record-type-descriptor cache-table))
(record-type-generative? rtd) ⇒ #f
(record-type-sealed? rtd) ⇒ #f
(record-type-opaque? rtd) ⇒ #t</code></pre>
</div>
</div>
<div id="records:s38" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-type-field-names <em>rtd</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a vector containing the names of the fields of the type described by <code><em>rtd</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records inspection)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The vector returned by this procedure is immutable: the effect on <code><em>rtd</em></code> of modifying it is unspecified. The vector does not include parent field names. The order of the names in the vector is the same as the order in which the fields were specified in the <code>define-record-type</code> form or <code>make-record-type-descriptor</code> call that created the record type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type point (fields x y))
(define-record-type cpoint (parent point) (fields color))
(record-type-field-names
  (record-type-descriptor point)) ⇒ #(x y)
(record-type-field-names
  (record-type-descriptor cpoint)) ⇒ #(color)</code></pre>
</div>
</div>
<div id="records:s39" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-field-mutable? <em>rtd</em> <em>idx</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t if the specified field of <em>rtd</em></code> is mutable, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records inspection)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code><em>idx</em></code> must be a nonnegative integer less than the number of fields of <code><em>rtd</em></code>, not counting parent fields. An <code><em>idx</em></code> value of 0 specifies the first field given in the <code>define-record-type</code> form or <code>make-record-type-descriptor</code> call that created the record type, 1 specifies the second, and so on.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type point (fields (mutable x) (mutable y)))
(define-record-type cpoint (parent point) (fields color))

(record-field-mutable? (record-type-descriptor point) 0) ⇒ #t
(record-field-mutable? (record-type-descriptor cpoint) 0) ⇒ #f</code></pre>
</div>
</div>
<div id="records:s40" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a non-opaque record instance, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records inspection)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When passed an instance of an opaque record type, <code>record?</code> returns <code>#f</code>. While an instance of an opaque record type is, in essence, a record, the point of opacity is to hide all representation information from the parts of a program that should not have access to the information, and this includes whether an object is a record. Furthermore, the primary purpose of this predicate is to allow programs to check whether it is possible to obtain from the argument an rtd via the <code>record-rtd</code> procedure described below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type statement (fields str))
(define q (make-statement "He's dead, Jim"))
(statement? q) ⇒ #t
(record? q) ⇒ #t

(define-record-type opaque-statement (fields str) (opaque #t))
(define q (make-opaque-statement "He's moved on, Jim"))
(opaque-statement? q) ⇒ #t
(record? q) ⇒ #f</code></pre>
</div>
</div>
<div id="records:s41" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(record-rtd <em>record</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the record-type descriptor (rtd) of <code><em>record</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs records inspection)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The argument must be an instance of a non-opaque record type. In combination with some of the other procedures described in this section and <a href="#section_9.2.">Section 9.2</a>, <code>record-rtd</code> allows the inspection or mutation of record instances, even if the type of the instance is unknown to the inspector. This capability is illustrated by the procedure <code>print-fields</code> below, which accepts a record argument and writes the name and value of each field of the record.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define print-fields
  (lambda (r)
    (unless (record? r)
      (assertion-violation 'print-fields "not a record" r))
    (let loop ([rtd (record-rtd r)])
      (let ([prtd (record-type-parent rtd)])
        (when prtd (loop prtd)))
      (let* ([v (record-type-field-names rtd)]
             [n (vector-length v)])
        (do ([i 0 (+ i 1)])
            ((= i n))
          (write (vector-ref v i))
          (display "=")
          (write ((record-accessor rtd i) r))
          (newline))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the familiar definitions of <code>point</code> and <code>cpoint</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type point (fields x y))
(define-record-type cpoint (parent point) (fields color))</code></pre>
</div>
</div>
<div class="paragraph">
<p>the expression <code>(print-fields (make-cpoint -3 7 'blue))</code> displays the following three lines.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">x=-3
y=7
color=blue</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chp_libraries_and_top_level_programs">Chapter 10. Libraries and Top-Level Programs</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/ch10.png" alt="ch10">
</div>
</div>
<div class="paragraph">
<p><em>Libraries</em> and <em>top-level programs</em> are the basic units of portable code in the language defined by the Revised<sup>6</sup> Report on Scheme <a href="#ref24">[24]</a>. Top-level programs may import from one or more libraries, and libraries may import from other libraries.</p>
</div>
<div class="paragraph">
<p>Libraries are named using a parenthesized syntax that encloses a sequence of identifiers, optionally followed by a version; the version is itself a parenthesized form that encloses a sequence of subversions represented as exact nonnegative integers. So, for example, <code>(a)</code>, <code>(a b)</code>, <code>(a b ())</code>, and <code>(a b (1 2 3))</code> are all valid library names. Implementations typically treat the sequence of names as a path by which a library&#8217;s source or object code can be found, possibly rooted in some standard set of locations in the host-machine&#8217;s filesystem.</p>
</div>
<div class="paragraph">
<p>An implementation of the standard library mechanism is available with the portable implementation of <code>syntax-case</code> at <em><a href="http://www.cs.indiana.edu/syntax-case/" class="bare">http://www.cs.indiana.edu/syntax-case/</a></em>.</p>
</div>
<div class="sect2">
<h3 id="section_10.1.">Section 10.1. Standard Libraries</h3>
<div class="paragraph">
<p>The Revised<sup>6</sup> Report <a href="#ref24">[24]</a> describes a base library</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(rnrs base (6))</code></pre>
</div>
</div>
<div class="paragraph">
<p>that defines the most commonly used features of the language. A separate Standard Libraries document <a href="#ref26">[26]</a> describes the libraries listed below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(rnrs arithmetic bitwise (6))
  (rnrs arithmetic fixnums (6))
  (rnrs arithmetic flonums (6))
  (rnrs bytevectors (6))
  (rnrs conditions (6))
  (rnrs control (6))
  (rnrs enums (6))
  (rnrs eval (6))
  (rnrs exceptions (6))
  (rnrs files (6))
  (rnrs hashtables (6))
  (rnrs io ports (6))
  (rnrs io simple (6))
  (rnrs lists (6))
  (rnrs mutable-pairs (6))
  (rnrs mutable-strings (6))
  (rnrs programs (6))
  (rnrs r5rs (6))
  (rnrs records procedural (6))
  (rnrs records syntactic (6))
  (rnrs records inspection (6))
  (rnrs sorting (6))
  (rnrs syntax-case (6))
  (rnrs unicode (6))</code></pre>
</div>
</div>
<div class="paragraph">
<p>One more library is described in the Standard Libraries document, a composite library</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(rnrs (6))</code></pre>
</div>
</div>
<div class="paragraph">
<p>that exports all of the <code>(rnrs base (6))</code> bindings along with those of the other libraries listed above, except those of <code>(rnrs eval (6))</code>, <code>(rnrs mutable-pairs (6))</code>, <code>(rnrs mutable-strings (6))</code>, and <code>(rnrs r5rs (6))</code>.</p>
</div>
<div class="paragraph">
<p>Although each of these libraries has the version <code>(6)</code>, references to them can and in most cases should leave the version out, e.g., the composite library should be referenced simply as <code>(rnrs)</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_10.2.">Section 10.2. Defining New Libraries</h3>
<div class="paragraph">
<p>New libraries are defined with the <code>library</code> form, which has the following syntax.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library <em>library-name</em>
  (export <em>export-spec</em> ...)
  (import <em>import-spec</em> ...)
  <em>library-body</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code><em>library-name</em></code> specifies the name and possibly version by which the library is identified by the <code>import</code> form of another library or top-level program. It also serves as kind of path that the implementation uses to locate the library, via some implementation-specific process, whenever it needs to be loaded. A <code><em>library-name</em></code> has one of the following two forms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(<em>identifier</em> <em>identifier</em> ...)
(<em>identifier</em> <em>identifier</em> ... <em>version</em>)</code></pre>
</div>
</div>
<div id="libraries:s2" class="paragraph">
<p>where <code><em>version</em></code> has the following form:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(<em>subversion</em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>and each <code><em>subversion</em></code> represents an exact nonnegative integer. A library name with no <code><em>version</em></code> is treated the same as a library name with the empty <code><em>version</em></code> <code>()</code>. For example, <code>(list-tools setops)</code> and <code>(list-tools setops ())</code> are equivalent and specify a library name with no version, while <code>(list-tools setops (1 2))</code> specifies a versioned library name, which can be thought of as Version 1.2 of the <code>(list-tools setops)</code> library.</p>
</div>
<div id="libraries:s3" class="paragraph">
<p>The <code>export</code> subform names the exports and, optionally, the names by which they should be known outside of the library. Each <code><em>export-spec</em></code> takes one of the following two forms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs"><em>identifier</em>
(rename (<em>internal-name</em> <em>export-name</em>) ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where each <code><em>internal-name</em></code> and <code><em>export-name</em></code> is an identifier. The first form names a single export, <code><em>identifier</em></code>, whose export name is the same as its internal name. The second names a set of exports, each of whose export name is given explicitly and may differ from its internal name.</p>
</div>
<div id="desc:import" class="paragraph">
<p>The <code>import</code> subform names the other libraries upon which the new library depends and, possibly, the set of identifiers to be imported and the names by which they should be known inside the new library. It may also specify when the bindings should be made available for implementations that require such information. Each <code><em>import-spec</em></code> takes one of the following two forms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs"><em>import-set</em>
(for <em>import-set</em> <em>import-level</em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code><em>import-level</em></code> is one of the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">run
expand
(meta <em>level</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>and <code><em>level</em></code> represents an exact integer.</p>
</div>
<div id="libraries:s6" class="paragraph">
<p>The <code>for</code> syntax declares when the imported bindings might be used by the importing library and thus when the implementation must make the bindings available. <code>run</code> and <code>(meta 0)</code> are equivalent and specify that the bindings imported from a library might be referenced by the run-time expressions (<code>define</code> right-hand-side expressions and initialization expressions) of the importing library. <code>expand</code> and <code>(meta 1)</code> are equivalent and specify that the bindings imported from a library might be referenced by the transformer expressions (<code>define-syntax</code>, <code>let-syntax</code>, or <code>letrec-syntax</code> right-hand-side expressions) of the importing library. <code>(meta 2)</code> specifies that the bindings imported from a library might be referenced by a transformer expression that appears within a transformer expression of the importing library, and so on for higher meta levels. Negative meta levels may also be specified and are needed in certain circumstances when a transformer expands into the transformer for another keyword binding used at a lower meta level.</p>
</div>
<div id="export-level" class="paragraph">
<p>A library export may have a non-zero <em>export</em> meta level, in which case the effective import level is the sum of the level specified by <code>for</code> and the export level. The exports of each standard library except <code>(rnrs base)</code> and <code>(rnrs)</code> have export level zero. For <code>(rnrs base)</code>, all exports have export level zero except for <code>syntax-rules</code>, <code>identifier-syntax</code>, and their auxiliary keywords <code>_</code>, <code>...</code>, and <code>set!</code>. <code>set!</code> has export levels zero and one, while the others have export level one. All exports of the <code>(rnrs)</code> library have export levels zero and one.</p>
</div>
<div class="paragraph">
<p>It can be difficult for the programmer to specify the import levels that allow a library or top-level program to compile or run properly. Moreover, it is often impossible to cause a library&#8217;s bindings to be made available when they are needed without causing them to be made available in some cases when they are not needed. For example, it is not possible to say that the run-time bindings of a library A are needed when a library B is expanded without also having the run-time bindings of A made available when code importing B is expanded. Making bindings available involves executing the code for the right-hand sides of the bindings and possibly executing initialization expressions as well, so the inability to specify when bindings are needed precisely can add both compile- and run-time overhead to a program.</p>
</div>
<div class="paragraph">
<p>Because of this, implementations are permitted to ignore export levels and the <code>for</code> wrapper on an <code><em>import-set</em></code> and instead automatically determine, while expanding an importing library or top-level program, when an imported library&#8217;s bindings must be made available, based on where references to the imported library&#8217;s exports actually appear. When using such an implementation, the <code>for</code> wrapper need never be used, i.e., all <code><em>import-spec</em></code>s can be <code><em>import-set</em></code>s. If code is intended for use with systems that do not automatically determine when a library&#8217;s bindings must be made available, however, the <code>for</code> must be used if the imported library&#8217;s bindings would not otherwise be available at the right time.</p>
</div>
<div class="paragraph">
<p>An <code><em>import-set</em></code> takes one of the following forms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs"><em>library-spec</em>
(only <em>import-set</em> <em>identifier</em> ...)
(except <em>import-set</em> <em>identifier</em> ...)
(prefix <em>import-set</em> <em>prefix</em>)
(rename <em>import-set</em> (<em>import-name</em> <em>internal-name</em>) ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where <code><em>prefix</em></code>, <code><em>import-name</em></code>, and <code><em>internal-name</em></code> are identifiers. An <code><em>import-set</em></code> is a recursive specification of the identifiers to be imported from a library and possibly the names by which they should be known within the importing library. At the base of the recursive structure must sit a <code><em>library-spec</em></code>, which identifies a library and imports all of the identifiers from that library. An <code>only</code> wrapper restricts the imported identifiers of the enclosed <code><em>import-set</em></code> to the ones listed, an <code>except</code> wrapper restricts the imported identifiers of the enclosed <code><em>import-set</em></code> to those not listed, a <code>prefix</code> wrapper adds a prefix to each of the imported identifiers of the enclosed <code><em>import-set</em></code>, and a <code>rename</code> wrapper specifies internal names for selected identifiers of the enclosed <code><em>import-set</em></code>, while leaving the names of the other imports alone. So, for example, the <code><em>import-set</em></code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(prefix
  (only
    (rename (list-tools setops) (difference diff))
    union
    diff)
  set:)</code></pre>
</div>
</div>
<div class="paragraph">
<p>imports only <code>union</code> and <code>difference</code> from the <code>(list-tools setops)</code> library, renames <code>difference</code> to <code>diff</code> while leaving <code>union</code> alone, and adds the prefix <code>set:</code> to the two names so that the names by which the two imports are known inside the importing library are <code>set:union</code> and <code>set:diff</code>.</p>
</div>
<div class="paragraph">
<p>A <code><em>library-spec</em></code> takes one of the following forms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs"><em>library-reference</em>
(library <em>library-reference</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>where a <code><em>library-reference</em></code> is in either of the following two forms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(<em>identifier</em> <em>identifier</em> ...)
(<em>identifier</em> <em>identifier</em> ... <em>version-reference</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Enclosing a <code><em>library-reference</em></code> in a <code>library</code> wrapper is necessary when the first identifier of the <code><em>library-reference</em></code> is <code>for</code>, <code>library</code>, <code>only</code>, <code>except</code>, <code>prefix</code>, or <code>rename</code>, to distinguish it from an <code><em>import-spec</em></code> or <code><em>import-set</em></code> identified by one of these keywords.</p>
</div>
<div id="libraries:s13" class="paragraph">
<p>A <code><em>version-reference</em></code> identifies a particular version of the library or a set of possible versions. A <code><em>version-reference</em></code> has one of the following forms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(<em>subversion-reference<sub>1</sub></em> ... <em>subversion-reference<sub>n</sub></em>)
(and <em>version-reference</em> ...)
(or <em>version-reference</em> ...)
(not <em>version-reference</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code><em>version-reference</em></code> of the first form matches a <code><em>version</em></code> with at least <em>n</em> elements if each <code><em>subversion-reference</em></code> matches <code><em>version</em></code>'s corresponding <code><em>subversion</em></code>. An <code>and</code> <code><em>version-reference</em></code> form matches a <code><em>version</em></code> if each of its <code><em>version-reference</em></code> subforms matches <code><em>version</em></code>. An <code>or</code> <code><em>version-reference</em></code> form matches a <code><em>version</em></code> if any of its <code><em>version-reference</em></code> subforms matches <code><em>version</em></code>. A <code>not</code> <code><em>version-reference</em></code> form matches a <code><em>version</em></code> if its <code><em>version-reference</em></code> subform does not match <code><em>version</em></code>.</p>
</div>
<div class="paragraph">
<p>A <code><em>subversion-reference</em></code> takes one of the following forms:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs"><em>subversion</em>
(>= <em>subversion</em>)
(<= <em>subversion</em>)
(and <em>subversion-reference</em> ...)
(or <em>subversion-reference</em> ...)
(not <em>subversion-reference</em>)</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code><em>subversion-reference</em></code> of the first form matches a <code><em>subversion</em></code> if it is identical to it. A <code>&gt;=</code> <code><em>subversion-reference</em></code> matches a <code><em>version</em></code>'s <code><em>subversion</em></code> if the <code><em>version</em></code>'s <code><em>subversion</em></code> is greater than or equal to the <code><em>subversion</em></code> appearing within the <code>&gt;=</code> form. Similarly, a <code>&lt;=</code> <code><em>subversion-reference</em></code> matches a <code><em>version</em></code>'s <code><em>subversion</em></code> if the <code><em>version</em></code>'s <code><em>subversion</em></code> is less than or equal to the <code><em>subversion</em></code> appearing within the <code>&lt;=</code> form. An <code>and</code> <code><em>subversion-reference</em></code> form matches a <code><em>version</em></code>'s <code><em>subversion</em></code> if each of its <code><em>subversion-reference</em></code> subforms matches the <code><em>version</em></code>'s <code><em>subversion</em></code>. An <code>or</code> <code><em>subversion-reference</em></code> matches a <code><em>version</em></code>'s <code><em>subversion</em></code> if any of its <code><em>subversion-reference</em></code> subforms match the <code><em>version</em></code>'s <code><em>subversion</em></code>. A <code>not</code> <code><em>subversion-reference</em></code> matches a <code><em>version</em></code>'s <code><em>subversion</em></code> if its <code><em>subversion-reference</em></code> subform does not match the <code><em>version</em></code>'s <code><em>subversion</em></code>.</p>
</div>
<div class="paragraph">
<p>For example, if two versions of a library are available, one with version <code>(1 2)</code> and the other with version <code>(1 3 1)</code>, the version references <code>()</code> and <code>(1)</code> match both, <code>(1 2)</code> matches the first but not the second, <code>(1 3)</code> matches the second but not the first, <code>(1 (&gt;= 2))</code> matches both, and <code>(and (1 (&gt;= 3)) (not (1 3 1)))</code> matches neither.</p>
</div>
<div class="paragraph">
<p>When a library reference identifies more than one available library, one of the available libraries is selected in some implementation-dependent manner.</p>
</div>
<div class="paragraph">
<p>Libraries and top-level programs should not, directly or indirectly, specify the import of two libraries that have the same names but different versions. To avoid problems such as incompatible types and replicated state, implementations are encouraged, though not required, to prohibit programs from importing two versions of the same library.</p>
</div>
<div id="libraries:s14" class="paragraph">
<p>A <code><em>library-body</em></code> contains definitions of exported identifiers, definitions of identifiers not intended for export, and initialization expressions. It consists of a (possibly empty) sequence of definitions followed by a (possibly empty) sequence of initialization expressions. When <code>begin</code>, <code>let-syntax</code>, or <code>letrec-syntax</code> forms occur in a library body prior to the first expression, they are spliced into the body. Any body form may be produced by a syntactic extension, including definitions, the splicing forms just mentioned, or initialization expressions. A library body is expanded in the same manner as a <code>lambda</code> or other body (<a href="#body-expansion">page 292</a>), and it expands into the equivalent of a <code>letrec*</code> form so that the definitions and initialization forms in the body are evaluated from left to right.</p>
</div>
<div class="paragraph">
<p>Each of the exports listed in a library&#8217;s <code>export</code> form must either be imported from another library or defined within the <code><em>library-body</em></code>, in either case with the internal rather than the export name, if the two differ.</p>
</div>
<div class="paragraph">
<p>Each identifier imported into or defined within a library must have exactly one binding. If imported into a library, it must not be defined in the library body, and if defined in the library body, it must be defined only once. If imported from two libraries, it must have the same binding in both cases, which can happen only if the binding originates in one of the two libraries and is reexported by the other or if the binding originates in a third library and is reexported by both.</p>
</div>
<div id="libraries:s15" class="paragraph">
<p>The identifiers defined within a library and not exported by the library are not visible in code that appears outside of the library. A syntactic extension defined within a library may, however, expand into a reference to such an identifier, so that the expanded code does contain a reference to the identifier; this is referred to as an <em>indirect export</em>.</p>
</div>
<div id="libraries:s16" class="paragraph">
<p>The exported variables of a library are <em>immutable</em> both inside the library and outside, whether they are explicitly or implicitly exported. It is a syntax violation if an explicitly exported variable appears on the left-hand side of a <code>set!</code> expression within or outside of the exporting library. It is also a syntax violation if any other variable defined by a library appears on the left-hand side of a <code>set!</code> expression and is indirectly exported.</p>
</div>
<div class="paragraph">
<p>Libraries are loaded and the code contained within them evaluated on an "as needed" basis by the implementation, as determined by the import relationships among libraries. A library&#8217;s transformer expressions (the expressions on the right-hand sides of a library body&#8217;s <code>define-syntax</code> forms) may be evaluated at different times from the library&#8217;s body expressions (the expressions on the right-hand side of the body&#8217;s <code>define</code> forms, plus initialization expressions). At a minimum, the transformer expressions of a library must be evaluated when (if not before) a reference to one of the library&#8217;s exported keywords is found while expanding another library or top-level program, and the body expressions must be evaluated when (if not before) a reference to one of the library&#8217;s exported variables is evaluated, which may occur either when a program using the library is run or when another library or top-level program is being expanded, if the reference is evaluated by a transformer called during the expansion process. An implementation may evaluate a library&#8217;s transformer and body expressions as many times as it pleases in the process of expanding other libraries. In particular, it may evaluate the expressions zero times if they are not actually needed, exactly one time, or one time for each meta level of the expansion. It is generally a bad idea for the evaluation of a library&#8217;s transformer or body expressions to involve externally visible side effects, e.g., popping up a window, since the time or times at which these side effects occur is unspecified. Localized effects that affect only the library&#8217;s initialization, e.g., to create a table used by the library, are generally okay.</p>
</div>
<div class="paragraph">
<p>Examples are given in <a href="#section_10.4.">Section 10.4</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_10.3.">Section 10.3. Top-Level Programs</h3>
<div class="paragraph">
<p>A top-level program is not a syntactic form per se but rather a set of forms that are usually delimited only by file boundaries. Top-level programs can be thought of as library forms without the <code>library</code> wrapper, library name, and export form. The other difference is that definitions and expressions can be intermixed within the body of a top-level program but not within the body of a library. Thus the syntax of a top-level program is, simply, an <code>import</code> form followed by a sequence of definitions and expressions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(import <em>import-spec</em> ...)
<em>definition-or-expression</em>
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>An expression that appears within a top-level program body before one or more definitions is treated as if it appeared on the right-hand side of a definition for a dummy variable that is not visible anywhere within the program.</p>
</div>
<div id="libraries:s17" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(command-line)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a list of strings representing command-line arguments</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs programs)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure may be used within a top-level program to obtain a list of the command-line arguments passed to the program.</p>
</div>
<div id="libraries:s18" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(exit)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(exit <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>does not return</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs programs)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure may be used to exit from a top-level program to the operating system. If no <code><em>obj</em></code> is given, the exit value returned to the operating system should indicate a normal exit. If <code><em>obj</em></code> is false, the exit value returned to the operating system should indicate an abnormal exit. Otherwise, <code><em>obj</em></code> is translated into an exit value as appropriate for the operating system.</p>
</div>
</div>
<div class="sect2">
<h3 id="section_10.4.">Section 10.4. Examples</h3>
<div class="paragraph">
<p>The example below demonstrates several features of the <code>library</code> syntax. It defines "Version 1" of the <code>(list-tools setops)</code> library, which exports two keywords and several variables. The library imports the <code>(rnrs base)</code> library, which provides everything it needs except the <code>member</code> procedure, which it imports from <code>(rnrs lists)</code>. Most of the variables exported by the library are bound to procedures, which is typical.</p>
</div>
<div class="paragraph">
<p>The syntactic extension <code>set</code> expands into a reference to the variable <code>list-&gt;set</code>, and <code>member?</code> similarly expands into a reference to the variable <code>member-help?</code>. While <code>list-&gt;set</code> is explicitly exported, <code>member-help?</code> is not. This makes <code>member-help?</code> an indirect export. The procedure <code>u-d-help</code> is not explicitly exported, and since neither of the exported syntactic extensions expand into references to <code>u-d-help</code>, it is not indirectly exported either. This means it could be assigned, but it is not assigned in this example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (list-tools setops (1))
  (export set empty-set empty-set? list->set set->list
          union intersection difference member?)
  (import (rnrs base) (only (rnrs lists) member))

  (define-syntax set
    (syntax-rules ()
      [(_ x ...)
       (list->set (list x ...))]))

  (define empty-set '())

  (define empty-set? null?)

  (define list->set
    (lambda (ls)
      (cond
        [(null? ls) '()]
        [(member (car ls) (cdr ls)) (list->set (cdr ls))]
        [else (cons (car ls) (list->set (cdr ls)))])))

  (define set->list (lambda (set) set))

  (define u-d-help
    (lambda (s1 s2 ans)
      (let f ([s1 s1])
        (cond
          [(null? s1) ans]
          [(member? (car s1) s2) (f (cdr s1))]
          [else (cons (car s1) (f (cdr s1)))]))))

  (define union
    (lambda (s1 s2)
      (u-d-help s1 s2 s2)))

  (define intersection
    (lambda (s1 s2)
      (cond
        [(null? s1) '()]
        [(member? (car s1) s2)
         (cons (car s1) (intersection (cdr s1) s2))]
        [else (intersection (cdr s1) s2)])))

  (define difference
    (lambda (s1 s2)
      (u-d-help s1 s2 '())))

  (define member-help?
    (lambda (x s)
      (and (member x s) #t)))

  (define-syntax member?
    (syntax-rules ()
      [(_ elt-expr set-expr)
       (let ([x elt-expr] [s set-expr])
         (and (not (null? s)) (member-help? x s)))])))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next library, <code>(more-setops)</code>, defines a few additional set operations in terms of the <code>(list-tools setops)</code> operations. No version is included in the library reference to <code>(list-tools setops)</code>; this is equivalent to an empty version reference, which matches any version. The <code>quoted-set</code> keyword is interesting because its transformer references <code>list-&gt;set</code> from <code>(list-tools setops)</code> at expansion time. As a result, if another library or top-level program that imports from <code>(more-setops)</code> references <code>quoted-set</code>, the run-time expressions of the <code>(list-tools setops)</code> library will have to be evaluated when the other library or top-level program is expanded. On the other hand, the run-time expressions of the <code>(list-tools setops)</code> library need not be evaluated when the <code>(more-setops)</code> library is itself expanded.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (more-setops)
  (export quoted-set set-cons set-remove)
  (import (list-tools setops) (rnrs base) (rnrs syntax-case))

  (define-syntax quoted-set
    (lambda (x)
      (syntax-case x ()
        [(k elt ...)
         #`(quote
             #,(datum->syntax #'k
                 (list->set
                   (syntax->datum #'(elt ...)))))])))

  (define set-cons
    (lambda (opt optset)
      (union (set opt) optset)))

  (define set-remove
    (lambda (opt optset)
      (difference optset (set opt)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the implementation does not automatically infer when bindings need to be made available, the <code>import</code> form in the <code>(more-setops)</code> library must be modified to specify at which meta levels the bindings it imports are used via the <code>for</code> <code><em>import-spec</em></code> syntax as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(import
  (for (list-tools setops) expand run)
  (for (rnrs base) expand run)
  (for (rnrs syntax-case) expand))</code></pre>
</div>
</div>
<div class="paragraph">
<p>To complete the example, the short top-level program below exercises several of the <code>(list-tools setops)</code> and <code>(more-setops)</code> exports.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(import (list-tools setops) (more-setops) (rnrs))
(define-syntax pr
  (syntax-rules ()
    [(_ obj)
     (begin
       (write 'obj)
       (display " ;=> ")
       (write obj)
       (newline))]))
(define get-set1
  (lambda ()
    (quoted-set a b c d)))
(define set1 (get-set1))
(define set2 (quoted-set a c e))

(pr (list set1 set2))
(pr (eq? (get-set1) (get-set1)))
(pr (eq? (get-set1) (set 'a 'b 'c 'd)))
(pr (union set1 set2))
(pr (intersection set1 set2))
(pr (difference set1 set2))
(pr (set-cons 'a set2))
(pr (set-cons 'b set2))
(pr (set-remove 'a set2))</code></pre>
</div>
</div>
<div class="paragraph">
<p>What running this program should print is left as an exercise for the reader.</p>
</div>
<div class="paragraph">
<p>Additional library and top-level program examples are given in <a href="#chp_extended_examples">Chapter 12</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chp_exceptions_and_conditions">Chapter 11. Exceptions and Conditions</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/ch11.png" alt="ch11">
</div>
</div>
<div class="paragraph">
<p><em>Exceptions</em> and <em>conditions</em> provide the means for system and user code to signal, detect, and recover from errors that occur when a program is run.</p>
</div>
<div class="paragraph">
<p>Exceptions are raised by the standard syntactic forms and procedures under a variety of circumstances, e.g., when the wrong number of arguments is passed to a procedure, when the syntax of an expression passed to <code>eval</code> is incorrect, or when a file cannot be opened by one of the file open procedures. In these situations, the exception is raised with a standard condition type.</p>
</div>
<div class="paragraph">
<p>Exceptions may also be raised by user code via the <code>raise</code> or <code>raise-continuable</code> procedures. In this case, the exception may be raised with one of the standard condition types, a user-defined subtype of one of the standard condition types (possibly defined using <code>define-condition-type</code>), or an arbitrary Scheme value that is not a condition type.</p>
</div>
<div class="paragraph">
<p>At any point during a program&#8217;s execution, a single exception handler, called the <em>current exception handler</em>, is charged with handling all exceptions that are raised. By default, the current exception handler is one provided by the implementation. The default exception handler typically prints a message that describes the condition or other value with which the exception was raised and, for any serious condition, terminates the running program. In interactive systems, this typically means a reset to the read-eval-print loop.</p>
</div>
<div class="paragraph">
<p>User code may establish a new current exception handler via the <code>guard</code> syntax or the <code>with-exception-handler</code> procedure. In either case, the user code may handle all exceptions or, based on the condition or other value with which the exception was raised, just some of the exceptions while reraising the others for the old current exception handler to handle. When <code>guard</code> forms and <code>with-exception-handler</code> calls are nested dynamically, a chain of exception handlers is established, and each may defer to the next in the chain.</p>
</div>
<div class="sect2">
<h3 id="section_11.1.">Section 11.1. Raising and Handling Exceptions</h3>
<div id="exceptions:s3" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(raise <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(raise-continuable <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs exceptions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Both of these procedures raise an exception, effectively invoking the current exception handler, passing <code><em>obj</em></code> as the only argument. For <code>raise</code>, the exception is <em>non-continuable</em>, while for <code>raise-continuable</code>, the exception is <em>continuable</em>. An exception handler may return (with zero or more values) to the continuation of a continuable exception. If an exception handler attempts to return to the continuation of a non-continuable exception, however, a new exception with condition type <code>&amp;non-continuable</code> is raised. Thus, <code>raise</code> never returns, while <code>raise-continuable</code> may return zero or more values, depending upon the exception handler.</p>
</div>
<div class="paragraph">
<p>If the current exception handler, <code><em>p</em></code>, was established via a <code>guard</code> form or call to <code>with-exception-handler</code>, the current exception handler is reset to the handler that was current when <code><em>p</em></code> was established before <code>raise</code> or <code>raise-continuable</code> invokes <code><em>p</em></code>. This allows <code><em>p</em></code> to defer to the preexisting exception handler simply by reraising the exception, and it helps prevent infinite regression when an exception handler inadvertently causes a different exception to be raised. If <code><em>p</em></code> returns and the exception is continuable, <code><em>p</em></code> is reinstated as the current exception handler.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(raise
  (condition
    (make-error)
    (make-message-condition "no go"))) ⇒ <em>error: no go</em>
(raise-continuable
  (condition
    (make-violation)
    (make-message-condition "oops"))) ⇒ <em>violation: oops</em>
(list
  (call/cc
    (lambda (k)
      (vector
        (with-exception-handler
          (lambda (x) (k (+ x 5)))
          (lambda () (+ (raise 17) 8))))))) ⇒ (22)
(list
  (vector
    (with-exception-handler
      (lambda (x) (+ x 5))
      (lambda () (+ (raise-continuable 17) 8))))) ⇒ (#(30))
(list
  (vector
    (with-exception-handler
      (lambda (x) (+ x 5))
      (lambda () (+ (raise 17) 8))))) ⇒ <em>violation: non-continuable</em></code></pre>
</div>
</div>
<div id="exceptions:s4" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(error <em>who</em> <em>msg</em> <em>irritant</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(assertion-violation <em>who</em> <em>msg</em> <em>irritant</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>error</code> raises a non-continuable exception with condition type <code>&amp;error</code> and should be used to describe situations for which the <code>&amp;error</code> condition type is appropriate, typically a situation involving the program&#8217;s interaction with something outside of the program. <code>assertion-violation</code> raises a non-continuable exception with condition type <code>&amp;assertion</code> and should be used to describe situations for which the <code>&amp;assertion</code> condition type is appropriate, typically an invalid argument to a procedure or invalid value of a subexpression of a syntactic form.</p>
</div>
<div class="paragraph">
<p>The continuation object with which the exception is raised also includes a <code>&amp;who</code> condition whose who field is <code><em>who</em></code> if <code><em>who</em></code> is not <code>#f</code>, a <code>&amp;message</code> condition whose message field is <code><em>msg</em></code>, and an <code>&amp;irritants</code> condition whose irritants field is <code>(<em>irritant</em> ...)</code>.</p>
</div>
<div class="paragraph">
<p><code><em>who</em></code> must be a string, a symbol, or <code>#f</code> identifying the procedure or syntactic form reporting the error upon whose behalf the error is being reported. It is usually best to identify a procedure the programmer has called rather than some other procedure the programmer may not be aware is involved in carrying out the operation. <code><em>msg</em></code> must be a string and should describe the exceptional situation. The irritants may be any Scheme objects and should include values that may have caused or been materially involved in the exceptional situation.</p>
</div>
<div id="exceptions:s5" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(assert <em>expression</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs base)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>assert</code> evaluates <code><em>expression</em></code> and returns the value of <code><em>expression</em></code> if the value is not <code>#f</code>. If the value of <code><em>expression</em></code> is <code>#f</code>, <code>assert</code> raises a non-continuable exception with condition types <code>&amp;assertion</code> and <code>&amp;message</code>, with an implementation-dependent value in its message field. Implementations are encouraged to provide information about the location of the <code>assert</code> call within the condition whenever possible.</p>
</div>
<div id="exceptions:s6" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(syntax-violation <em>who</em> <em>msg</em> <em>form</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(syntax-violation <em>who</em> <em>msg</em> <em>form</em> <em>subform</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>does not return</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs syntax-case)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure raises a non-continuable exception with a condition of type <code>&amp;syntax</code>. It should be used to report a syntax error detected by the transformer of a syntactic extension. The value of the condition&#8217;s form field is <code><em>form</em></code>, and the value of its subform field is <code><em>subform</em></code>, or <code>#f</code> if <code><em>subform</em></code> is not provided.</p>
</div>
<div class="paragraph">
<p>The continuation object with which the exception is raised also includes a <code>&amp;who</code> condition whose who field is <code><em>who</em></code>, if <code><em>who</em></code> is not <code>#f</code> or is inferred from <code><em>form</em></code>, and a <code>&amp;message</code> condition whose message field is <code><em>msg</em></code>.</p>
</div>
<div class="paragraph">
<p><code><em>who</em></code> must be a string, a symbol, or <code>#f</code>. If <code><em>who</em></code> is <code>#f</code>, it is inferred to be the symbolic name of <code><em>form</em></code> if <code><em>form</em></code> is an identifier or the symbolic name of the first subform of <code><em>form</em></code> if <code><em>form</em></code> is a list-structured form whose first subform is an identifier. <code><em>message</em></code> must be a string. <code><em>form</em></code> should be the syntax object or datum representation of the syntactic form within which the syntax violation occurred, and <code><em>subform</em></code>, if not <code>#f</code>, should be a syntax object or datum representation of a subform more specifically involved in the violation. For example, if a duplicate formal parameter is found in a <code>lambda</code> expression, <code><em>form</em></code> might be the <code>lambda</code> expression and <code><em>subform</em></code> might be the duplicated parameter.</p>
</div>
<div class="paragraph">
<p>Some implementations attach source information to syntax objects, e.g., line, character, and filename for forms originating in a file, in which case this information might also be present as some implementation-dependent condition type within the condition object.</p>
</div>
<div id="exceptions:s7" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(with-exception-handler <em>procedure</em> <em>thunk</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs exceptions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This procedure establishes <code><em>procedure</em></code>, which should accept one argument, as the current exception handler in place of the old current exception handler, <code><em>old-proc</em></code>, and invokes <code><em>thunk</em></code> without arguments. If the call to <code><em>thunk</em></code> returns, <code><em>old-proc</em></code> is reestablished as the current exception handler and the values returned by <code><em>thunk</em></code> are returned. If control leaves or subsequently reenters the call to <code><em>thunk</em></code> via the invocation of a continuation obtained via <code>call/cc</code>, the procedure that was the current exception handler when the continuation was captured is reinstated.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define (try thunk)
  (call/cc
    (lambda (k)
      (with-exception-handler
        (lambda (x) (if (error? x) (k #f) (raise x)))
        thunk))))
(try (lambda () 17)) ⇒ 17
(try (lambda () (raise (make-error)))) ⇒ #f
(try (lambda () (raise (make-violation)))) ⇒ <em>violation</em>
(with-exception-handler
  (lambda (x)
    (raise
      (apply condition
        (make-message-condition "oops")
        (simple-conditions x))))
  (lambda ()
    (try (lambda () (raise (make-violation)))))) ⇒ <em>violation: oops</em></code></pre>
</div>
</div>
<div id="exceptions:s8" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(guard (<em>var</em> <em>clause<sub>1</sub></em> <em>clause<sub>2</sub></em> ...) <em>b1</em> <em>b2</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>see below</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs exceptions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>guard</code> expression establishes a new current exception handler, <code><em>procedure</em></code> (described below), in place of the old current exception handler, <code><em>old-proc</em></code>, and evaluates the body <code><em>b1</em> <em>b2</em> ...</code>. If the body returns, <code>guard</code> reestablishes <code><em>old-proc</em></code> as the current exception handler. If control leaves or subsequently reenters the body via the invocation of a continuation obtained via <code>call/cc</code>, the procedure that was the current exception handler when the continuation was captured is reinstated.</p>
</div>
<div class="paragraph">
<p>The procedure <code><em>procedure</em></code> established by <code>guard</code> binds <code><em>var</em></code> to the value it receives and, within the scope of that binding, processes the clauses <code><em>clause<sub>1</sub></em> <em>clause<sub>2</sub></em> ...</code> in turn, as if contained within an implicit <code>cond</code> expression. This implicit <code>cond</code> expression is evaluated in the continuation of the <code>guard</code> expression, with <code><em>old-proc</em></code> as the current exception handler.</p>
</div>
<div class="paragraph">
<p>If no <code>else</code> clause is provided, <code>guard</code> supplies one that reraises the exception with the same value, as if with <code>raise-continuable</code>, in the continuation of the call to <code><em>procedure</em></code>, with <code><em>old-proc</em></code> as the current exception handler.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(guard (x [else x]) (raise "oops")) ⇒ "oops"
(guard (x [#f #f]) (raise (make-error))) ⇒  <em>error</em>
(define-syntax try
  (syntax-rules ()
    [(_ e1 e2 ...)
     (guard (x [(error? x) #f]) e1 e2 ...)]))
(define open-one
  (lambda fn*
    (let loop ([ls fn*])
      (if (null? ls)
          (error 'open-one "all open attempts failed" fn*)
          (or (try (open-input-file (car ls)))
              (loop (cdr ls)))))))
; say bar.ss exists but not foo.ss:
(open-one "foo.ss" "bar.ss") ⇒ #&lt;input port bar.ss&gt;</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_11.2.">Section 11.2. Defining Condition Types</h3>
<div class="paragraph">
<p>While a program may pass <code>raise</code> or <code>raise-continuable</code> any Scheme value, the best way to describe an exceptional situation is usually to create and pass a <em>condition object</em>. Where the Revised<sup>6</sup> Report requires the implementation to raise exceptions, the value passed to the current exception handler is always a condition object of one or more of the standard <em>condition types</em> described in <a href="#section_11.3.">Section 11.3</a>. User code may create a condition object that is an instance of one or more standard condition types or it may create an extended condition type and create a condition object of that type.</p>
</div>
<div class="paragraph">
<p>Condition types are similar to record types but are more flexible in that a condition object may be an instance of two or more condition types, even if neither is a subtype of the other. When a condition is an instance of multiple types, it is referred to as a <em>compound condition</em>. Compound conditions are useful for communicating multiple pieces of information about an exception to the exception handler. A condition that is not a compound condition is referred to as a <em>simple condition</em>. In most cases, the distinction between the two is unimportant, and a simple condition is treated as if it were a compound condition with itself as its only simple condition.</p>
</div>
<div id="exceptions:s13" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;condition</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>&amp;condition</code> is a record-type name (<a href="#chp_records">Chapter 9</a>) and the root of the condition-type hierarchy. All simple condition types are extensions of this type, and all conditions, whether simple or compound, are considered instances of this type.</p>
</div>
<div id="exceptions:s14" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(condition? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition object, otherwise <code>#f</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A condition object is an instance of a subtype of <code>&amp;condition</code> or a compound condition, possibly created by user code with <code>condition</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(condition? 'stable) ⇒ #f
(condition? (make-error)) ⇒ #t
(condition? (make-message-condition "oops")) ⇒ #t
(condition?
  (condition
    (make-error)
    (make-message-condition "no such element"))) ⇒ #t</code></pre>
</div>
</div>
<div id="exceptions:s15" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(condition <em>condition</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition, possibly compound</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>condition</code> is used to create condition objects that may consist of multiple simple conditions. Each argument <code><em>condition</em></code> may be simple or complex; if simple, it is treated as a compound condition with itself as its only simple condition. The simple conditions of the result condition are the simple conditions of the <code><em>condition</em></code> arguments, flattened into a single list and appearing in order, with the simple conditions of the first <code><em>condition</em></code> followed by the simple conditions of the second, and so on.</p>
</div>
<div class="paragraph">
<p>If the list has exactly one element, the result condition may be simple or compound; otherwise it is compound. The distinction between simple and compound conditions is not usually important but can be detected, if <code>define-record-type</code> rather than <code>define-condition-type</code> is used to extend an existing condition type, via the predicate defined by <code>define-record-type</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(condition) ⇒ #&lt;condition&gt;
(condition
  (make-error)
  (make-message-condition "oops")) ⇒ #&lt;condition&gt;

(define-record-type (&xcond make-xcond xcond?) (parent &condition))
(xcond? (make-xcond)) ⇒ #t
(xcond? (condition (make-xcond))) ⇒ #t <em>or</em> #f
(xcond? (condition)) ⇒ #f
(xcond? (condition (make-error) (make-xcond))) ⇒ #f</code></pre>
</div>
</div>
<div id="exceptions:s16" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(simple-conditions <em>condition</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a list of the simple conditions of <code><em>condition</em></code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(simple-conditions (condition)) ⇒ '()
(simple-conditions (make-error)) ⇒ (#&lt;condition &error&gt;)
(simple-conditions (condition (make-error))) ⇒ (#&lt;condition &error&gt;)
(simple-conditions
  (condition
    (make-error)
    (make-message-condition
      "oops"))) ⇒ (#&lt;condition &error&gt; #&lt;condition &message&gt;)

(let ([c1 (make-error)]
      [c2 (make-who-condition "f")]
      [c3 (make-message-condition "invalid argument")]
      [c4 (make-message-condition
            "error occurred while reading from file")]
      [c5 (make-irritants-condition '("a.ss"))])
  (equal?
    (simple-conditions
      (condition
        (condition (condition c1 c2) c3)
        (condition c4 (condition c5))))
    (list c1 c2 c3 c4 c5))) ⇒ #t</code></pre>
</div>
</div>
<div id="exceptions:s17" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>(define-condition-type <em>name</em> <em>parent</em> <em>constructor</em> <em>pred</em> <em>field</em> ...)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A <code>define-condition-type</code> form is a definition and may appear anywhere other definitions may appear. It is used to define new simple condition types.</p>
</div>
<div class="paragraph">
<p>The subforms <code><em>name</em></code>, <code><em>parent</em></code>, <code><em>constructor</em></code>, and <code><em>pred</em></code> must be identifiers. Each <code><em>field</em></code> must be of the form <code>(<em>field-name</em> <em>accessor-name</em>)</code>, where <code><em>field-name</em></code> and <code><em>accessor-name</em></code> are identifiers.</p>
</div>
<div class="paragraph">
<p><code>define-condition-type</code> defines <code><em>name</em></code> as a new record type whose parent record type is <code><em>parent</em></code>, whose constructor name is <code><em>constructor</em></code>, whose predicate name is <code><em>pred</em></code>, whose fields are <code><em>field-name</em> ...</code>, and whose field accessors are named by <code><em>accessor-name</em> ...</code>.</p>
</div>
<div class="paragraph">
<p>With the exception of the predicate and field accessors, <code>define-condition-type</code> is essentially an ordinary record definition equivalent to</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type (<em>name</em> <em>constructor</em> <em>pred</em>)
  (parent <em>parent</em>)
  (fields ((immutable <em>field-name</em> <em>accessor-name</em>) ...)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The predicate differs from one that would be generated by a <code>define-record-type</code> form in that it returns <code>#t</code> not only for an instance of the new type but also for compound conditions whose simple conditions include an instance of the new type. Similarly, field accessors accept instances of the new type as well as compound conditions whose simple conditions include at least one instance of the new record type. If an accessor receives a compound condition whose simple conditions list includes one or more instances of the new type, the accessor operates on the first instance in the list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &mistake &condition make-mistake mistake?
  (type mistake-type))

(mistake? 'booboo) ⇒ #f

(define c1 (make-mistake 'spelling))
(mistake? c1) ⇒ #t
(mistake-type c1) ⇒ spelling

(define c2 (condition c1 (make-irritants-condition '(eggregius))))
(mistake? c2) ⇒ #t
(mistake-type c2) ⇒ spelling
(irritants-condition? c2) ⇒ #t
(condition-irritants c2) ⇒ (eggregius)</code></pre>
</div>
</div>
<div id="exceptions:s18" class="hdlist">
<table>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(condition-predicate <em>rtd</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition predicate</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(condition-accessor <em>rtd</em> <em>procedure</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition accessor</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>These procedures may be used to create the same kind of special predicates and accessors that are created by <code>define-record-type</code> from a record-type descriptor, <code><em>rtd</em></code>, of a simple condition type or other type derived from a simple condition type.</p>
</div>
<div class="paragraph">
<p>For both procedures, <code><em>rtd</em></code> must be a record-type descriptor of a subtype of <code>&amp;condition</code>, and for <code>condition-accessor</code>, <code><em>procedure</em></code> should accept one argument.</p>
</div>
<div class="paragraph">
<p>The predicate returned by <code>condition-predicate</code> accepts one argument, which may be any Scheme value. The predicate returns <code>#t</code> if the value is a condition of the type described by <code><em>rtd</em></code>, i.e., an instance of the type described by <code><em>rtd</em></code> (or one of its subtypes) or a compound condition whose simple conditions include an instance of the type described by <code><em>rtd</em></code>. Otherwise, the predicate returns <code>#f</code>.</p>
</div>
<div class="paragraph">
<p>The accessor returned by <code>condition-accessor</code> accepts one argument, <code><em>c</em></code>, which must be a condition of the type described by <code><em>rtd</em></code>. The accessor applies <code><em>procedure</em></code> to a single argument, the first element of <code><em>c</em></code>'s simple condition list that is an instance of the type described by <code><em>rtd</em></code> (this is <code><em>c</em></code> itself if <code><em>c</em></code> is a simple condition), and returns the result of this application. In most situations, <code><em>procedure</em></code> is a record accessor for a field of the type described by <code><em>rtd</em></code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-record-type (&mistake make-mistake $mistake?)
  (parent &condition)
  (fields (immutable type $mistake-type)))

; define predicate and accessor as if we'd used define-condition-type
(define rtd (record-type-descriptor &mistake))
(define mistake? (condition-predicate rtd))
(define mistake-type (condition-accessor rtd $mistake-type))

(define c1 (make-mistake 'spelling))
(define c2 (condition c1 (make-irritants-condition '(eggregius))))
(list (mistake? c1) (mistake? c2)) ⇒ (#t #t)
(list ($mistake? c1) ($mistake? c2)) ⇒ (#t #f)
(mistake-type c1) ⇒ spelling
($mistake-type c1) ⇒ spelling
(mistake-type c2) ⇒ spelling
($mistake-type c2) ⇒ <em>violation</em></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_11.3.">Section 11.3. Standard Condition Types</h3>
<div id="exceptions:s19" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;serious</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-serious-condition)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;serious</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(serious-condition? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;serious</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Conditions of this type indicate situations of a serious nature that, if uncaught, generally result in termination of the program&#8217;s execution. Conditions of this type typically occur as one of the more specific subtypes <code>&amp;error</code> or <code>&amp;violation</code>. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &serious &condition
  make-serious-condition serious-condition?)</code></pre>
</div>
</div>
<div id="exceptions:s20" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;violation</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-violation)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;violation</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(violation? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;violation</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Conditions of this type indicate that the program has violated some requirement, usually due to a bug in the program. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &violation &serious
  make-violation violation?)</code></pre>
</div>
</div>
<div id="exceptions:s21" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;assertion</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-assertion-violation)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;assertion</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(assertion-violation? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;assertion</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This condition type indicates a specific violation in which the program has passed the wrong number or types of arguments to a procedure. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &assertion &violation
  make-assertion-violation assertion-violation?)</code></pre>
</div>
</div>
<div id="exceptions:s22" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;error</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-error)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;error</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(error? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;error</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Conditions of this type indicate that an error has occurred with the program&#8217;s interaction with its operating environment, such as the failure of an attempt to open a file. It is not used to describe situations in which an error in the program has been detected. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &error &serious
  make-error error?)</code></pre>
</div>
</div>
<div id="exceptions:s23" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;warning</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-warning)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;warning</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(warning? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;warning</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Warning conditions indicate situations that do not prevent the program from continuing its execution but, in some cases, might result in a more serious problem at some later point. For example, a compiler might use a condition of this type to indicate that it has processed a call to a standard procedure with the wrong number of arguments; this will not become a serious problem unless the call is actually evaluated at some later point. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &warning &condition
  make-warning warning?)</code></pre>
</div>
</div>
<div id="exceptions:s24" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;message</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-message-condition <em>message</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;message</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(message-condition? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;message</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(condition-message <em>condition</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the contents of <code><em>condition</em></code>'s <code>message</code> field</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Conditions of this type are usually included with a <code>&amp;warning</code> condition or one of the <code>&amp;serious</code> condition subtypes to provide a more specific description of the exceptional situation. The <code><em>message</em></code> argument to the constructor may be any Scheme value but is typically a string. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &message &condition
  make-message-condition message-condition?
  (message condition-message))</code></pre>
</div>
</div>
<div id="exceptions:s25" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;irritants</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-irritants-condition <em>irritants</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;irritants</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(irritants-condition? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;irritants</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(condition-irritants <em>condition</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the contents of <code><em>condition</em></code>'s <code>irritants</code> field</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Conditions of this type are usually included with a <code>&amp;message</code> condition to provide information about Scheme values that may have caused or been materially involved in the exceptional situation. For example, if a procedure receives the wrong type of argument, it may raise an exception with a compound condition consisting of an assertion condition, a who condition naming the procedure, a message condition stating that the wrong type of argument was received, and an irritants condition listing the argument. The <code><em>irritants</em></code> argument to the constructor should be a list. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &irritants &condition
  make-irritants-condition irritants-condition?
  (irritants condition-irritants))</code></pre>
</div>
</div>
<div id="exceptions:s26" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;who</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-who-condition <em>who</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;who</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(who-condition? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;who</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(condition-who <em>condition</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the contents of <code><em>condition</em></code>'s <code>who</code> field</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Conditions of this type are often included with a <code>&amp;message</code> condition to identify the syntactic form or procedure that detected the error. The <code><em>who</em></code> argument to the constructor should be a symbol or string. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &who &condition
  make-who-condition who-condition?
  (who condition-who))</code></pre>
</div>
</div>
<div id="exceptions:s27" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;non-continuable</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-non-continuable-violation)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;non-continuable</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(non-continuable-violation? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;non-continuable</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Conditions of this type indicate that a non-continuable violation has occurred. <code>raise</code> raises an exception with this type if the current exception handler returns. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &non-continuable &violation
  make-non-continuable-violation
  non-continuable-violation?)</code></pre>
</div>
</div>
<div id="exceptions:s28" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;implementation-restriction</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-implementation-restriction-violation)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;implementation-restriction</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(implementation-restriction-violation? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;implementation-restriction</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An implementation-restriction condition indicates that the program has attempted to exceed some limitation in the implementation, such as when the value of a fixnum addition operation would result in a number that exceeds the implementation&#8217;s fixnum range. It does not normally indicate a deficiency in the implementation but rather a mismatch between what the program is attempting to do and what the implementation can support. In many cases, implementation restrictions are dictated by the underlying hardware. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &implementation-restriction &violation
  make-implementation-restriction-violation
  implementation-restriction-violation?)</code></pre>
</div>
</div>
<div id="exceptions:s29" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;lexical</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-lexical-violation)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;lexical</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(lexical-violation? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;lexical</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Conditions of this type indicate that a lexical error has occurred in the parsing of a Scheme program or datum, such as mismatched parentheses or an invalid character appearing within a numeric constant. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &lexical &violation
  make-lexical-violation lexical-violation?)</code></pre>
</div>
</div>
<div id="exceptions:s30" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;syntax</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-syntax-violation <em>form</em> <em>subform</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;syntax</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(syntax-violation? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;syntax</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(syntax-violation-form <em>condition</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the contents of <code><em>condition</em></code>'s <code>form</code> field</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(syntax-violation-subform <em>condition</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the contents of <code><em>condition</em></code>'s <code>subform</code> field</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Conditions of this type indicate that a syntax error has occurred in the parsing of a Scheme program. In most implementations, syntax errors are detected by the macro expander. Each of the <code><em>form</em></code> and <code><em>subform</em></code> arguments to <code>make-syntax-violation</code> should be a syntax object (<a href="#section_8.3.">Section 8.3</a>) or datum, the former indicating the containing form and the latter indicating the specific subform. For example, if a duplicate formal parameter is found in a <code>lambda</code> expression, <code><em>form</em></code> might be the <code>lambda</code> expression and <code><em>subform</em></code> might be the duplicated parameter. If there is no need to identify a subform, <code><em>subform</em></code> should be <code>#f</code>. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &syntax &violation
  make-syntax-violation syntax-violation?
  (form syntax-violation-form)
  (subform syntax-violation-subform))</code></pre>
</div>
</div>
<div id="exceptions:s31" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;undefined</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-undefined-violation)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;undefined</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(undefined-violation? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;undefined</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs conditions)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An undefined condition indicates an attempt to reference an unbound variable. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &undefined &violation
  make-undefined-violation undefined-violation?)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The next several condition types describe conditions that occur when input or output operations fail in some manner.</p>
</div>
<div id="exceptions:s32" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;i/o</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-i/o-error)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;i/o</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-error? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;i/o</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs files)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A condition of type <code>&amp;i/o</code> indicates that an input/output error of some sort has occurred. Conditions of this type typically occur as one of the more specific subtypes described below. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &i/o &error
  make-i/o-error i/o-error?)</code></pre>
</div>
</div>
<div id="exceptions:s33" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;i/o-read</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-i/o-read-error)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;i/o-read</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-read-error? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;i/o-read</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs files)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This condition type indicates that an error has occurred while reading from a port. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &i/o-read &i/o
  make-i/o-read-error i/o-read-error?)</code></pre>
</div>
</div>
<div id="exceptions:s34" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;i/o-write</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-i/o-write-error)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;i/o-write</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-write-error? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;i/o-write</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs files)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This condition type indicates that an error has occurred while writing to a port. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &i/o-write &i/o
  make-i/o-write-error i/o-write-error?)</code></pre>
</div>
</div>
<div id="exceptions:s35" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;i/o-invalid-position</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-i/o-invalid-position-error <em>position</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;i/o-invalid-position</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-invalid-position-error? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;i/o-invalid-position</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-error-position <em>condition</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the contents of <code><em>condition</em></code>'s <code>position</code> field</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs files)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This condition type indicates an attempt to set a port&#8217;s position to a position that is out of range for the underlying file or other object. The <code><em>position</em></code> argument to the constructor should be the invalid position. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &i/o-invalid-position &i/o
  make-i/o-invalid-position-error
  i/o-invalid-position-error?
  (position i/o-error-position))</code></pre>
</div>
</div>
<div id="exceptions:s36" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;i/o-filename</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-i/o-filename-error <em>filename</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;i/o-filename</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-filename-error? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;i/o-filename</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-error-filename <em>condition</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the contents of <code><em>condition</em></code>'s <code>filename</code> field</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs files)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This condition type indicates an input/output error that occurred while operating on a file. The <code><em>filename</em></code> argument to the constructor should be the name of the file. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &i/o-filename &i/o
  make-i/o-filename-error i/o-filename-error?
  (filename i/o-error-filename))</code></pre>
</div>
</div>
<div id="exceptions:s37" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;i/o-file-protection</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-i/o-file-protection-error <em>filename</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;i/o-file-protection</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-file-protection-error? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;i/o-file-protection</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs files)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A condition of this type indicates that an attempt has been made to perform some input/output operation on a file for which the program does not have the proper permission. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &i/o-file-protection &i/o-filename
  make-i/o-file-protection-error
  i/o-file-protection-error?)</code></pre>
</div>
</div>
<div id="exceptions:s38" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;i/o-file-is-read-only</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-i/o-file-is-read-only-error <em>filename</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;i/o-file-is-read-only</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-file-is-read-only-error? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;i/o-file-is-read-only</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs files)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A condition of this type indicates an attempt to treat as writeable a read-only file. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &i/o-file-is-read-only &i/o-file-protection
  make-i/o-file-is-read-only-error
  i/o-file-is-read-only-error?)</code></pre>
</div>
</div>
<div id="exceptions:s39" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;i/o-file-already-exists</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-i/o-file-already-exists-error <em>filename</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;i/o-file-already-exists</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-file-already-exists-error? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;i/o-file-already-exists</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs files)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A condition of this type indicates a situation in which an operation on a file failed because the file already exists, e.g., an attempt is made to open an existing file for output without the <code>no-fail</code> file option. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &i/o-file-already-exists &i/o-filename
  make-i/o-file-already-exists-error
  i/o-file-already-exists-error?)</code></pre>
</div>
</div>
<div id="exceptions:s40" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;i/o-file-does-not-exist</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-i/o-file-does-not-exist-error <em>filename</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;i/o-file-does-not-exist</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-file-does-not-exist-error? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;i/o-file-does-not-exist</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs files)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A condition of this type indicates a situation in which an operation on a file failed because the file does not exist, e.g., an attempt is made to open a nonexistent file for input only. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &i/o-file-does-not-exist &i/o-filename
  make-i/o-file-does-not-exist-error
  i/o-file-does-not-exist-error?)</code></pre>
</div>
</div>
<div id="exceptions:s41" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;i/o-port</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-i/o-port-error <em>pobj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;i/o-port</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-port-error? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;i/o-port</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-error-port <em>condition</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the contents of <code><em>condition</em></code>'s <code>pobj</code> field</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs io simple)</code>, <code>(rnrs files)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A condition of this type is usually included with a condition of one of the other <code>&amp;i/o</code> subtypes to indicate the port involved in the exceptional situation, if a port is involved. The <code><em>pobj</em></code> argument to the constructor should be the port. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &i/o-port &i/o
  make-i/o-port-error i/o-port-error?
  (pobj i/o-error-port))</code></pre>
</div>
</div>
<div id="exceptions:s42" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;i/o-decoding</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-i/o-decoding-error <em>pobj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;i/o-decoding</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-decoding-error? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;i/o-decoding</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A condition of this type indicates that a decoding error has occurred during the transcoding of bytes to characters. The <code><em>pobj</em></code> argument to the constructor should be the port involved, if any. The port should be positioned past the invalid encoding. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &i/o-decoding &i/o-port
  make-i/o-decoding-error i/o-decoding-error?)</code></pre>
</div>
</div>
<div id="exceptions:s43" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;i/o-encoding</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-i/o-encoding-error <em>pobj</em> <em>cobj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;i/o-encoding</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-encoding-error? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;i/o-encoding</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(i/o-encoding-error-char <em>condition</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>the contents of <code><em>condition</em></code>'s <code>cobj</code> field</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs io ports)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A condition of this type indicates that an encoding error has occurred during the transcoding of characters to bytes. The <code><em>pobj</em></code> argument to the constructor should be the port involved, if any, and the <code><em>cobj</em></code> argument should be the character for which the encoding failed. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &i/o-encoding &i/o-port
  make-i/o-encoding-error i/o-encoding-error?
  (cobj i/o-encoding-error-char))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The final two condition types describe conditions that occur when implementations are required to produce a NaN or infinity but have no representations for these values.</p>
</div>
<div id="exceptions:s44" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;no-infinities</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-no-infinities-violation)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;no-infinities</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(no-infinities-violation? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;no-infinities</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This condition indicates that the implementation has no representation for infinity. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &no-infinities &implementation-restriction
  make-no-infinities-violation
  no-infinities-violation?)</code></pre>
</div>
</div>
<div id="exceptions:s45" class="hdlist">
<table>
<tr>
<td class="hdlist1">
syntax
</td>
<td class="hdlist2">
<p><code>&amp;no-nans</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(make-no-nans-violation)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p>a condition of type <code>&amp;no-nans</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
procedure
</td>
<td class="hdlist2">
<p><code>(no-nans-violation? <em>obj</em>)</code></p>
</td>
</tr>
<tr>
<td class="hdlist1">
returns
</td>
<td class="hdlist2">
<p><code>#t</code> if <code><em>obj</em></code> is a condition of type <code>&amp;no-nans</code>, <code>#f</code> otherwise</p>
</td>
</tr>
<tr>
<td class="hdlist1">
libraries
</td>
<td class="hdlist2">
<p><code>(rnrs arithmetic flonums)</code>, <code>(rnrs)</code></p>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This condition indicates that the implementation has no representation for NaN. This condition type might be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-condition-type &no-nans &implementation-restriction
  make-no-nans-violation no-nans-violation?)</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="chp_extended_examples">Chapter 12. Extended Examples</h2>
<div class="sectionbody">
<div class="imageblock">
<div class="content">
<img src="images/ch12.png" alt="ch12">
</div>
</div>
<div class="paragraph">
<p>This chapter presents a series of programs that perform more complicated tasks than most of the examples found throughout the earlier chapters of the book. They illustrate a variety of programming techniques and demonstrate a particular programming style.</p>
</div>
<div class="paragraph">
<p>Each section of this chapter describes one program in detail and gives examples of its use. This is followed by a listing of the code. At the end of each section are exercises intended to stimulate thought about the program and to suggest possible extensions. These exercises are generally more difficult than those found in Chapters <a href="#chp_getting_started">2</a> and <a href="#chp_going_further">3</a>, and a few are major projects.</p>
</div>
<div class="paragraph">
<p><a href="#section_12.1.">Section 12.1</a> presents a simple matrix multiplication package. It demonstrates a set of procedures that could be written in almost any language. Its most interesting features are that all multiplication operations are performed by calling a single <em>generic</em> procedure, <code>mul</code>, which calls the appropriate help procedure depending upon the dimensions of its arguments, and that it dynamically allocates results of the proper size. <a href="#section_12.2.">Section 12.2</a> presents a merge sorting algorithm for ordering lists according to arbitrary predicates. <a href="#section_12.3.">Section 12.3</a> describes a syntactic form that is used to construct sets. It demonstrates a simple but efficient syntactic transformation from set notation to Scheme code. <a href="#section_12.4.">Section 12.4</a> presents a word-counting program borrowed from <em>The C Programming Language</em> <a href="#ref19">[19]</a>, translated from C into Scheme. It shows character and string manipulation, data structure creation and manipulation, and basic file input and output. <a href="#section_12.5.">Section 12.5</a> presents a Scheme printer that implements basic versions of <code>put-datum</code>, <code>write</code>, and <code>display</code>. <a href="#section_12.6.">Section 12.6</a> presents a simple formatted output facility similar to those found in many Scheme systems and in other languages. <a href="#section_12.7.">Section 12.7</a> presents a simple interpreter for Scheme that illustrates Scheme as a language implementation vehicle while giving an informal operational semantics for Scheme as well as a useful basis for investigating extensions to Scheme. <a href="#section_12.8.">Section 12.8</a> presents a small, extensible abstract object facility that could serve as the basis for an entire object-oriented subsystem. <a href="#section_12.9.">Section 12.9</a> presents a recursive algorithm for computing the Fourier transform of a sequence of input values. It highlights the use of Scheme&#8217;s complex arithmetic. <a href="#section_12.10.">Section 12.10</a> presents a concise unification algorithm that shows how procedures can be used as continuations and as substitutions (unifiers) in Scheme. <a href="#section_12.11.">Section 12.11</a> describes a multitasking facility and its implementation in terms of continuations.</p>
</div>
<div class="sect2">
<h3 id="section_12.1.">Section 12.1. Matrix and Vector Multiplication</h3>
<div class="paragraph">
<p>This example program involves mostly basic programming techniques. It demonstrates simple arithmetic and vector operations, looping with the <code>do</code> syntactic form, dispatching based on object type, and raising exceptions.</p>
</div>
<div class="paragraph">
<p>Multiplication of scalar to scalar, scalar to matrix, or matrix to matrix is performed by a single <em>generic</em> procedure, called <code>mul</code>. <code>mul</code> is called with two arguments, and it decides based on the types of its arguments what operation to perform. Because scalar operations use Scheme&#8217;s multiplication procedure, <code>*</code>, <code>mul</code> scalars can be any built-in numeric type (exact or inexact complex, real, rational, or integer).</p>
</div>
<div class="paragraph">
<p>The product of an \(m \times n\) matrix \(A\) and an \(n \times p\) matrix \(B\) is the \(m \times p\) matrix \(C\) whose entries are defined by</p>
</div>
<div class="stemblock">
<div class="content">
\[C_{ij} = \sum_{k=0}^{n-1}A_{ik}B_{kj}\]
</div>
</div>
<div class="paragraph">
<p>The product of a scalar \(x\) and an \(m \times n\) matrix \(A\) is the \(m \times n\) matrix \(C\) whose entries are defined by the equation</p>
</div>
<div class="stemblock">
<div class="content">
\[C_{ij} = xA_{ij}\]
</div>
</div>
<div class="paragraph">
<p>That is, each element of \(C\) is the product of \(x\) and the corresponding element of \(A\). Vector-vector, vector-matrix, and matrix-vector multiplication may be considered special cases of matrix-matrix multiplication, where a vector is represented as a \(1 \times n\) or \(n \times 1\) matrix.</p>
</div>
<div class="paragraph">
<p>Here are a few examples, each preceded by the equivalent operation in standard mathematical notation.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Scalar times scalar:<br></p>
<div class="stemblock">
<div class="content">
\[3 \times 4 = 12\]
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(mul 3 4) ⇒ 12</code></pre>
</div>
</div>
</li>
<li>
<p>Scalar times vector (\(1 \times 3\) matrix):<br></p>
<div class="stemblock">
<div class="content">
\[1/2 \times \begin{pmatrix}
1 &amp; 2 &amp; 3 \\
\end{pmatrix} = \begin{pmatrix}
1/2 &amp; 1 &amp; 3/2 \\
\end{pmatrix}\]
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(mul 1/2 '#(#(1 2 3))) ⇒ #(#(1/2 1 3/2))</code></pre>
</div>
</div>
</li>
<li>
<p>Scalar times matrix:<br></p>
<div class="stemblock">
<div class="content">
\[-2 \times \begin{pmatrix}
3 &amp; -2 &amp; -1 \\
-3 &amp; 0 &amp; -5 \\
7 &amp; -1 &amp; -1 \\
\end{pmatrix} = \begin{pmatrix}
-6 &amp; 4 &amp; 2 \\
6 &amp; 0 &amp; 10 \\
-14 &amp; 2 &amp; 2 \\
\end{pmatrix}\]
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(mul -2
     '#(#(3 -2 -1)
        #(-3 0 -5)
        #(7 -1 -1))) ⇒ #(#(-6 4 2)
                          #(6 0 10)
                          #(-14 2 2))</code></pre>
</div>
</div>
</li>
<li>
<p>Vector times matrix:<br></p>
<div class="stemblock">
<div class="content">
\[\begin{pmatrix}
1 &amp; 2 &amp; 3 \\
\end{pmatrix} \times \begin{pmatrix}
2 &amp; 3 \\
3 &amp; 4 \\
4 &amp; 5 \\
\end{pmatrix} = \begin{pmatrix}
20 &amp; 26 \\
\end{pmatrix}\]
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(mul '#(#(1 2 3))
     '#(#(2 3)
        #(3 4)
        #(4 5))) ⇒ #(#(20 26))</code></pre>
</div>
</div>
</li>
<li>
<p>Matrix times vector:<br></p>
<div class="stemblock">
<div class="content">
\[\begin{pmatrix}
2 &amp; 3 &amp; 4 \\
3 &amp; 4 &amp; 5 \\
\end{pmatrix} \times \begin{pmatrix}
1 \\
2 \\
3 \\
\end{pmatrix} = \begin{pmatrix}
20 \\
26 \\
\end{pmatrix}\]
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(mul '#(#(2 3 4)
        #(3 4 5))
     '#(#(1) #(2) #(3))) ⇒ #(#(20) #(26))</code></pre>
</div>
</div>
</li>
<li>
<p>Matrix times matrix:<br></p>
<div class="stemblock">
<div class="content">
\[\begin{pmatrix}
1 &amp; 2 &amp; 3 \\
4 &amp; 5 &amp; 6 \\
\end{pmatrix} \times \begin{pmatrix}
1 &amp; 2 &amp; 3 &amp; 4 \\
2 &amp; 3 &amp; 4 &amp; 5 \\
3 &amp; 4 &amp; 5 &amp; 6 \\
\end{pmatrix} = \begin{pmatrix}
14 &amp; 20 &amp; 26 &amp; 32 \\
32 &amp; 47 &amp; 62 &amp; 77 \\
\end{pmatrix}\]
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(mul '#(#(1 2 3)
        #(4 5 6))
     '#(#(1 2 3 4)
        #(2 3 4 5)
        #(3 4 5 6))) ⇒ #(#(14 20 26 32)
                          #(32 47 62 77))</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The code for <code>mul</code> and its helpers, which is structured as a library, appears below. The first few definitions establish a set of procedures that support the matrix data type. A matrix is a vector of vectors. Included are a procedure to create matrices, procedures to access and assign matrix elements, and a matrix predicate. Following these definitions is the definition of <code>mul</code> itself. Inside the <code>lambda</code> expression for <code>mul</code> are a set of definitions for help procedures that support <code>mul</code>.</p>
</div>
<div class="paragraph">
<p><code>mul</code> checks the types of its arguments and chooses the appropriate help procedure to do the work. Each helper operates on arguments of specific types. For example, <code>mat-sca-mul</code> multiplies a matrix by a scalar. If the type of either argument is invalid or the arguments are incompatible, e.g., rows or columns do not match up, <code>mul</code> or one of its helpers raises an exception.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (tspl matrix)
  (export make-matrix matrix? matrix-rows matrix-columns
          matrix-ref matrix-set! mul)
  (import (rnrs))

 ; make-matrix creates a matrix (a vector of vectors).
  (define make-matrix
    (lambda (rows columns)
      (do ([m (make-vector rows)]
           [i 0 (+ i 1)])
          ((= i rows) m)
        (vector-set! m i (make-vector columns)))))

 ; matrix? checks to see if its argument is a matrix.
 ; It isn't foolproof, but it's generally good enough.
  (define matrix?
    (lambda (x)
      (and (vector? x)
           (> (vector-length x) 0)
           (vector? (vector-ref x 0)))))

 ; matrix-rows returns the number of rows in a matrix.
  (define matrix-rows
    (lambda (x)
      (vector-length x)))

 ; matrix-columns returns the number of columns in a matrix.
  (define matrix-columns
    (lambda (x)
      (vector-length (vector-ref x 0))))

 ; matrix-ref returns the jth element of the ith row.
  (define matrix-ref
    (lambda (m i j)
      (vector-ref (vector-ref m i) j)))

 ; matrix-set! changes the jth element of the ith row.
  (define matrix-set!
    (lambda (m i j x)
      (vector-set! (vector-ref m i) j x)))

 ; mat-sca-mul multiplies a matrix by a scalar.
  (define mat-sca-mul
    (lambda (m x)
      (let* ([nr (matrix-rows m)]
             [nc (matrix-columns m)]
             [r (make-matrix nr nc)])
        (do ([i 0 (+ i 1)])
            ((= i nr) r)
          (do ([j 0 (+ j 1)])
              ((= j nc))
            (matrix-set! r i j (* x (matrix-ref m i j))))))))

 ; mat-mat-mul multiplies one matrix by another, after verifying
 ; that the first matrix has as many columns as the second
 ; matrix has rows.
  (define mat-mat-mul
    (lambda (m1 m2)
      (let* ([nr1 (matrix-rows m1)]
             [nr2 (matrix-rows m2)]
             [nc2 (matrix-columns m2)]
             [r (make-matrix nr1 nc2)])
        (unless (= (matrix-columns m1) nr2) (match-error m1 m2))
        (do ([i 0 (+ i 1)])
            ((= i nr1) r)
          (do ([j 0 (+ j 1)])
              ((= j nc2))
            (do ([k 0 (+ k 1)]
                 [a 0 (+ a
                         (* (matrix-ref m1 i k)
                            (matrix-ref m2 k j)))])
                ((= k nr2)
                 (matrix-set! r i j a))))))))

 ; type-error is called to complain when mul receives an invalid
 ; type of argument.
  (define type-error
    (lambda (what)
      (assertion-violation 'mul
        "not a number or matrix"
         what)))

 ; match-error is called to complain when mul receives a pair of
 ; incompatible arguments.
  (define match-error
    (lambda (what1 what2)
      (assertion-violation 'mul
        "incompatible operands" what1
        what2)))

 ; mul is the generic matrix/scalar multiplication procedure
  (define mul
    (lambda (x y)
      (cond
        [(number? x)
         (cond
           [(number? y) (* x y)]
           [(matrix? y) (mat-sca-mul y x)]
           [else (type-error y)])]
        [(matrix? x)
         (cond
           [(number? y) (mat-sca-mul x y)]
           [(matrix? y) (mat-mat-mul x y)]
           [else (type-error y)])]
        [else (type-error x)]))))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.1.1">Exercise 12.1.1</h4>
<div class="paragraph">
<p>Make the necessary changes to rename <code>mul</code> to <code>*</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.1.2">Exercise 12.1.2</h4>
<div class="paragraph">
<p>The predicate <code>matrix?</code> is usually sufficient but not completely reliable, since it may return <code>#t</code> for objects that are not matrices. In particular, it does not verify that all of the matrix rows are vectors, that each row has the same number of elements, or that the elements themselves are numbers. Modify <code>matrix?</code> to perform each of these additional checks.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.1.3">Exercise 12.1.3</h4>
<div class="paragraph">
<p>Another solution to <a href="#exercise_12.1.2">Exercise 12.1.2</a> is to define a matrix record type encapsulating the vectors of the matrix. If the matrix creation routine never allows a malformed matrix record to be created, a matrix record check is the only check needed to ensure that the input is well formed. Define a matrix record type and recode the library to use it.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.1.4">Exercise 12.1.4</h4>
<div class="paragraph">
<p>Write similar generic procedures for addition and subtraction. Devise a generic <code>dispatch</code> procedure or syntactic form so that the type dispatching code need not be rewritten for each new operation.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.1.5">Exercise 12.1.5</h4>
<div class="paragraph">
<p>This version of <code>mul</code> uses vectors of vectors to represent matrices. Rewrite the system, using nested lists to represent matrices. What efficiency is gained or lost by this change?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_12.2.">Section 12.2. Sorting</h3>
<div class="paragraph">
<p>This section illustrates a list sorting algorithm based on a simple technique known as merge sorting. The procedure <code>sort</code> defined here accepts two arguments: a predicate and a list, just like the built-in <code>list-sort</code>. It returns a list containing the elements of the old list sorted according to the predicate. As with <code>list-sort</code>, the predicate should be a procedure that expects two arguments and returns <code>#t</code> if its first argument must precede its second in the sorted list and false otherwise. That is, if the predicate is applied to two elements <code><em>x</em></code> and <code><em>y</em></code>, where <code><em>x</em></code> appears after <code><em>y</em></code> in the input list, it should return true only if <code><em>x</em></code> should appear before <code><em>y</em></code> in the output list. If this constraint is met, <code>sort</code> will perform a <em>stable sort</em>; with a stable sort, two elements that are already sorted with respect to each other will appear in the output in the same order in which they appeared in the input. Thus, sorting a list that is already sorted will result in no reordering, even if there are equivalent elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(sort < '(3 4 2 1 2 5)) ⇒ (1 2 2 3 4 5)
(sort > '(0.5 1/2)) ⇒ (0.5 1/2)
(sort > '(1/2 0.5)) ⇒ (1/2 0.5)
(list->string
  (sort char>?
        (string->list "coins"))) ⇒ "sonic"</code></pre>
</div>
</div>
<div class="paragraph">
<p>A companion procedure, <code>merge</code>, is also defined by the code. <code>merge</code> accepts a predicate and two sorted lists and returns a merged list in sorted order of the elements of the two lists. With a properly defined predicate, <code>merge</code> is also stable in the sense that an item from the first list will appear before an item from the second list unless it is necessary that the item from the second list appear first.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(merge char&lt;?
       '(#\a #\c)
       '(#\b #\c #\d)) ⇒ (#\a #\b #\c #\c #\d)
(merge <
       '(1/2 2/3 3/4)
       '(0.5 0.6 0.7)) ⇒ (1/2 0.5 0.6 2/3 0.7 3/4)
(list->string
  (merge char>?
    (string->list "old")
    (string->list "toe"))) ⇒ "tooled"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The merge sorting algorithm is simple and elegant. The input list is split into two approximately equal sublists. These sublists are sorted recursively, yielding two sorted lists. The sorted lists are then merged to form a single sorted list. The base case for the recursion is a list of one element, which is already sorted.</p>
</div>
<div class="paragraph">
<p>To reduce overhead, the implementation computes the length of the input list once, in <code>sort</code>, rather than at each step of the recursion, in <code>dosort</code>. This also allows <code>dosort</code> to isolate the first half of the list merely by halving the length, saving the cost of allocating a new list containing half of the elements. As a result, <code>ls</code> may contain more than <code>n</code> elements, but only the first <code>n</code> elements are considered part of the list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (tspl sort)
  (export sort merge)
  (import (rnrs))

  (define dosort
    (lambda (pred? ls n)
      (if (= n 1)
          (list (car ls))
          (let ([i (div n 2)])
            (domerge pred?
              (dosort pred? ls i)
              (dosort pred? (list-tail ls i) (- n i)))))))

  (define domerge
    (lambda (pred? l1 l2)
      (cond
        [(null? l1) l2]
        [(null? l2) l1]
        [(pred? (car l2) (car l1))
         (cons (car l2) (domerge pred? l1 (cdr l2)))]
        [else (cons (car l1) (domerge pred? (cdr l1) l2))])))

  (define sort
    (lambda (pred? l)
      (if (null? l) l (dosort pred? l (length l)))))

  (define merge
    (lambda (pred? l1 l2)
      (domerge pred? l1 l2))))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.2.1">Exercise 12.2.1</h4>
<div class="paragraph">
<p>In <code>dosort</code>, when <code>n</code> is 1, why is <code>(list (car ls))</code> returned instead of just <code>ls</code>? How much allocation would be saved overall by replacing <code>(list (car ls))</code> with <code>(if (null? (cdr ls)) ls (list (car ls)))</code>?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.2.2">Exercise 12.2.2</h4>
<div class="paragraph">
<p>How much work is actually saved by not copying the first part of the input list when splitting it in <code>dosort</code>?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.2.3">Exercise 12.2.3</h4>
<div class="paragraph">
<p>All or nearly all allocation could be saved if the algorithm were to work destructively, using <code>set-cdr!</code> to separate and join lists. Write destructive versions <code>sort!</code> and <code>merge!</code> of the <code>sort</code> and <code>merge</code>. Determine the difference between the two sets of procedures in terms of allocation and run time for various inputs.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_12.3.">Section 12.3. A Set Constructor</h3>
<div class="paragraph">
<p>This example describes a syntactic extension, <code>set-of</code>, that allows the construction of sets represented as lists with no repeated elements <a href="#ref22">[22]</a>. It uses <code>define-syntax</code> and <code>syntax-rules</code> to compile set expressions into recursion expressions. The expanded code is often as efficient as that which can be produced by hand.</p>
</div>
<div class="paragraph">
<p>A <code>set-of</code> expression takes the following form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(set-of <em>expr</em> <em>clause</em> ...)</code></pre>
</div>
</div>
<div class="paragraph">
<p><code><em>expr</em></code> describes the elements of the set in terms of the bindings established by the <code>set-of</code> clauses <code><em>clause</em> ...</code>. Each <code><em>clause</em></code> can take one of three forms:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A clause of the form <code>(<em>x</em> in <em>s</em>)</code> establishes a binding for <code><em>x</em></code> to each element of the set <code><em>s</em></code> in turn. This binding is visible within the remaining clauses and the expression <code><em>expr</em></code>.</p>
</li>
<li>
<p>A clause of the form <code>(<em>x</em> is <em>e</em>)</code> establishes a binding for <code><em>x</em></code> to <code><em>e</em></code>. This binding is visible within the remaining clauses and the expression <code><em>expr</em></code>. This form is essentially an abbreviation for <code>(<em>x</em> in (list <em>e</em>))</code>.</p>
</li>
<li>
<p>A clause taking any other form is treated as a predicate; this is used to force refusal of certain elements as in the second of the examples below.<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(set-of x
  (x in '(a b c))) ⇒ (a b c)

(set-of x
  (x in '(1 2 3 4))
  (even? x)) ⇒ (2 4)

(set-of (cons x y)
  (x in '(1 2 3))
  (y is (* x x))) ⇒ ((1 . 1) (2 . 4) (3 . 9))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(set-of (cons x y)
  (x in '(a b))
  (y in '(1 2))) ⇒ ((a . 1) (a . 2) (b . 1) (b . 2))</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>A <code>set-of</code> expression is transformed into nested <code>let</code>, named <code>let</code>, and <code>if</code> expressions, corresponding to each <code>is</code>, <code>in</code>, or predicate subexpression. For example, the simple expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(set-of x (x in '(a b c)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>is transformed into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let loop ([set '(a b c)])
  (if (null? set)
      '()
      (let ([x (car set)])
        (set-cons x (loop (cdr set))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(set-of x (x in '(1 2 3 4)) (even? x))</code></pre>
</div>
</div>
<div class="paragraph">
<p>is transformed into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let loop ([set '(1 2 3 4)])
  (if (null? set)
      '()
      (let ([x (car set)])
        (if (even? x)
            (set-cons x (loop (cdr set)))
            (loop (cdr set))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The more complicated expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(set-of (cons x y) (x in '(1 2 3)) (y is (* x x)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>is transformed into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let loop ([set '(1 2 3)])
  (if (null? set)
      '()
      (let ([x (car set)])
        (let ([y (* x x)])
          (set-cons (cons x y)
                    (loop (cdr set)))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, the expression</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(set-of (cons x y) (x in '(a b)) (y in '(1 2)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>is transformed into nested named <code>let</code> expressions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let loop1 ([set1 '(a b)])
  (if (null? set1)
      '()
      (let ([x (car set1)])
        (let loop2 ([set2 '(1 2)])
          (if (null? set2)
              (loop1 (cdr set1))
              (let ([y (car set2)])
                (set-cons (cons x y)
                          (loop2 (cdr set2)))))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>These are fairly straightforward transformations, except that the base case for the recursion on nested named <code>let</code> expressions varies depending upon the level. The base case for the outermost named <code>let</code> is always the empty list <code>()</code>, while the base case for an internal named <code>let</code> is the recursion step for the next outer named <code>let</code>. In order to handle this, the definition of <code>set-of</code> employs a help syntactic extension <code>set-of-help</code>. <code>set-of-help</code> takes an additional expression, <code>base</code>, which is the base case for recursion at the current level.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (tspl sets)
  (export set-of set-cons in is)
  (import (rnrs))

 ; set-of uses helper syntactic extension set-of-help, passing it
 ; an initial base expression of '()
  (define-syntax set-of
    (syntax-rules ()
      [(_ e m ...)
       (set-of-help e '() m ...)]))

 ; set-of-help recognizes in, is, and predicate expressions and
 ; changes them into nested named let, let, and if expressions.
  (define-syntax set-of-help
    (syntax-rules (in is)
      [(_ e base) (set-cons e base)]
      [(_ e base (x in s) m ...)
       (let loop ([set s])
         (if (null? set)
             base
             (let ([x (car set)])
               (set-of-help e (loop (cdr set)) m ...))))]
      [(_ e base (x is y) m ...)
       (let ([x y]) (set-of-help e base m ...))]
      [(_ e base p m ...)
       (if p (set-of-help e base m ...) base)]))

 ; since in and is are used as auxiliary keywords by set-of, the
 ; library must export definitions for them as well
  (define-syntax in
    (lambda (x)
      (syntax-violation 'in "misplaced auxiliary keyword" x)))

  (define-syntax is
    (lambda (x)
      (syntax-violation 'is "misplaced auxiliary keyword" x)))

 ; set-cons returns the original set y if x is already in y.
  (define set-cons
    (lambda (x y)
      (if (memv x y)
          y
          (cons x y)))))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.3.1">Exercise 12.3.1</h4>
<div class="paragraph">
<p>Write a procedure, <code>union</code>, that takes an arbitrary number of sets (lists) as arguments and returns the union of the sets, using only the <code>set-of</code> syntactic form. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(union) ⇒ ()
(union '(a b c)) ⇒ (a b c)
(union '(2 5 4) '(9 4 3)) ⇒ (2 5 9 4 3)
(union '(1 2) '(2 4) '(4 8)) ⇒ (1 2 4 8)</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.3.2">Exercise 12.3.2</h4>
<div class="paragraph">
<p>A single-list version of <code>map</code> can (almost) be defined as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define map1
  (lambda (f ls)
    (set-of (f x) (x in ls))))

(map1 - '(1 2 3 2)) ⇒ (-1 -3 -2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Why does this not work? What could be changed to make it work?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.3.3">Exercise 12.3.3</h4>
<div class="paragraph">
<p>Devise a different definition of <code>set-cons</code> that maintains sets in some sorted order, making the test for set membership, and hence <code>set-cons</code> itself, potentially more efficient.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_12.4.">Section 12.4. Word Frequency Counting</h3>
<div class="paragraph">
<p>This program demonstrates several basic programming techniques, including string and character manipulation, file input/output, data structure manipulation, and recursion. The program is adapted from Chapter 6 of <em>The C Programming Language</em> <a href="#ref19">[19]</a>. One reason for using this particular example is to show how a C program might look when converted almost literally into Scheme.</p>
</div>
<div class="paragraph">
<p>A few differences between the Scheme program and the original C program are worth noting. First, the Scheme version employs a different protocol for file input and output. Rather than implicitly using the standard input and output ports, it requires that filenames be passed in, thus demonstrating the opening and closing of files. Second, the procedure <code>get-word</code> returns one of three values: a string (the word), a nonalphabetic character, or an eof value. The original C version returned a flag for letter (to say that a word was read) or a nonalphabetic character. Furthermore, the C version passed in a string to fill and a limit on the number of characters in the string; the Scheme version builds a new string of whatever length is required (the characters in the word are held in a list until the end of the word has been found, then converted into a string with <code>list-&gt;string</code>). Finally, <code>char-type</code> uses the primitive Scheme character predicates <code>char-alphabetic?</code> and <code>char-numeric?</code> to determine whether a character is a letter or digit.</p>
</div>
<div class="paragraph">
<p>The main program, <code>frequency</code>, takes an input filename and an output filename as arguments, e.g., <code>(frequency "pickle" "freq.out")</code> prints the frequency count for each word in the file "pickle" to the file "freq.out." As <code>frequency</code> reads words from the input file, it inserts them into a binary tree structure (using a binary sorting algorithm). Duplicate entries are recorded by incrementing the count associated with each word. Once end of file is reached, the program traverses the tree, printing each word with its count.</p>
</div>
<div class="paragraph">
<p>Assume that the file "pickle" contains the following text.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Peter Piper picked a peck of pickled peppers;
A peck of pickled peppers Peter Piper picked.
If Peter Piper picked a peck of pickled peppers,
Where's the peck of pickled peppers Peter Piper picked?</pre>
</div>
</div>
<div class="paragraph">
<p>Then, after typing <code>(frequency "pickle" "freq.out")</code>, the file "freq.out" should contain the following.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">1 A
1 If
4 Peter
4 Piper
1 Where
2 a
4 of
4 peck
4 peppers
4 picked
4 pickled
1 s
1 the</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code for the word-counting program is structured as a top-level program, with the script header recommended in the scripts chapter of the nonnormative appendices to the Revised<sup>6</sup> Report <a href="#ref25">[25]</a>. It takes the names of input and output files from the command line.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">#! /usr/bin/env scheme-script
(import (rnrs))

;;; If the next character on p is a letter, get-word reads a word
;;; from p and returns it in a string.  If the character is not a
;;; letter, get-word returns the character (on eof, the eof-object).
(define get-word
  (lambda (p)
    (let ([c (get-char p)])
      (if (eq? (char-type c) 'letter)
          (list->string
            (let loop ([c c])
              (cons
                c
                (if (memq (char-type (lookahead-char p))
                          '(letter digit))
                    (loop (get-char p))
                    '()))))
          c))))

;;; char-type tests for the eof-object first, since the eof-object
;;; may not be a valid argument to char-alphabetic? or char-numeric?
;;; It returns the eof-object, the symbol letter, the symbol digit,
;;; or the argument itself if it is not a letter or digit.
(define char-type
  (lambda (c)
    (cond
      [(eof-object? c) c]
      [(char-alphabetic? c) 'letter]
      [(char-numeric? c) 'digit]
      [else c])))

;;; Tree nodes are represented as a record type with four fields: word,
;;; left, right, and count.  Only one field, word, is initialized by an
;;; argument to the constructor procedure make-tnode.  The remaining
;;; fields are initialized by the constructor and changed by subsequent
;;; operations.
(define-record-type tnode
  (fields (immutable word)
          (mutable left)
          (mutable right)
          (mutable count))
  (protocol
    (lambda (new)
      (lambda (word)
        (new word '() '() 1)))))

;;; If the word already exists in the tree, tree increments its
;;; count.  Otherwise, a new tree node is created and put into the
;;; tree.  In any case, the new or modified tree is returned.
(define tree
  (lambda (node word)
    (cond
      [(null? node) (make-tnode word)]
      [(string=? word (tnode-word node))
       (tnode-count-set! node (+ (tnode-count node) 1))
       node]
      [(string&lt;? word (tnode-word node))
       (tnode-left-set! node (tree (tnode-left node) word))
       node]
      [else
       (tnode-right-set! node (tree (tnode-right node) word))
       node])))

;;; tree-print prints the tree in "in-order," i.e., left subtree,
;;; then node, then right subtree.  For each word, the count and the
;;; word are printed on a single line.
(define tree-print
  (lambda (node p)
    (unless (null? node)
      (tree-print (tnode-left node) p)
      (put-datum p (tnode-count node))
      (put-char p #\space)
      (put-string p (tnode-word node))
      (newline p)
      (tree-print (tnode-right node) p))))

;;; frequency is the driver routine.  It opens the files, reads the
;;; words, and enters them into the tree.  When the input port
;;; reaches end-of-file, it prints the tree and closes the ports.
(define frequency
  (lambda (infn outfn)
    (let ([ip (open-file-input-port infn (file-options)
                (buffer-mode block) (native-transcoder))]
          [op (open-file-output-port outfn (file-options)
                (buffer-mode block) (native-transcoder))])
      (let loop ([root '()])
        (let ([w (get-word ip)])
          (cond
            [(eof-object? w) (tree-print root op)]
            [(string? w) (loop (tree root w))]
            [else (loop root)])))
      (close-port ip)
      (close-port op))))

(unless (= (length (command-line)) 3)
  (put-string (current-error-port) "usage: ")
  (put-string (current-error-port) (car (command-line)))
  (put-string (current-error-port) " input-filename output-filename\n")
  (exit #f))

(frequency (cadr (command-line)) (caddr (command-line)))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.4.1">Exercise 12.4.1</h4>
<div class="paragraph">
<p>In the output file shown earlier, the capitalized words appeared before the others in the output file, and the capital <code>A</code> was not recognized as the same word as the lower-case <code>a</code>. Modify <code>tree</code> to use the case-insensitive versions of the string comparisons so that this does not happen.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.4.2">Exercise 12.4.2</h4>
<div class="paragraph">
<p>The "word" <code>s</code> appears in the file "freq.out," although it is really just a part of the contraction <code>Where&#8217;s</code>. Adjust <code>get-word</code> to allow embedded single quote marks.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.4.3">Exercise 12.4.3</h4>
<div class="paragraph">
<p>Modify this program to "weed out" certain common words such as <code>a</code>, <code>an</code>, <code>the</code>, <code>is</code>, <code>of</code>, etc., in order to reduce the amount of output for long input files. Try to devise other ways to cut down on useless output.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.4.4">Exercise 12.4.4</h4>
<div class="paragraph">
<p><code>get-word</code> buffers characters in a list, allocating a new pair (with <code>cons</code>) for each character. Make it more efficient by using a string to buffer the characters. Devise a way to allow the string to grow if necessary. [<em>Hint</em>: Use <code>string-append</code> or a string output port.]</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.4.5">Exercise 12.4.5</h4>
<div class="paragraph">
<p>The <code>tree</code> implementation works by creating trees and later filling in their <code>left</code> and <code>right</code> fields. This requires many unnecessary assignments. Rewrite the <code>tree</code> procedure to avoid <code>tree-left-set!</code> and <code>tree-right-set!</code> entirely.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.4.6">Exercise 12.4.6</h4>
<div class="paragraph">
<p>Recode the program to use a hashtable (<a href="#section_6.13.">Section 6.13</a>) in place of a binary tree, and compare the running times of the new and old programs on large input files. Are hashtables always faster or always slower? Is there a break-even point? Does the break-even point depend on the size of the file or on some other characteristic of the file?</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_12.5.">Section 12.5. Scheme Printer</h3>
<div class="paragraph">
<p>Printing Scheme objects may seem like a complicated process, but in fact a rudimentary printer is straightforward, as this example demonstrates. <code>put-datum</code>, <code>write</code>, and <code>display</code> are all implemented by the same code. Sophisticated printers often support various printer controls and handle printing of cyclic objects, but the one given here is completely basic.</p>
</div>
<div class="paragraph">
<p>The main driver for the program is a procedure <code>wr</code>, which takes an object to print <code>x</code>, a flag <code>d?</code>, and a port <code>p</code>. The flag <code>d?</code> (for display) is <code>#t</code> if the code is to <em>display</em> the object, <code>#f</code> otherwise. The <code>d?</code> flag is important only for characters and strings. Recall from <a href="#section_7.8.">Section 7.8</a> that <code>display</code> prints strings without the enclosing quote marks and characters without the <code>#\</code> syntax.</p>
</div>
<div class="paragraph">
<p>The entry points for <code>write</code> and <code>display</code> handle the optionality of the second (port) argument, passing the value of <code>current-output-port</code> when no port argument is provided.</p>
</div>
<div class="paragraph">
<p>Procedures, ports, and the end-of-file object are printed as <code>#&lt;procedure&gt;</code>, <code>#&lt;port&gt;</code>, and <code>#&lt;eof&gt;</code>. Unrecognized types of values are printed as <code>#&lt;unknown&gt;</code>. So, for example, a hashtable, enumeration set, and object of some implementation-specific type will all print as <code>#&lt;unknown&gt;</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (tspl printer)
  (export put-datum write display)
  (import (except (rnrs) put-datum write display))

 ; define these here to avoid confusing paren-balancers
  (define lparen #\()
  (define rparen #\))

 ; wr is the driver, dispatching on the type of x
  (define wr
    (lambda (x d? p)
      (cond
        [(symbol? x) (put-string p (symbol->string x))]
        [(pair? x) (wrpair x d? p)]
        [(number? x) (put-string p (number->string x))]
        [(null? x) (put-string p "()")]
        [(boolean? x) (put-string p (if x "#t" "#f"))]
        [(char? x) (if d? (put-char p x) (wrchar x p))]
        [(string? x) (if d? (put-string p x) (wrstring x p))]
        [(vector? x) (wrvector x d? p)]
        [(bytevector? x) (wrbytevector x d? p)]
        [(eof-object? x) (put-string p "#&lt;eof&gt;")]
        [(port? x) (put-string p "#&lt;port&gt;")]
        [(procedure? x) (put-string p "#&lt;procedure&gt;")]
        [else (put-string p "#&lt;unknown&gt;")])))

 ; wrpair handles pairs and nonempty lists
  (define wrpair
    (lambda (x d? p)
      (put-char p lparen)
      (let loop ([x x])
        (wr (car x) d? p)
        (cond
          [(pair? (cdr x)) (put-char p #\space) (loop (cdr x))]
          [(null? (cdr x))]
          [else (put-string p " . ") (wr (cdr x) d? p)]))
      (put-char p rparen)))

 ; wrchar handles characters.  Used only when d? is #f.
  (define wrchar
    (lambda (x p)
      (put-string p "#\\")
      (cond
        [(assq x '((#\alarm . "alarm") (#\backspace . "backspace")
                   (#\delete . "delete") (#\esc . "esc")
                   (#\newline . "newline") (#\nul . "nul")
                   (#\page . "page") (#\return . "return")
                   (#\space . "space") (#\tab . "tab")
                   (#\vtab . "vtab"))) =>
         (lambda (a) (put-string p (cdr a)))]
        [else (put-char p x)])))

 ; wrstring handles strings.  Used only when d? is #f.
  (define wrstring
    (lambda (x p)
      (put-char p #\")
      (let ([n (string-length x)])
        (do ([i 0 (+ i 1)])
            ((= i n))
          (let ([c (string-ref x i)])
            (case c
              [(#\alarm) (put-string p "\\a")]
              [(#\backspace) (put-string p "\\b")]
              [(#\newline) (put-string p "\\n")]
              [(#\page) (put-string p "\\f")]
              [(#\return) (put-string p "\\r")]
              [(#\tab) (put-string p "\\t")]
              [(#\vtab) (put-string p "\\v")]
              [(#\") (put-string p "\\\"")]
              [(#\\) (put-string p "\\\\")]
              [else (put-char p c)]))))
      (put-char p #\")))

  (define wrvector
    (lambda (x d? p)
      (put-char p #\#)
      (let ([n (vector-length x)])
        (do ([i 0 (+ i 1)] [sep lparen #\space])
            ((= i n))
          (put-char p sep)
          (wr (vector-ref x i) d? p)))
      (put-char p rparen)))

  (define wrbytevector
    (lambda (x d? p)
      (put-string p "#vu8")
      (let ([n (bytevector-length x)])
        (do ([i 0 (+ i 1)] [sep lparen #\space])
            ((= i n))
          (put-char p sep)
          (wr (bytevector-u8-ref x i) d? p)))
      (put-char p rparen)))

 ; check-and-wr is called when the port is supplied
  (define check-and-wr
    (lambda (who x d? p)
      (unless (and (output-port? p) (textual-port? p))
        (assertion-violation who "invalid argument" p))
      (wr x d? p)))

 ; put-datum calls wr with d? set to #f
  (define put-datum
    (lambda (p x)
      (check-and-wr 'put-datum x #f p)))

 ; write calls wr with d? set to #f
  (define write
    (case-lambda
      [(x) (wr x #f (current-output-port))]
      [(x p) (check-and-wr 'write x #f p)]))

 ; display calls wr with d? set to #t
  (define display
    (case-lambda
      [(x) (wr x #t (current-output-port))]
      [(x p) (check-and-wr 'display x #t p)])))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.5.1">Exercise 12.5.1</h4>
<div class="paragraph">
<p>Numbers are printed with the help of <code>number-&gt;string</code>. Correct printing of all Scheme numeric types, especially inexact numbers, is a complicated task. Handling exact integers and ratios is fairly straightforward, however. Modify the code to print exact integers and ratios numbers directly (without <code>number-&gt;string</code>), but continue to use <code>number-&gt;string</code> for inexact and complex numbers.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.5.2">Exercise 12.5.2</h4>
<div class="paragraph">
<p>Modify <code>wr</code> and its helpers to direct their output to an internal buffer rather than to a port. Use the modified versions to implement a procedure <code>object-&gt;string</code> that, like <code>number-&gt;string</code>, returns a string containing a printed representation of its input. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(object->string '(a b c)) ⇒ "(a b c)"
(object->string "hello") ⇒ "\"hello\""</code></pre>
</div>
</div>
<div class="paragraph">
<p>You may be surprised just how easy this change is to make.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.5.3">Exercise 12.5.3</h4>
<div class="paragraph">
<p>Some symbols are not printed properly by <code>wr</code>, including those that start with digits or contain whitespace. Modify <code>wr</code> to call a <code>wrsymbol</code> helper that uses hex scalar escapes as necessary to handle such symbols. A hex scalar escape takes the form <code>#\x<em>n</em>;</code>, where <code><em>n</em></code> is the Unicode scalar value of a character expressed in hexadecimal notation. Consult the grammar for symbols on <a href="#grammar:symbols">page 458</a> to determine when hex scalar escapes are necessary.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_12.6.">Section 12.6. Formatted Output</h3>
<div class="paragraph">
<p>It is often necessary to print strings containing the printed representations of Scheme objects, especially numbers. Doing so with Scheme&#8217;s standard output routines can be tedious. For example, the <code>tree-print</code> procedure of <a href="#section_12.4.">Section 12.4</a> requires a sequence of four calls to output routines to print a simple one-line message:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(put-datum p (tnode-count node))
(put-char p #\space)
(put-string p (tnode-word node))
(newline p)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The formatted output facility defined in this section allows these four calls to be replaced by the single call to <code>fprintf</code> below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(fprintf p "~s ~a~%" (tnode-count node) (tnode-word node))</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fprintf</code> expects a port argument, a <em>control string</em>, and an indefinite number of additional arguments that are inserted into the output as specified by the control string. In the example, the value of <code>(tnode-count node)</code> is written first, in place of <code>~s</code>. This is followed by a space and the displayed value of <code>(tnode-word node)</code>, in place of <code>~a</code>. The <code>~%</code> is replaced in the output with a newline.</p>
</div>
<div class="paragraph">
<p>The procedure <code>printf</code>, also defined in this section, is like <code>fprintf</code> except that no port argument is expected and output is sent to the current output port.</p>
</div>
<div class="paragraph">
<p><code>~s</code>, <code>~a</code>, and <code>~%</code> are <em>format directives</em>; <code>~s</code> causes the first unused argument after the control string to be printed to the output via <code>write</code>, <code>~a</code> causes the first unused argument to be printed via <code>display</code>, and <code>~%</code> simply causes a newline character to be printed. The simple implementation of <code>fprintf</code> below recognizes only one other format directive, <code>~~</code>, which inserts a tilde into the output. For example,</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(printf "The string ~s displays as ~~.~%" "~")</code></pre>
</div>
</div>
<div class="paragraph">
<p>prints</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">The string "~" displays as ~.</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (tspl formatted-output)
  (export printf fprintf)
  (import (rnrs))

 ; dofmt does all of the work.  It loops through the control string
 ; recognizing format directives and printing all other characters
 ; without interpretation.  A tilde at the end of a control string is
 ; treated as an ordinary character.  No checks are made for proper
 ; inputs.  Directives may be given in either lower or upper case.
  (define dofmt
    (lambda (p cntl args)
      (let ([nmax (- (string-length cntl) 1)])
        (let loop ([n 0] [a args])
          (if (<= n nmax)
              (let ([c (string-ref cntl n)])
                (if (and (char=? c #\~) (< n nmax))
                    (case (string-ref cntl (+ n 1))
                      [(#\a #\A)
                       (display (car a) p)
                       (loop (+ n 2) (cdr a))]
                      [(#\s #\S)
                       (write (car a) p)
                       (loop (+ n 2) (cdr a))]
                      [(#\%)
                       (newline p)
                       (loop (+ n 2) a)]
                      [(#\~)
                       (put-char p #\~) (loop (+ n 2) a)]
                      [else
                       (put-char p c) (loop (+ n 1) a)])
                    (begin
                      (put-char p c)
                      (loop (+ n 1) a)))))))))

 ; printf and fprintf differ only in that fprintf passes its
 ; port argument to dofmt while printf passes the current output
 ; port.
  (define printf
    (lambda (control . args)
      (dofmt (current-output-port) control args)))

  (define fprintf
    (lambda (p control . args)
      (dofmt p control args))))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.6.1">Exercise 12.6.1</h4>
<div class="paragraph">
<p>Add error checking to the code for invalid port arguments (<code>fprintf</code>), invalid tilde escapes, and extra or missing arguments.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.6.2">Exercise 12.6.2</h4>
<div class="paragraph">
<p>Using the optional radix argument to <code>number-&gt;string</code>, augment <code>printf</code> and <code>fprintf</code> with support for the following new format directives:</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>~b</code> or <code>~B</code>: print the next unused argument, which must be a number, in binary;</p>
</li>
<li>
<p><code>~o</code> or <code>~O</code>: print the next unused argument, which must be a number, in octal; and</p>
</li>
<li>
<p><code>~x</code> or <code>~X</code>: print the next unused argument, which must be a number, in hexadecimal.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(printf "#x~x #o~o #b~b~%" 16 8 2)</code></pre>
</div>
</div>
<div class="paragraph">
<p>would print</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">#x10 #o10 #b10</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.6.3">Exercise 12.6.3</h4>
<div class="paragraph">
<p>Add an "indirect" format directive, <code>~@</code>, that treats the next unused argument, which must be a string, as if it were spliced into the current format string. For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(printf "--- ~@ ---" "> ~s <" '(a b c))</code></pre>
</div>
</div>
<div class="paragraph">
<p>would print</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">---> (a b c) <---</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.6.4">Exercise 12.6.4</h4>
<div class="paragraph">
<p>Implement <code>format</code>, a version of <code>fprintf</code> that places its output into a string instead of writing to a port. Make use of <code>object-&gt;string</code> from <a href="#exercise_12.5.2">Exercise 12.5.2</a> to support the <code>~s</code> and <code>~a</code> directives.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 3] [y 4])
  (format "~s + ~s = ~s" x y (+ x y))) ⇒ "3 + 4 = 7"</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.6.5">Exercise 12.6.5</h4>
<div class="paragraph">
<p>Instead of using <code>object-&gt;string</code>, define <code>format</code> using a string output port.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.6.6">Exercise 12.6.6</h4>
<div class="paragraph">
<p>Modify <code>format</code>, <code>fprintf</code>, and <code>printf</code> to allow a field size to be specified after the tilde in the <code>~a</code> and <code>~s</code> format directives. For example, the directive <code>~10s</code> would cause the next unused argument to be inserted into the output left-justified in a field of size 10. If the object requires more spaces than the amount specified, allow it to extend beyond the field.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x 'abc] [y '(def)])
  (format "(cons '~5s '~5s) = ~5s"
    x y (cons x y))) ⇒ "(cons 'abc   '(def)) = (abc def)"</code></pre>
</div>
</div>
<div class="paragraph">
<p>[<em>Hint</em>: Use <code>format</code> recursively.]</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_12.7.">Section 12.7. A Meta-Circular Interpreter for Scheme</h3>
<div class="paragraph">
<p>The program described in this section is a <em>meta-circular</em> interpreter for Scheme, i.e., it is an interpreter <em>for</em> Scheme written <em>in</em> Scheme. The interpreter shows how small Scheme is when the core structure is considered independently from its syntactic extensions and primitives. It also illustrates interpretation techniques that can be applied equally well to languages other than Scheme.</p>
</div>
<div class="paragraph">
<p>The relative simplicity of the interpreter is somewhat misleading. An interpreter for Scheme written in Scheme can be quite a bit simpler than one written in most other languages. Here are a few reasons why this one is simpler.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Tail calls are handled properly only because tail calls in the interpreter are handled properly by the host implementation. All that is required is that the interpreter itself be tail-recursive.</p>
</li>
<li>
<p>First-class procedures in interpreted code are implemented by first-class procedures in the interpreter, which in turn are supported by the host implementation.</p>
</li>
<li>
<p>First-class continuations created with <code>call/cc</code> are provided by the host implementation&#8217;s <code>call/cc</code>.</p>
</li>
<li>
<p>Primitive procedures such as <code>cons</code> and <code>assq</code> and services such as storage management are provided by the host implementation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Converting the interpreter to run in a language other than Scheme may require explicit support for some or all of these items.</p>
</div>
<div class="paragraph">
<p>The interpreter stores lexical bindings in an <em>environment</em>, which is simply an <em>association list</em> (see <a href="#page:assq">page 165</a>). Evaluation of a <code>lambda</code> expression results in the creation of a procedure within the scope of variables holding the environment and the <code>lambda</code> body. Subsequent application of the procedure combines the new bindings (the actual parameters) with the saved environment.</p>
</div>
<div class="paragraph">
<p>The interpreter handles only the core syntactic forms described in <a href="#section_3.1.">Section 3.1</a>, and it recognizes bindings for only a handful of primitive procedures. It performs no error checking.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(interpret 3) ⇒ 3

(interpret '(cons 3 4)) ⇒ (3 . 4)

(interpret
  '((lambda (x . y)
      (list x y))
    'a 'b 'c 'd)) ⇒ (a (b c d))

(interpret
  '(((call/cc (lambda (k) k))
     (lambda (x) x))
    "HEY!")) ⇒ "HEY!"

(interpret
  '((lambda (memq)
      (memq memq 'a '(b c a d e)))
    (lambda (memq x ls)
      (if (null? ls) #f
          (if (eq? (car ls) x)
              ls
              (memq memq x (cdr ls))))))) ⇒ (a d e)

(interpret
  '((lambda (reverse)
      (set! reverse
        (lambda (ls new)
          (if (null? ls)
              new
              (reverse (cdr ls) (cons (car ls) new)))))
      (reverse '(a b c d e) '()))
 #f)) ⇒ (e d c b a)</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (tspl interpreter)
  (export interpret)
  (import (rnrs) (rnrs mutable-pairs))

 ; primitive-environment contains a small number of primitive
 ; procedures; it can be extended easily with additional primitives.
  (define primitive-environment
    `((apply . ,apply) (assq . ,assq) (call/cc . ,call/cc)
      (car . ,car) (cadr . ,cadr) (caddr . ,caddr)
      (cadddr . ,cadddr) (cddr . ,cddr) (cdr . ,cdr)
      (cons . ,cons) (eq? . ,eq?) (list . ,list) (map . ,map)
      (memv . ,memv) (null? . ,null?) (pair? . ,pair?)
      (read . ,read) (set-car! . ,set-car!)
      (set-cdr! . ,set-cdr!) (symbol? . ,symbol?)))

 ; new-env returns a new environment from a formal parameter
 ; specification, a list of actual parameters, and an outer
 ; environment.  The symbol? test identifies "improper"
 ; argument lists.  Environments are association lists,
 ; associating variables with values.
  (define new-env
    (lambda (formals actuals env)
      (cond
        [(null? formals) env]
        [(symbol? formals) (cons (cons formals actuals) env)]
        [else
         (cons
           (cons (car formals) (car actuals))
           (new-env (cdr formals) (cdr actuals) env))])))

 ; lookup finds the value of the variable var in the environment
 ; env, using assq.  Assumes var is bound in env.
  (define lookup
    (lambda (var env)
      (cdr (assq var env))))

 ; assign is similar to lookup but alters the binding of the
 ; variable var by changing the cdr of the association pair
  (define assign
    (lambda (var val env)
      (set-cdr! (assq var env) val)))

 ; exec evaluates the expression, recognizing a small set of core forms.
  (define exec
    (lambda (expr env)
      (cond
        [(symbol? expr) (lookup expr env)]
        [(pair? expr)
         (case (car expr)
           [(quote) (cadr expr)]
           [(lambda)
            (lambda vals
              (let ([env (new-env (cadr expr) vals env)])
                (let loop ([exprs (cddr expr)])
                  (if (null? (cdr exprs))
                      (exec (car exprs) env)
                      (begin
                        (exec (car exprs) env)
                        (loop (cdr exprs)))))))]
           [(if)
            (if (exec (cadr expr) env)
                (exec (caddr expr) env)
                (exec (cadddr expr) env))]
           [(set!) (assign (cadr expr) (exec (caddr expr) env) env)]
           [else
            (apply
              (exec (car expr) env)
              (map (lambda (x) (exec x env)) (cdr expr)))])]
        [else expr])))

 ; interpret starts execution with the primitive environment.
  (define interpret
    (lambda (expr)
      (exec expr  primitive-environment))))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.7.1">Exercise 12.7.1</h4>
<div class="paragraph">
<p>As written, the interpreter cannot interpret itself because it does not support several of the syntactic forms used in its implementation: <code>let</code> (named and unnamed), internal <code>define</code>, <code>case</code>, <code>cond</code>, and <code>begin</code>. Rewrite the code for the interpreter, using only the syntactic forms it supports.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.7.2">Exercise 12.7.2</h4>
<div class="paragraph">
<p>After completing the preceding exercise, use the interpreter to run a copy of the interpreter, and use the copy to run another copy of the interpreter. Repeat this process to see how many levels deep it will go before the system grinds to a halt.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.7.3">Exercise 12.7.3</h4>
<div class="paragraph">
<p>At first glance, it might seem that the <code>lambda</code> case could be written more simply as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">[(lambda)
 (lambda vals
   (let ([env (new-env (cadr expr) vals env)])
     (let loop ([exprs (cddr expr)])
       (let ([val (exec (car exprs) env)])
         (if (null? (cdr exprs))
             val
             (loop (cdr exprs)))))))]</code></pre>
</div>
</div>
<div class="paragraph">
<p>Why would this be incorrect? [<em>Hint</em>: What property of Scheme would be violated?]</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.7.4">Exercise 12.7.4</h4>
<div class="paragraph">
<p>Try to make the interpreter more efficient by looking for ways to ask fewer questions or to allocate less storage space. [<em>Hint</em>: Before evaluation, convert lexical variable references into <code>(access <em>n</em>)</code>, where <code><em>n</em></code> represents the number of values in the environment association list in front of the value in question.]</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.7.5">Exercise 12.7.5</h4>
<div class="paragraph">
<p>Scheme evaluates arguments to a procedure before applying the procedure and applies the procedure to the values of these arguments (<em>call-by-value</em>). Modify the interpreter to pass arguments unevaluated and arrange to evaluate them upon reference (<em>call-by-name</em>). [<em>Hint</em>: Use <code>lambda</code> to delay evaluation.] You will need to create versions of the primitive procedures (<code>car</code>, <code>null?</code>, etc.) that take their arguments unevaluated.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_12.8.">Section 12.8. Defining Abstract Objects</h3>
<div class="paragraph">
<p>This example demonstrates a syntactic extension that facilitates the definition of simple abstract objects (see <a href="#section_2.9.">Section 2.9</a>). This facility has unlimited potential as the basis for a complete object-oriented subsystem in Scheme.</p>
</div>
<div class="paragraph">
<p>Abstract objects are similar to basic data structures such as pairs and vectors. Rather than being manipulated via access and assignment operators, however, abstract objects respond to <em>messages</em>. The valid messages and the actions to be taken for each message are defined by code within the object itself rather than by code outside the object, resulting in more modular and potentially more secure programming systems. The data local to an abstract object is accessible only through the actions performed by the object in response to the messages.</p>
</div>
<div class="paragraph">
<p>A particular type of abstract object is defined with <code>define-object</code>, which has the general form</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-object (<em>name</em> <em>var<sub>1</sub></em> ...)
  ((<em>var<sub>2</sub></em> <em>expr</em>) ...)
  ((<em>msg</em> <em>action</em>) ...))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first set of bindings <code>((<em>var<sub>2</sub></em> <em>expr</em>) ...)</code> may be omitted. <code>define-object</code> defines a procedure that is called to create new abstract objects of the given type. This procedure is called <code><em>name</em></code>, and the arguments to this procedure become the values of the local variables <code><em>var<sub>1</sub></em> ...</code>. After the procedure is invoked, the variables <code><em>var<sub>2</sub></em> ...</code> are bound to the values <code><em>expr</em> ...</code> in sequence (as with <code>let*</code>) and the messages <code><em>msg</em> ...</code> are bound to the procedure values <code><em>action</em> ...</code> in a mutually recursive fashion (as with <code>letrec</code>). Within these bindings, the new abstract object is created; this object is the value of the creation procedure.</p>
</div>
<div class="paragraph">
<p>The syntactic form <code>send-message</code> is used to send messages to abstract objects. <code>(send-message <em>object</em> <em>msg</em> <em>arg</em> ...)</code> sends <code><em>object</em></code> the message <code><em>msg</em></code> with arguments <code><em>arg</em> ...</code>. When an object receives a message, the <code><em>arg</em> ...</code> become the parameters to the action procedure associated with the message, and the value returned by this procedure is returned by <code>send-message</code>.</p>
</div>
<div class="paragraph">
<p>The following examples should help to clarify how abstract objects are defined and used. The first example is a simple <code>kons</code> object that is similar to Scheme&#8217;s built-in pair object type, except that to access or assign its fields requires sending it messages.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-object (kons kar kdr)
  ((get-car (lambda () kar))
   (get-cdr (lambda () kdr))
   (set-car! (lambda (x) (set! kar x)))
   (set-cdr! (lambda (x) (set! kdr x)))))

(define p (kons 'a 'b))
(send-message p get-car) ⇒ a
(send-message p get-cdr) ⇒ b
(send-message p set-cdr! 'c)
(send-message p get-cdr) ⇒ c</code></pre>
</div>
</div>
<div class="paragraph">
<p>The simple <code>kons</code> object does nothing but return or assign one of the fields as requested. What makes abstract objects interesting is that they can be used to restrict access or perform additional services. The following version of <code>kons</code> requires that a password be given with any request to assign one of the fields. This password is a parameter to the <code>kons</code> procedure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-object (kons kar kdr pwd)
  ((get-car (lambda () kar))
   (get-cdr (lambda () kar))
   (set-car!
     (lambda (x p)
       (if (string=? p pwd)
           (set! kar x))))
   (set-cdr!
     (lambda (x p)
       (if (string=? p pwd)
           (set! kar x))))))

(define p1 (kons 'a 'b "magnificent"))
(send-message p1 set-car! 'c "magnificent")
(send-message p1 get-car) ⇒ c
(send-message p1 set-car! 'd "please")
(send-message p1 get-car) ⇒ c

(define p2 (kons 'x 'y "please"))
(send-message p2 set-car! 'z "please")
(send-message p2 get-car) ⇒ z</code></pre>
</div>
</div>
<div class="paragraph">
<p>One important ability of an abstract object is that it can keep statistics on messages sent to it. The following version of <code>kons</code> counts accesses to the two fields. This version also demonstrates the use of explicitly initialized local bindings.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-object (kons kar kdr)
  ((count 0))
  ((get-car
    (lambda ()
      (set! count (+ count 1))
      kar))
   (get-cdr
    (lambda ()
      (set! count (+ count 1))
      kdr))
    (accesses
     (lambda () count))))

(define p (kons 'a 'b))
(send-message p get-car) ⇒ a
(send-message p get-cdr) ⇒ b
(send-message p accesses) ⇒ 2
(send-message p get-cdr) ⇒ b
(send-message p accesses) ⇒ 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation of <code>define-object</code> is straightforward. The object definition is transformed into a definition of the object creation procedure. This procedure is the value of a <code>lambda</code> expression whose arguments are those specified in the definition. The body of the <code>lambda</code> consists of a <code>let*</code> expression to bind the local variables and a <code>letrec</code> expression to bind the message names to the action procedures. The body of the <code>letrec</code> is another <code>lambda</code> expression whose value represents the new object. The body of this <code>lambda</code> expression compares the messages passed in with the expected messages using a <code>case</code> expression and applies the corresponding action procedure to the remaining arguments.</p>
</div>
<div class="paragraph">
<p>For example, the definition</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-object (kons kar kdr)
  ((count 0))
  ((get-car
    (lambda ()
      (set! count (+ count 1))
      kar))
   (get-cdr
    (lambda ()
      (set! count (+ count 1))
      kdr))
   (accesses
    (lambda () count))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>is transformed into</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define kons
  (lambda (kar kdr)
    (let* ([count 0])
      (letrec ([get-car
                (lambda ()
                  (set! count (+ count 1)) kar)]
               [get-cdr
                (lambda ()
                  (set! count (+ count 1)) kdr)]
               [accesses (lambda () count)])
        (lambda (msg . args)
          (case msg
            [(get-car) (apply get-car args)]
            [(get-cdr) (apply get-cdr args)]
            [(accesses) (apply accesses args)]
            [else (assertion-violation 'kons
                    "invalid message"
                    (cons msg args))]))))))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (tspl oop)
  (export define-object send-message)
  (import (rnrs))

 ; define-object creates an object constructor that uses let* to bind
 ; local fields and letrec to define the exported procedures.  An
 ; object is itself a procedure that accepts messages corresponding
 ; to the names of the exported procedures.  The second pattern is
 ; used to allow the set of local fields to be omitted.
  (define-syntax define-object
    (syntax-rules ()
      [(_ (name . varlist)
          ((var1 val1) ...)
          ((var2 val2) ...))
       (define name
         (lambda varlist
           (let* ([var1 val1] ...)
             (letrec ([var2 val2] ...)
               (lambda (msg . args)
                 (case msg
                   [(var2) (apply var2 args)]
                   ...
                   [else
                    (assertion-violation 'name
                      "invalid message"
                      (cons msg args))]))))))]
      [(_ (name . varlist) ((var2 val2) ...))
       (define-object (name . varlist)
                      ()
                      ((var2 val2) ...))]))

 ; send-message abstracts the act of sending a message from the act
 ; of applying a procedure and allows the message to be unquoted.
  (define-syntax send-message
    (syntax-rules ()
      [(_ obj msg arg ...)
       (obj 'msg arg ...)])))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.8.1">Exercise 12.8.1</h4>
<div class="paragraph">
<p>Use <code>define-object</code> to define the <code>stack</code> object type from <a href="#section_2.9.">Section 2.9</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.8.2">Exercise 12.8.2</h4>
<div class="paragraph">
<p>Use <code>define-object</code> to define a <code>queue</code> object type with operations similar to those described in <a href="#section_2.9.">Section 2.9</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.8.3">Exercise 12.8.3</h4>
<div class="paragraph">
<p>It is often useful to describe one object in terms of another. For example, the second <code>kons</code> object type could be described as the same as the first but with a password argument and different actions associated with the <code>set-car!</code> and <code>set-cdr!</code> messages. This is called <em>inheritance</em>; the new type of object is said to <em>inherit</em> attributes from the first. Modify <code>define-object</code> to support inheritance by allowing the optional declaration <code>(inherit object-name)</code> to appear after the message/action pairs. This will require saving some information about each object definition for possible use in subsequent object definitions. Conflicting argument names should be disallowed, but other conflicts should be resolved by using the initialization or action specified in the new object definition.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.8.4">Exercise 12.8.4</h4>
<div class="paragraph">
<p>Based on the definition of <code>method</code> on <a href="#defn:method">page 317</a>, define a complete object system, but use records rather than vectors to represent object instances. If done well, the resulting object system should be more efficient and easier to use than the system given above.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_12.9.">Section 12.9. Fast Fourier Transform</h3>
<div class="paragraph">
<p>The procedure described in this section uses Scheme&#8217;s complex arithmetic to compute the discrete <em>Fourier transform</em> (DFT) of a sequence of values <a href="#ref4">[4]</a>. Discrete Fourier transforms are used to analyze and process sampled signal sequences in a wide variety of digital electronics applications such as pattern recognition, bandwidth compression, radar target detection, and weather surveillance.</p>
</div>
<div class="paragraph">
<p>The DFT of a sequence of \(N\) input values,</p>
</div>
<div class="stemblock">
<div class="content">
\[\{x(n)\}_{n=0}^{N-1}\]
</div>
</div>
<div class="paragraph">
<p>is the sequence of \(N\) output values,</p>
</div>
<div class="stemblock">
<div class="content">
\[\{X(m)\}_{m=0}^{N-1}\]
</div>
</div>
<div class="paragraph">
<p>each defined by the equation</p>
</div>
<div class="stemblock">
<div class="content">
\[X(m) = \sum_{n=0}^{N-1}x(n)e^{-i \frac{2πmn}{N}}\]
</div>
</div>
<div class="paragraph">
<p>It is convenient to abstract away the constant amount (for given \(N\))</p>
</div>
<div class="stemblock">
<div class="content">
\[W_N = e^{-i \frac{2π}{N}}\]
</div>
</div>
<div class="paragraph">
<p>in order to obtain the more concise but equivalent equation</p>
</div>
<div class="stemblock">
<div class="content">
\[X(m) = \sum_{n=0}^{N-1}x(n)W_N^{mn}\]
</div>
</div>
<div class="paragraph">
<p>A straightforward computation of the \(N\) output values, each as a sum of \(N\) intermediate values, requires on the order of \(N^2\) operations. A <em>fast</em> Fourier transform (FFT), applicable when \(N\) is a power of 2, requires only on the order of \(N\log_2N\) operations. Although usually presented as a rather complicated iterative algorithm, the fast Fourier transform is most concisely and elegantly expressed as a recursive algorithm.</p>
</div>
<div class="paragraph">
<p>The recursive algorithm, which is due to Sam Daniel <a href="#ref7">[7]</a>, can be derived by manipulating the preceding summation as follows. We first split the summation into two summations and recombine them into one summation from 0 to \(N/2 - 1\).</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align}
X(m) &amp;= \sum_{n=0}^{N/2-1}x(n)W_N^{mn} + \sum_{n=N/2}^{N-1}x(n)W_N^{mn} \\
     &amp;= \sum_{n=0}^{N/2-1} [ x(n)W_N^{mn} + x(n + N/2)W_N^{m(n+N/2)} ]
\end{align}\]
</div>
</div>
<div class="paragraph">
<p>We then pull out the common factor \(W_N^{mn}\).</p>
</div>
<div class="stemblock">
<div class="content">
\[X(m) = \sum_{n=0}^{N/2-1} [ x(n) + x(n + N/2)W_N^{m(N/2)} ] W_N^{mn}\]
</div>
</div>
<div class="paragraph">
<p>We can reduce \(W_N^{m(N/2)}\) to 1 when \(m\) is even and -1 when \(m\) is odd, since</p>
</div>
<div class="stemblock">
<div class="content">
\[W_N^{m(N/2)} = W_2^m = e^{-iπm} = \begin{cases}
1,  &amp; \text{$m$ even} \\
-1, &amp; \text{$m$ odd}
\end{cases}\]
</div>
</div>
<div class="paragraph">
<p>This allows us to specialize the summation for the even and odd cases of \(m = 2k\) and \(m = 2k + 1\), \(0 ≤ k ≤ N/2 - 1\).</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align}
X(2k) &amp;= \sum_{n=0}^{N/2-1} [ x(n) + x(n + N/2) ] W_N^{2kn} \\
      &amp;= \sum_{n=0}^{N/2-1} [ x(n) + x(n + N/2) ] W_{N/2}^{kn}
\end{align}\]
</div>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align}
X(2k+1) &amp;= \sum_{n=0}^{N/2-1} [ x(n) - x(n + N/2) ] W_N^{(2k+1)n} \\
        &amp;= \sum_{n=0}^{N/2-1} [ x(n) - x(n + N/2) ] W_N^n W_{N/2}^{kn}
\end{align}\]
</div>
</div>
<div class="paragraph">
<p>The resulting summations are DFTs of the <em>N</em>/2-element sequences</p>
</div>
<div class="stemblock">
<div class="content">
\[\{ x(n) + x(n + N/2) \}_{n=0}^{N/2-1}\]
</div>
</div>
<div class="paragraph">
<p>and</p>
</div>
<div class="stemblock">
<div class="content">
\[\{ [x(n) - x(n + N/2)] W_N^n \}_{n=0}^{N/2-1}\]
</div>
</div>
<div class="paragraph">
<p>Thus, the DFT of an N-element sequence can be computed recursively by interlacing the DFTs of two <em>N</em>/2-element sequences. If we select a base case of two elements, we can describe a recursive fast Fourier transformation (RFFT) algorithm as follows. For \(N = 2\),</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align}
RFFT\{ x(n) \}_{n=0}^{1} &amp;= \{ X(m) \}_{m=0}^{1} \\
                         &amp;= \{ x(0) + x(1), [ x(0) - x(1) ] W_2^0 \} \\
                         &amp;= \{ x(0) + x(1), x(0) - x(1) \}
\end{align}\]
</div>
</div>
<div class="paragraph">
<p>since \(W_2^0 = e^0 = 1\). For \(N &gt; 2\),</p>
</div>
<div class="stemblock">
<div class="content">
\[\begin{align}
RFFT\{ x(n) \}_{n=0}^{N-1} &amp;= \{ X(m) \}_{n=0}^{N-1} \\
                           &amp;= \begin{cases}
                                RFFT\{ x(n) + x(n + N/2) \}_{n=0}^{N/2-1},  &amp; \text{$m$ even} \\
                                RFFT\{ (x(n) + x(n + N/2)) W_N^n \}_{n=0}^{N/2-1}, &amp; \text{$m$ odd}
                                \end{cases}
\end{align}\]
</div>
</div>
<div class="paragraph">
<p>with the attendant interlacing of even and odd components.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/45.gif" alt="45">
</div>
</div>
<div class="paragraph">
<p>The diagram above is adapted from one by Sam Daniel <a href="#ref7">[7]</a> and shows the computational structure of the RFFT algorithm. The first stage computes pairwise sums and differences of the first and second halves of the input; this stage is labeled the <em>butterfly</em> stage. The second stage recurs on the resulting subsequences. The third stage interlaces the output of the two recursive calls to RFFT, thus yielding the properly ordered sequence \(\{X(m)\}_{m=0}^{N-1}\).</p>
</div>
<div class="paragraph">
<p>The procedure <code>dft</code> accepts a sequence (list) of values, <code>x</code>, the length of which is assumed to be a power of 2. <code>dft</code> precomputes a sequence of powers of \(W_N\), \(\{W_N^n\}_{n=0}^{N/2-1}\), and calls <code>rfft</code> to initiate the recursion. <code>rfft</code> follows the algorithm outlined above.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define (dft x)
  (define (w-powers n)
    (let ([pi (* (acos 0.0) 2)])
      (let ([delta (/ (* -2.0i pi) n)])
        (let f ([n n] [x 0.0])
          (if (= n 0)
              '()
              (cons (exp x) (f (- n 2) (+ x delta))))))))
  (define (evens w)
    (if (null? w)
        '()
        (cons (car w) (evens (cddr w)))))
  (define (interlace x y)
    (if (null? x)
        '()
        (cons (car x) (cons (car y) (interlace (cdr x) (cdr y))))))
  (define (split ls)
    (let split ([fast ls] [slow ls])
      (if (null? fast)
          (values '() slow)
          (let-values ([(front back) (split (cddr fast) (cdr slow))])
            (values (cons (car slow) front) back)))))
  (define (butterfly x w)
    (let-values ([(front back) (split x)])
      (values
        (map + front back)
        (map * (map - front back) w))))
  (define (rfft x w)
    (if (null? (cddr x))
        (let ([x0 (car x)] [x1 (cadr x)])
          (list (+ x0 x1) (- x0 x1)))
        (let-values ([(front back) (butterfly x w)])
          (let ([w (evens w)])
            (interlace (rfft front w) (rfft back w))))))
  (rfft x (w-powers (length x))))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.9.1">Exercise 12.9.1</h4>
<div class="paragraph">
<p>Alter the algorithm to employ a base case of four points. What simplifications can be made to avoid multiplying any of the base case outputs by elements of <code>w</code>?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.9.2">Exercise 12.9.2</h4>
<div class="paragraph">
<p>Recode <code>dft</code> to accept a vector rather than a list as input, and have it produce a vector as output. Use lists internally if necessary, but do not simply convert the input to a list on entry and the output to a vector on exit.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.9.3">Exercise 12.9.3</h4>
<div class="paragraph">
<p>Rather than recomputing the powers of <code>w</code> on each step for a new number of points, the code simply uses the even-numbered elements of the preceding list of powers. Show that doing so yields the proper list of powers. That is, show that <code>(evens (w-powers n))</code> is equal to <code>(w-powers (/ n 2))</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.9.4">Exercise 12.9.4</h4>
<div class="paragraph">
<p>The recursion step creates several intermediate lists that are immediately discarded. Recode the recursion step to avoid any unnecessary allocation.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.9.5">Exercise 12.9.5</h4>
<div class="paragraph">
<p>Each element of a sequence of input values may be regenerated from the discrete Fourier transform of the sequence via the equation</p>
</div>
<div class="stemblock">
<div class="content">
\[x(n) = \frac{1}{N} \sum_{m=0}^{N-1} X(m) e^{ i \frac{2πmn}{N} }\]
</div>
</div>
<div class="paragraph">
<p>Noting the similarity between this equation and the original equation defining <em>X</em>(<em>m</em>), create a modified version of <code>dft</code>, <code>inverse-dft</code>, that performs the inverse transformation. Verify that <code>(inverse-dft (dft <em>seq</em>))</code> returns <code><em>seq</em></code> for several input sequences <code><em>seq</em></code>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_12.10.">Section 12.10. A Unification Algorithm</h3>
<div class="paragraph">
<p><em>Unification</em> <a href="#ref23">[23]</a> is a pattern-matching technique used in automated theorem proving, type-inference systems, computer algebra, and logic programming, e.g., Prolog <a href="#ref6">[6]</a>.</p>
</div>
<div class="paragraph">
<p>A unification algorithm attempts to make two symbolic expressions equal by computing a unifying substitution for the expressions. A <em>substitution</em> is a function that replaces variables with other expressions. A substitution must treat all occurrences of a variable the same way, e.g., if it replaces one occurrence of the variable <em>x</em> by <em>a</em>, it must replace all occurrences of <em>x</em> by <em>a</em>. A unifying substitution, or <em>unifier</em>, for two expressions <em>e</em><sub>1</sub> and <em>e</em><sub>2</sub> is a substitution, \(\sigma\), such that \(\sigma(e_1) = \sigma(e_2)\).</p>
</div>
<div class="paragraph">
<p>For example, the two expressions <em>f</em>(<em>x</em>) and <em>f</em>(<em>y</em>) can be unified by substituting <em>x</em> for <em>y</em> (or <em>y</em> for <em>x</em>). In this case, the unifier \(\sigma\) could be described as the function that replaces <em>y</em> with <em>x</em> and leaves other variables unchanged. On the other hand, the two expressions <em>x</em> + 1 and <em>y</em> + 2 cannot be unified. It might appear that substituting 3 for <em>x</em> and 2 for <em>y</em> would make both expressions equal to 4 and hence equal to each other. The symbolic expressions, 3 + 1 and 2 + 2, however, still differ.</p>
</div>
<div class="paragraph">
<p>Two expressions may have more than one unifier. For example, the expressions <em>f</em>(<em>x</em>,<em>y</em>) and <em>f</em>(1,<em>y</em>) can be unified to <em>f</em>(1,<em>y</em>) with the substitution of 1 for <em>x</em>. They may also be unified to <em>f</em>(1,5) with the substitution of 1 for <em>x</em> and 5 for <em>y</em>. The first substitution is preferable, since it does not commit to the unnecessary replacement of <em>y</em>. Unification algorithms typically produce the <em>most general unifier</em>, or <em>mgu</em>, for two expressions. The mgu for two expressions makes no unnecessary substitutions; all other unifiers for the expressions are special cases of the mgu. In the example above, the first substitution is the mgu and the second is a special case.</p>
</div>
<div class="paragraph">
<p>For the purposes of this program, a symbolic expression can be a variable, a constant, or a function application. Variables are represented by Scheme symbols, e.g., <code>x</code>; a function application is represented by a list with the function name in the first position and its arguments in the remaining positions, e.g., <code>(f x)</code>; and constants are represented by zero-argument functions, e.g., <code>(a)</code>.</p>
</div>
<div class="paragraph">
<p>The algorithm presented here finds the mgu for two terms, if it exists, using a continuation-passing style, or CPS (see <a href="#section_3.4.">Section 3.4</a>), approach to recursion on subterms. The procedure <code>unify</code> takes two terms and passes them to a help procedure, <code>uni</code>, along with an initial (identity) substitution, a success continuation, and a failure continuation. The success continuation returns the result of applying its argument, a substitution, to one of the terms, i.e., the unified result. The failure continuation simply returns its argument, a message. Because control passes by explicit continuation within <code>unify</code> (always with tail calls), a return from the success or failure continuation is a return from <code>unify</code> itself.</p>
</div>
<div class="paragraph">
<p>Substitutions are procedures. Whenever a variable is to be replaced by another term, a new substitution is formed from the variable, the term, and the existing substitution. Given a term as an argument, the new substitution replaces occurrences of its saved variable with its saved term in the result of invoking the saved substitution on the argument expression. Intuitively, a substitution is a chain of procedures, one for each variable in the substitution. The chain is terminated by the initial, identity substitution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(unify 'x 'y) ⇒ y
(unify '(f x y) '(g x y)) ⇒ "clash"
(unify '(f x (h)) '(f (h) y)) ⇒ (f (h) (h))
(unify '(f (g x) y) '(f y x)) ⇒ "cycle"
(unify '(f (g x) y) '(f y (g x))) ⇒ (f (g x) (g x))
(unify '(f (g x) y) '(f y z)) ⇒ (f (g x) (g x))</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (tspl unification)
  (export unify)
  (import (rnrs))

 ; occurs? returns true if and only if u occurs in v
  (define occurs?
    (lambda (u v)
      (and (pair? v)
           (let f ([l (cdr v)])
             (and (pair? l)
                  (or (eq? u (car l))
                      (occurs? u (car l))
                      (f (cdr l))))))))

 ; sigma returns a new substitution procedure extending s by
 ; the substitution of u with v
  (define sigma
    (lambda (u v s)
      (lambda (x)
        (let f ([x (s x)])
          (if (symbol? x)
              (if (eq? x u) v x)
              (cons (car x) (map f (cdr x))))))))

 ; try-subst tries to substitute u for v but may require a
 ; full unification if (s u) is not a variable, and it may
 ; fail if it sees that u occurs in v.
  (define try-subst
    (lambda (u v s ks kf)
      (let ([u (s u)])
        (if (not (symbol? u))
            (uni u v s ks kf)
            (let ([v (s v)])
              (cond
                [(eq? u v) (ks s)]
                [(occurs? u v) (kf "cycle")]
                [else (ks (sigma u v s))]))))))

 ; uni attempts to unify u and v with a continuation-passing
 ; style that returns a substitution to the success argument
 ; ks or an error message to the failure argument kf.  The
 ; substitution itself is represented by a procedure from
 ; variables to terms.
  (define uni
    (lambda (u v s ks kf)

      (cond
        [(symbol? u) (try-subst u v s ks kf)]
        [(symbol? v) (try-subst v u s ks kf)]
        [(and (eq? (car u) (car v))
              (= (length u) (length v)))
         (let f ([u (cdr u)] [v (cdr v)] [s s])
           (if (null? u)
               (ks s)
               (uni (car u)
                    (car v)
                    s
                    (lambda (s) (f (cdr u) (cdr v) s))
                    kf)))]
        [else (kf "clash")])))

 ; unify shows one possible interface to uni, where the initial
 ; substitution is the identity procedure, the initial success
 ; continuation returns the unified term, and the initial failure
 ; continuation returns the error message.
  (define unify
    (lambda (u v)
      (uni u
           v
           (lambda (x) x)
           (lambda (s) (s u))
           (lambda (msg) msg)))))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.10.1">Exercise 12.10.1</h4>
<div class="paragraph">
<p>Modify <code>unify</code> so that it returns its substitution rather than the unified term. Apply this substitution to both input terms to verify that it returns the same result for each.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.10.2">Exercise 12.10.2</h4>
<div class="paragraph">
<p>As mentioned above, substitutions on a term are performed sequentially, requiring one entire pass through the input expression for each substituted variable. Represent the substitution differently so that only one pass through the expression need be made. Make sure that substitutions are performed not only on the input expression but also on any expressions you insert during substitution.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.10.3">Exercise 12.10.3</h4>
<div class="paragraph">
<p>Extend the continuation-passing style unification algorithm into an entire continuation-passing style logic programming system.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="section_12.11.">Section 12.11. Multitasking with Engines</h3>
<div class="paragraph">
<p>Engines are a high-level process abstraction supporting <em>timed preemption</em> (<a href="#ref10">[10]</a>,<a href="#ref15">[15]</a>). Engines may be used to simulate multiprocessing, implement light-weight threads, implement operating system kernels, and perform nondeterministic computations. The engine implementation is one of the more interesting applications of continuations in Scheme.</p>
</div>
<div class="paragraph">
<p>An engine is created by passing a thunk (procedure of no arguments) to the procedure <code>make-engine</code>. The body of the thunk is the computation to be performed by the engine. An engine itself is a procedure of three arguments:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code><em>ticks</em></code>, a positive integer that specifies the amount of <em>fuel</em> to be given to the engine. An engine executes until this fuel runs out or until its computation finishes.</p>
</li>
<li>
<p><code><em>complete</em></code>, a procedure of two arguments that specifies what to do if the computation finishes. Its arguments will be the amount of fuel left over and the result of the computation.</p>
</li>
<li>
<p><code><em>expire</em></code>, a procedure of one argument that specifies what to do if the fuel runs out before the computation finishes. Its argument will be a new engine capable of continuing the computation from the point of interruption.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>When an engine is applied to its arguments, it sets up a timer to fire in <code><em>ticks</em></code> time units. If the engine computation completes before the timer goes off, the system invokes <code><em>complete</em></code>, passing it the number of <code><em>ticks</em></code> left over and the value of the computation. If, on the other hand, the timer goes off before the engine computation completes, the system creates a new engine from the continuation of the interrupted computation and passes this engine to <code><em>expire</em></code>. <code><em>complete</em></code> and <code><em>expire</em></code> are invoked in the continuation of the engine invocation.</p>
</div>
<div class="paragraph">
<p>The following example creates an engine from a trivial computation, 3, and gives the engine 10 ticks.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define eng
  (make-engine
    (lambda () 3)))

(eng 10
  (lambda (ticks value) value)
  (lambda (x) x)) ⇒ 3</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is often useful to pass <code>list</code> as the <code><em>complete</em></code> procedure to an engine, causing the engine to return a list of the ticks remaining and the value if the computation completes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(eng 10
  list
  (lambda (x) x)) ⇒ (9 3)</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, the value was 3 and there were 9 ticks left over, i.e., it took only one unit of fuel to evaluate 3. (The fuel amounts given here are for illustration only. The actual amount may differ.)</p>
</div>
<div class="paragraph">
<p>Typically, the engine computation does not finish in one try. The following example displays the use of an engine to compute the 10th Fibonacci number (see <a href="#section_3.2.">Section 3.2</a>) in steps.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define fibonacci
  (lambda (n)
    (if (< n 2)
        n
        (+ (fibonacci (- n 1))
           (fibonacci (- n 2))))))

(define eng
  (make-engine
    (lambda ()
      (fibonacci 10))))

(eng 50
  list
  (lambda (new-eng)
    (set! eng new-eng)
    "expired")) ⇒ "expired"

(eng 50
  list
  (lambda (new-eng)
    (set! eng new-eng)
    "expired")) ⇒ "expired"

(eng 50
  list
  (lambda (new-eng)
    (set! eng new-eng)
    "expired")) ⇒ "expired"

(eng 50
  list
  (lambda (new-eng)
    (set! eng new-eng)
    "expired")) ⇒ (22 55)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each time the engine&#8217;s fuel ran out, the <code><em>expire</em></code> procedure assigned <code>eng</code> to the new engine. The entire computation required four allotments of 50 ticks to complete; of the last 50 it used all but 23. Thus, the total amount of fuel used was 177 ticks. This leads us to the following procedure, <code>mileage</code>, which uses engines to "time" a computation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define mileage
  (lambda (thunk)
    (let loop ([eng (make-engine thunk)] [total-ticks 0])
      (eng 50
        (lambda (ticks value)
          (+ total-ticks (- 50 ticks)))
        (lambda (new-eng)
          (loop new-eng (+ total-ticks 50)))))))

(mileage (lambda () (fibonacci 10))) ⇒ 178</code></pre>
</div>
</div>
<div class="paragraph">
<p>The choice of 50 for the number of ticks to use each time is arbitrary, of course. It might make more sense to pass a much larger number, say 10000, in order to reduce the number of times the computation is interrupted.</p>
</div>
<div class="paragraph">
<p>The next procedure, <code>round-robin</code>, could be the basis for a simple time-sharing operating system. <code>round-robin</code> maintains a queue of processes (a list of engines) and cycles through the queue in a <em>round-robin</em> fashion, allowing each process to run for a set amount of time. <code>round-robin</code> returns a list of the values returned by the engine computations in the order that the computations complete.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define round-robin
  (lambda (engs)
    (if (null? engs)
        '()
        ((car engs) 1
          (lambda (ticks value)
            (cons value (round-robin (cdr engs))))
          (lambda (eng)
            (round-robin
              (append (cdr engs) (list eng))))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Assuming the amount of computation corresponding to one tick is constant, the effect of <code>round-robin</code> is to return a list of the values sorted from the quickest to complete to the slowest to complete. Thus, when we call <code>round-robin</code> on a list of engines, each computing one of the Fibonacci numbers, the output list is sorted with the earlier Fibonacci numbers first, regardless of the order of the input list.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(round-robin
  (map (lambda (x)
         (make-engine
           (lambda ()
              (fibonacci x))))
       '(4 5 2 8 3 7 6 2))) ⇒ (1 1 2 3 5 8 13 21)</code></pre>
</div>
</div>
<div class="paragraph">
<p>More interesting things could happen if the amount of fuel varied each time through the loop. In this case, the computation would be nondeterministic, i.e., the results would vary from call to call.</p>
</div>
<div class="paragraph">
<p>The following syntactic form, <code>por</code> (parallel-or), returns the first of its expressions to complete with a true value. <code>por</code> is implemented with the procedure <code>first-true</code>, which is similar to <code>round-robin</code> but quits when any of the engines completes with a true value. If all of the engines complete, but none with a true value, <code>first-true</code> (and hence <code>por</code>) returns <code>#f</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax por
  (syntax-rules ()
    [(_ x ...)
     (first-true
       (list (make-engine (lambda () x)) ...))]))

(define first-true
  (lambda (engs)
    (if (null? engs)
        #f
        ((car engs) 1
          (lambda (ticks value)
            (or value (first-true (cdr engs))))
          (lambda (eng)
            (first-true
              (append (cdr engs) (list eng))))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Even if one of the expressions is an infinite loop, <code>por</code> can still finish (as long as one of the other expressions completes and returns a true value).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(por 1 2) ⇒ 1
(por ((lambda (x) (x x)) (lambda (x) (x x)))
     (fibonacci 10)) ⇒ 55</code></pre>
</div>
</div>
<div class="paragraph">
<p>The first subexpression of the second <code>por</code> expression is nonterminating, so the answer is the value of the second subexpression.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s turn to the implementation of engines. Any preemptive multitasking primitive must have the ability to interrupt a running process after a given amount of computation. This ability is provided by a primitive timer interrupt mechanism in some Scheme implementations. We will construct a suitable one here.</p>
</div>
<div class="paragraph">
<p>Our timer system defines three procedures: <code>start-timer</code>, <code>stop-timer</code>, and <code>decrement-timer</code>, which can be described operationally as follows.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>(start-timer <em>ticks</em> <em>handler</em>)</code> sets the timer to <code><em>ticks</em></code> and installs <code><em>handler</em></code> as the procedure to be invoked (without arguments) when the timer expires, i.e., reaches zero.</p>
</li>
<li>
<p><code>(stop-timer)</code> resets the timer and returns the number of ticks remaining.</p>
</li>
<li>
<p><code>(decrement-timer)</code> decrements the timer by one tick if the timer is on, i.e., if it is not zero. When the timer reaches zero, <code>decrement-timer</code> invokes the saved handler. If the timer has already reached zero, <code>decrement-timer</code> returns without changing the timer.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Code to implement these procedures is given along with the engine implementation below.</p>
</div>
<div class="paragraph">
<p>Using the timer system requires inserting calls to <code>decrement-timer</code> in appropriate places. Consuming a timer tick on entry to a procedure usually provides a sufficient level of granularity. This can be accomplished by using <code>timed-lambda</code> as defined below in place of <code>lambda</code>. <code>timed-lambda</code> simply invokes <code>decrement-timer</code> before executing the expressions in its body.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax timed-lambda
  (syntax-rules ()
    [(_ formals exp1 exp2 ...)
     (lambda formals (decrement-timer) exp1 exp2 ...)]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>It may be useful to redefine named <code>let</code> and <code>do</code> to use <code>timed-lambda</code> as well, so that recursions expressed with these constructs are timed. If you use this mechanism, do not forget to use the timed versions of <code>lambda</code> and other forms in code run within an engine, or no ticks will be consumed.</p>
</div>
<div class="paragraph">
<p>Now that we have a suitable timer, we can implement engines in terms of the timer and continuations. We use <code>call/cc</code> in two places in the engine implementation: (1) to obtain the continuation of the computation that invokes the engine so that we can return to that continuation when the engine computation completes or the timer expires, and (2) to obtain the continuation of the engine computation when the timer expires so that we can return to this computation if the newly created engine is subsequently run.</p>
</div>
<div class="paragraph">
<p>The state of the engine system is contained in two variables local to the engine system: <code>do-complete</code> and <code>do-expire</code>. When an engine is started, the engine assigns to <code>do-complete</code> and <code>do-expire</code> procedures that, when invoked, return to the continuation of the engine&#8217;s caller to invoke <code><em>complete</em></code> or <code><em>expire</em></code>. The engine starts (or restarts) the computation by invoking the procedure passed as an argument to <code>make-engine</code> with the specified number of ticks. The ticks and the local procedure <code>timer-handler</code> are then used to start the timer.</p>
</div>
<div class="paragraph">
<p>Suppose that the timer expires before the engine computation completes. The procedure <code>timer-handler</code> is then invoked. It initiates a call to <code>start-timer</code> but obtains the ticks by calling <code>call/cc</code> with <code>do-expire</code>. Consequently, <code>do-expire</code> is called with a continuation that, if invoked, will restart the timer and continue the interrupted computation. <code>do-expire</code> creates a new engine from this continuation and arranges for the engine&#8217;s <code><em>expire</em></code> procedure to be invoked with the new engine in the correct continuation.</p>
</div>
<div class="paragraph">
<p>If, on the other hand, the engine computation completes before the timer expires, the timer is stopped and the number of ticks remaining is passed along with the value to <code>do-complete</code>; <code>do-complete</code> arranges for the engine&#8217;s <code><em>complete</em></code> procedure to be invoked with the ticks and value in the correct continuation.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s discuss a couple of subtle aspects to this code. The first concerns the method used to start the timer when an engine is invoked. The code would apparently be simplified by letting <code>new-engine</code> start the timer before it initiates or resumes the engine computation, instead of passing the ticks to the computation and letting it start the timer. Starting the timer within the computation, however, prevents ticks from being consumed prematurely. If the engine system itself consumes fuel, then an engine provided with a small amount of fuel may not progress toward completion. (It may, in fact, make negative progress.) If the software timer described above is used, this problem is actually avoided by compiling the engine-making code with the untimed version of <code>lambda</code>.</p>
</div>
<div class="paragraph">
<p>The second subtlety concerns the procedures created by <code>do-complete</code> and <code>do-expire</code> and subsequently applied by the continuation of the <code>call/cc</code> application. It may appear that <code>do-complete</code> could first invoke the engine&#8217;s <code><em>complete</em></code> procedure, then pass the result to the continuation (and similarly for <code>do-expire</code>) as follows.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(escape (complete value ticks))</code></pre>
</div>
</div>
<div class="paragraph">
<p>This would result in improper treatment of tail recursion, however. The problem is that the current continuation would not be replaced with the continuation stored in <code>escape</code> until the call to the <code>complete</code> procedure returns. Consequently, both the continuation of the running engine and the continuation of the engine invocation could be retained for an indefinite period of time, when in fact the actual engine invocation may appear to be tail-recursive. This is especially inappropriate because the engine interface encourages use of continuation-passing style and hence tail recursion. The round-robin scheduler and <code>first-true</code> provide good examples of this, since the <code><em>expire</em></code> procedure in each invokes engines tail-recursively.</p>
</div>
<div class="paragraph">
<p>We maintain proper treatment of tail recursion by arranging for <code>do-complete</code> and <code>do-expire</code> to escape from the continuation of the running engine before invoking the <code>complete</code> or <code>expire</code> procedures. Since the continuation of the engine invocation is a procedure application, passing it a procedure of no arguments results in application of the procedure in the continuation of the engine invocation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(library (tspl timer)
  (export start-timer stop-timer decrement-timer)
  (import (rnrs))

  (define clock 0)
  (define handler #f)

  (define start-timer
    (lambda (ticks new-handler)
      (set! handler new-handler)
      (set! clock ticks)))

  (define stop-timer
    (lambda ()
      (let ([time-left clock])
        (set! clock 0)
        time-left)))

  (define decrement-timer
    (lambda ()
      (when (> clock 0)
        (set! clock (- clock 1))
        (when (= clock 0) (handler)))))

  (define-syntax timed-lambda
    (syntax-rules ()
      [(_ formals exp1 exp2 ...)
       (lambda formals (decrement-timer) exp1 exp2 ...)])))

(library (tspl engines)
  (export make-engine timed-lambda)
  (import (rnrs) (tspl timer))

  (define make-engine
    (let ([do-complete #f] [do-expire #f])
      (define timer-handler
        (lambda ()
          (start-timer (call/cc do-expire) timer-handler)))
      (define new-engine
        (lambda (resume)
          (lambda (ticks complete expire)
            ((call/cc
               (lambda (escape)
                 (set! do-complete
                   (lambda (ticks value)
                     (escape (lambda () (complete ticks value)))))
                 (set! do-expire
                   (lambda (resume)
                     (escape (lambda ()
                               (expire (new-engine resume))))))
                 (resume ticks)))))))
      (lambda (proc)
        (new-engine
          (lambda (ticks)
            (start-timer ticks timer-handler)
            (let ([value (proc)])
              (let ([ticks (stop-timer)])
                (do-complete ticks value))))))))

  (define-syntax timed-lambda
    (syntax-rules ()
      [(_ formals exp1 exp2 ...)
       (lambda formals (decrement-timer) exp1 exp2 ...)])))</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.11.1">Exercise 12.11.1</h4>
<div class="paragraph">
<p>If your Scheme implementation allows definition and import of libraries in the interactive top level, try defining the libraries above, then type</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(import (rename (tspl engines) (timed-lambda lambda)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>to define <code>make-engine</code> and redefine <code>lambda</code>. Then try out the examples given earlier in this section.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.11.2">Exercise 12.11.2</h4>
<div class="paragraph">
<p>It may appear that the nested <code>let</code> expressions in the body of <code>make-engine</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([value (proc)])
  (let ([ticks (stop-timer)])
    (do-complete ticks value)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>could be replaced with the following.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([value (proc)] [ticks (stop-timer)])
  (do-complete value ticks))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Why is this not correct?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.11.3">Exercise 12.11.3</h4>
<div class="paragraph">
<p>It would also be incorrect to replace the nested <code>let</code> expressions discussed in the preceding exercise with the following.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([value (proc)])
  (do-complete value (stop-timer)))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Why?</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.11.4">Exercise 12.11.4</h4>
<div class="paragraph">
<p>Modify the engine implementation to provide a procedure, <code>engine-return</code>, that returns immediately from an engine.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.11.5">Exercise 12.11.5</h4>
<div class="paragraph">
<p>Implement the kernel of a small operating system using engines for processes. Processes should request services (such as reading input from the user) by evaluating an expression of the form <code>(trap 'request)</code>. Use <code>call/cc</code> and <code>engine-return</code> from the preceding exercise to implement <code>trap</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.11.6">Exercise 12.11.6</h4>
<div class="paragraph">
<p>Write the same operating-system kernel without using engines, building instead from continuations and timer interrupts.</p>
</div>
</div>
<div class="sect3">
<h4 id="exercise_12.11.7">Exercise 12.11.7</h4>
<div class="paragraph">
<p>This implementation of engines does not allow one engine to call another, i.e., nested engines <a href="#ref10">[10]</a>. Modify the implementation to allow nested engines.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="ref1"></a>[1] Michael Adams and R. Kent Dybvig. Efficient nondestructive equality checking for trees and graphs. In <em>Proceedings of the 13th ACM SIGPLAN International Conference on Functional Programming</em>, 179-188, September 2008.</p>
</li>
<li>
<p><a id="ref2"></a>[2] J. Michael Ashley and R. Kent Dybvig. An efficient implementation of multiple return values in Scheme. In <em>Proceedings of the 1994 ACM Conference on Lisp and Functional Programming</em>, 140-149, June 1994.</p>
</li>
<li>
<p><a id="ref3"></a>[3] Alan Bawden. Quasiquotation in lisp. In <em>Partial Evaluation and Semantic-Based Program Manipulation</em>, 88-99, 1999.</p>
</li>
<li>
<p><a id="ref4"></a>[4] William Briggs and Van Emden Henson. <em>The DFT: An Owner&#8217;s Manual for the Discrete Fourier Transform</em>. Society for Industrial and Applied Mathematics, Philadelphia, PA, 1995.</p>
</li>
<li>
<p><a id="ref5"></a>[5] Robert G. Burger and R. Kent Dybvig. Printing floating-point numbers quickly and accurately. In <em>Proceedings of the ACM SIGPLAN '96 Conference on Programming Language Design and Implementation</em>, 108-116, May 1996.</p>
</li>
<li>
<p><a id="ref6"></a>[6] William F. Clocksin and Christopher S. Mellish. <em>Programming in Prolog</em>, second edition. Springer-Verlag, Berlin, 1984.</p>
</li>
<li>
<p><a id="ref7"></a>[7] Sam M. Daniel. Efficient recursive FFT implementation in Prolog. In <em>Proceedings of the Second International Conference on the Practical Application of Prolog</em>, 175-185, 1994.</p>
</li>
<li>
<p><a id="ref8"></a>[8] Mark Davis. Unicode Standard Annex #29: Text boundaries, 2006. <a href="http://www.unicode.org/reports/tr29/" class="bare">http://www.unicode.org/reports/tr29/</a>.</p>
</li>
<li>
<p><a id="ref9"></a>[9] R. Kent Dybvig. <em>Chez Scheme User&#8217;s Guide: Version 8</em>. Cadence Research Systems, 2009. <a href="http://www.scheme.com/csug8/" class="bare">http://www.scheme.com/csug8/</a>.</p>
</li>
<li>
<p><a id="ref10"></a>[10] R. Kent Dybvig and Robert Hieb. Engines from continuations. <em>Computer Languages</em>, 14(2):109-123, 1989.</p>
</li>
<li>
<p><a id="ref11"></a>[11] R. Kent Dybvig and Robert Hieb. A new approach to procedures with variable arity. <em>Lisp and Symbolic Computation</em>, 3(3):229-244, September 1990.</p>
</li>
<li>
<p><a id="ref12"></a>[12] R. Kent Dybvig, Robert Hieb, and Carl Bruggeman. Syntactic abstraction in Scheme. <em>Lisp and Symbolic Computation</em>, 5(4):295-326, 1993.</p>
</li>
<li>
<p><a id="ref13"></a>[13] Daniel P. Friedman and Matthias Felleisen. <em>The Little Schemer</em>, fourth edition. MIT Press, Cambridge, MA, 1996.</p>
</li>
<li>
<p><a id="ref14"></a>[14] Daniel P. Friedman, Christopher T. Haynes, and Eugene E. Kohlbecker. Programming with continuations. In P. Pepper, editor, <em>Program Transformation and Programming Environments</em>, 263-274. Springer-Verlag, New York, 1984.</p>
</li>
<li>
<p><a id="ref15"></a>[15] Christopher T. Haynes and Daniel P. Friedman. Abstracting timed preemption with engines. <em>Computer Languages</em>, 12(2):109-121, 1987.</p>
</li>
<li>
<p><a id="ref16"></a>[16] Christopher T. Haynes, Daniel P. Friedman, and Mitchell Wand. Obtaining coroutines with continuations. <em>Computer Languages</em>, 11(3/4):143-153, 1986.</p>
</li>
<li>
<p><a id="ref17"></a>[17] Robert Hieb, R. Kent Dybvig, and Carl Bruggeman. Representing control in the presence of first-class continuations. In <em>Proceedings of the SIGPLAN '90 Conference on Programming Language Design and Implementation</em>, 66-77, June 1990.</p>
</li>
<li>
<p><a id="ref18"></a>[18] IEEE Computer Society. <em>IEEE Standard for the Scheme Programming Language</em>, May 1991. IEEE Std 1178-1990.</p>
</li>
<li>
<p><a id="ref19"></a>[19] Brian W. Kernighan and Dennis M. Ritchie. <em>The C Programming Language</em>, second edition. Prentice Hall, Englewood Cliffs, NJ, 1988.</p>
</li>
<li>
<p><a id="ref20"></a>[20] P. Leach, M. Mealling, and R. Salz. A Universally Unique IDentifier (UUID) URN namespace, July 2005. RFC 4122. <a href="http://www.ietf.org/rfc/rfc4122.txt" class="bare">http://www.ietf.org/rfc/rfc4122.txt</a>.</p>
</li>
<li>
<p><a id="ref21"></a>[21] Peter Naur et al. Revised report on the algorithmic language ALGOL 60. <em>Communications of the ACM</em>, 6(1):1-17, January 1963.</p>
</li>
<li>
<p><a id="ref22"></a>[22] David A. Plaisted. Constructs for sets, quantifiers, and rewrite rules in Lisp. Technical Report UIUCDCS-R-84-1176, University of Illinois at Urbana-Champaign Department of Computer Science, June 1984.</p>
</li>
<li>
<p><a id="ref23"></a>[23] J. A. Robinson. A machine-oriented logic based on the resolution principle. <em>Journal of the ACM</em>, 12(1):23-41, 1965.</p>
</li>
<li>
<p><a id="ref24"></a>[24] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised<sup>6</sup> report on the algorithmic language Scheme, September 2007. <a href="http://www.r6rs.org/" class="bare">http://www.r6rs.org/</a>.</p>
</li>
<li>
<p><a id="ref25"></a>[25] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised<sup>6</sup> report on the algorithmic language Scheme---non-normative appendices, September 2007. <a href="http://www.r6rs.org/" class="bare">http://www.r6rs.org/</a>.</p>
</li>
<li>
<p><a id="ref26"></a>[26] Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton van Straaten (eds.). Revised<sup>6</sup> report on the algorithmic language Scheme---standard libraries, September 2007. <a href="http://www.r6rs.org/" class="bare">http://www.r6rs.org/</a>.</p>
</li>
<li>
<p><a id="ref27"></a>[27] Guy L. Steele Jr. <em>Common Lisp, the Language</em>, second edition. Digital Press, Bedford, Massachusetts, 1990.</p>
</li>
<li>
<p><a id="ref28"></a>[28] Guy L. Steele Jr. and Gerald J. Sussman. The revised report on Scheme, a dialect of Lisp. MIT AI Memo 452, Massachusetts Institute of Technology, January 1978.</p>
</li>
<li>
<p><a id="ref29"></a>[29] Gerald J. Sussman and Guy L. Steele Jr. Scheme: An interpreter for extended lambda calculus. <em>Higher-Order and Symbolic Computation</em>, 11(4):405-439, 1998. Reprinted from the AI Memo 349, MIT (1975), with a foreword.</p>
</li>
<li>
<p><a id="ref30"></a>[30] The Unicode Consortium. <em>The Unicode Standard, Version 5.0</em>, fifth edition. Addison-Wesley Professional, Boston, MA, 2006.</p>
</li>
<li>
<p><a id="ref31"></a>[31] Oscar Waddell, Dipanwita Sarkar, and R. Kent Dybvig. Fixing letrec: A faithful yet efficient implementation of Scheme&#8217;s recursive binding construct. <em>Higher-Order and Symbolic Computation</em>, 18(3/4):299-326, 2005.</p>
</li>
<li>
<p><a id="ref32"></a>[32] Mitchell Wand. Continuation-based multiprocessing. <em>Higher-Order and Symbolic Computation</em>, 12(3):285-299, 1999. Reprinted from the proceedings of the 1980 Lisp Conference, with a foreword.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="answers_to_selected_exercises">Answers to Selected Exercises</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.2.1">2.2.1</a>.</strong> (page <a href="#start:s35">20</a>)</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>(+ (* 1.2 (- 2 1/3)) -8.7)</code></p>
</li>
<li>
<p><code>(/ (+ 2/3 4/9) (- 5/11 4/3))</code></p>
</li>
<li>
<p><code>(+ 1 (/ 1 (+ 2 (/ 1 (+ 1 1/2)))))</code></p>
</li>
<li>
<p><code>(* (* (* (* (* (* 1 -2) 3) -4) 5) -6) 7)</code> or <code>(* 1 -2 3 -4 5 -6 7)</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.2.2">2.2.2</a>.</strong> (page <a href="#start:s35">20</a>)</p>
</div>
<div class="paragraph">
<p>See Section <a href="#section_6.4.">6.4</a>.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.2.3">2.2.3</a>.</strong> (page <a href="#start:s35">20</a>)</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>(car . cdr)</code></p>
</li>
<li>
<p><code>(this (is silly))</code></p>
</li>
<li>
<p><code>(is this silly?)</code></p>
</li>
<li>
<p><code>(+ 2 3)</code></p>
</li>
<li>
<p><code>(+ 2 3)</code></p>
</li>
<li>
<p><code>+</code></p>
</li>
<li>
<p><code>(2 3)</code></p>
</li>
<li>
<p><code>#&lt;procedure&gt;</code></p>
</li>
<li>
<p><code>cons</code></p>
</li>
<li>
<p><code>'cons</code></p>
</li>
<li>
<p><code>quote</code></p>
</li>
<li>
<p><code>5</code></p>
</li>
<li>
<p><code>5</code></p>
</li>
<li>
<p><code>5</code></p>
</li>
<li>
<p><code>5</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.2.4">2.2.4</a>.</strong> (page <a href="#start:s38">21</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(car (cdr (car '((a b) (c d))))) ⇒ b
(car (car (cdr '((a b) (c d))))) ⇒ c
(car (cdr (car (cdr '((a b) (c d)))))) ⇒ d</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.2.5">2.2.5</a>.</strong> (page <a href="#start:s38">21</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">'((a . b) ((c) d) ())</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.2.6">2.2.6</a>.</strong> (page <a href="#start:s38">21</a>)</p>
</div>
<div class="imageblock">
<div class="content">
<img src="images/50.gif" alt="50">
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.2.7">2.2.7</a>.</strong> (page <a href="#start:s38">21</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(car '((a b) (c d))) ⇒ (a b)
(car (car '((a b) (c d)))) ⇒ a
(cdr (car '((a b) (c d)))) ⇒ (b)
(car (cdr (car '((a b) (c d))))) ⇒ b
(cdr (cdr (car '((a b) (c d))))) ⇒ ()
(cdr '((a b) (c d))) ⇒ ((c d))
(car (cdr '((a b) (c d)))) ⇒ (c d)
(car (car (cdr '((a b) (c d))))) ⇒ c
(cdr (car (cdr '((a b) (c d))))) ⇒ (d)
(car (cdr (car (cdr '((a b) (c d)))))) ⇒ d
(cdr (cdr (car (cdr '((a b) (c d)))))) ⇒ ()
(cdr (cdr '((a b) (c d)))) ⇒ ()</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.2.8">2.2.8</a>.</strong> (page <a href="#start:s38">21</a>)</p>
</div>
<div class="paragraph">
<p>See Section <a href="#section_2.3.">2.3</a>.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.3.1">2.3.1</a>.</strong> (page <a href="#start:s41">23</a>)</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Evaluate the variables <code>list</code>, <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>, yielding the list, addition, subtraction, multiplication, and division procedures. <a id="g252"></a></p>
</li>
<li>
<p>Apply the list procedure to the addition, subtraction, multiplication, and division procedures, yielding a list containing these procedures in order.</p>
</li>
<li>
<p>Evaluate the variable <code>cdr</code>, yielding the cdr procedure. <a id="g254"></a></p>
</li>
<li>
<p>Apply the cdr procedure to the list produced in step <a href="#g252">2</a>, yielding a list containing the subtraction, multiplication, and division procedures.</p>
</li>
<li>
<p>Evaluate the variable <code>car</code>, yielding the car procedure.</p>
</li>
<li>
<p>Apply the car procedure to the list produced in step <a href="#g254">4</a>, yielding the subtraction procedure.</p>
</li>
<li>
<p>Evaluate the constants <code>17</code> and <code>5</code>, yielding <code>17</code> and <code>5</code>.</p>
</li>
<li>
<p>Apply the subtraction procedure to <code>17</code> and <code>5</code>, yielding <code>12</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Other orders are possible. For example, the variable <code>car</code> could have been evaluated before its argument.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.4.1">2.4.1</a>.</strong> (page <a href="#start:s57">25</a>)</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>(let ([x (* 3 a)]) (+ (- x b) (+ x b)))</code></p>
</li>
<li>
<p><code>(let ([x (list a b c)]) (cons (car x) (cdr x)))</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.4.2">2.4.2</a>.</strong> (page <a href="#start:s57">25</a>)</p>
</div>
<div class="paragraph">
<p>The value is 54. The outer <code>let</code> binds <code>x</code> to 9, while the inner <code>let</code> binds <code>x</code> to 3 (9/3). The inner <code>let</code> evaluates to 6 (3 + 3), and the outer <code>let</code> evaluates to 54 (9 × 6).</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.4.3">2.4.3</a>.</strong> (page <a href="#start:s59">26</a>)</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x0 'a] [y0 'b])
  (list (let ([x1 'c]) (cons x1 y0))
        (let ([y1 'd]) (cons x0 y1))))</code></pre>
</div>
</div>
</li>
<li>
<p></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x0 '((a b) c)])
  (cons (let ([x1 (cdr x0)])
          (car x1))
        (let ([x2 (car x0)])
          (cons (let ([x3 (cdr x2)])
                  (car x3))
                (cons (let ([x4 (car x2)])
                        x4)
                      (cdr x2))))))</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.5.1">2.5.1</a>.</strong> (page <a href="#start:s73">30</a>)</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p><code>a</code></p>
</li>
<li>
<p><code>(a)</code></p>
</li>
<li>
<p><code>a</code></p>
</li>
<li>
<p><code>()</code></p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.5.2">2.5.2</a>.</strong> (page <a href="#start:s73">30</a>)</p>
</div>
<div class="paragraph">
<p>See page <a href="#defn:list">31</a>.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.5.3">2.5.3</a>.</strong> (page <a href="#start:s73">30</a>)</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>no free variables</p>
</li>
<li>
<p><code>+</code></p>
</li>
<li>
<p><code>f</code></p>
</li>
<li>
<p><code>cons</code>, <code>f</code>, and <code>y</code></p>
</li>
<li>
<p><code>cons</code> and <code>y</code></p>
</li>
<li>
<p><code>cons</code>, <code>y</code>, and <code>z</code> (<code>y</code> also appears as a bound variable)</p>
</li>
</ol>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.6.1">2.6.1</a>.</strong> (page <a href="#start:s96">34</a>)</p>
</div>
<div class="paragraph">
<p>The program would loop indefinitely.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.6.2">2.6.2</a>.</strong> (page <a href="#start:s96">34</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define compose
  (lambda (p1 p2)
    (lambda (x)
      (p1 (p2 x)))))

(define cadr (compose car cdr))
(define cddr (compose cdr cdr))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.6.3">2.6.3</a>.</strong> (page <a href="#start:s96">34</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define caar (compose car car))
(define cadr (compose car cdr))

(define cdar (compose cdr car))
(define cddr (compose cdr cdr))

(define caaar (compose car caar))
(define caadr (compose car cadr))
(define cadar (compose car cdar))
(define caddr (compose car cddr))

(define cdaar (compose cdr caar))
(define cdadr (compose cdr cadr))
(define cddar (compose cdr cdar))
(define cdddr (compose cdr cddr))

(define caaaar (compose caar caar))
(define caaadr (compose caar cadr))
(define caadar (compose caar cdar))
(define caaddr (compose caar cddr))
(define cadaar (compose cadr caar))
(define cadadr (compose cadr cadr))
(define caddar (compose cadr cdar))
(define cadddr (compose cadr cddr))

(define cdaaar (compose cdar caar))
(define cdaadr (compose cdar cadr))
(define cdadar (compose cdar cdar))
(define cdaddr (compose cdar cddr))
(define cddaar (compose cddr caar))
(define cddadr (compose cddr cadr))
(define cdddar (compose cddr cdar))
(define cddddr (compose cddr cddr))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.7.1">2.7.1</a>.</strong> (page <a href="#start:s128">41</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define atom?
  (lambda (x)
    (not (pair? x))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.7.2">2.7.2</a>.</strong> (page <a href="#start:s128">41</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define shorter
  (lambda (ls1 ls2)
    (if (< (length ls2) (length ls1))
        ls2
        ls1)))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.8.1">2.8.1</a>.</strong> (page <a href="#start:s149">46</a>)</p>
</div>
<div class="paragraph">
<p>The structure of the output would be the mirror image of the structure of the input. For example, <code>(a . b)</code> would become <code>(b . a)</code> and <code>((a . b) . (c . d))</code> would become <code>((d . c) . (b . a))</code>.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.8.2">2.8.2</a>.</strong> (page <a href="#start:s149">46</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define append
  (lambda (ls1 ls2)
    (if (null? ls1)
        ls2
        (cons (car ls1) (append (cdr ls1) ls2)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.8.3">2.8.3</a>.</strong> (page <a href="#start:s149">46</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define make-list
  (lambda (n x)
    (if (= n 0)
        '()
        (cons x (make-list (- n 1) x)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.8.4">2.8.4</a>.</strong> (page <a href="#start:s155">47</a>)</p>
</div>
<div class="paragraph">
<p>See the description of <code>list-ref</code> on page <a href="#defn:list-ref">160</a> and the description of <code>list-tail</code> on page <a href="#defn:list-ref">160</a>.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.8.5">2.8.5</a>.</strong> (page <a href="#start:s155">47</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define shorter?
  (lambda (ls1 ls2)
    (and (not (null? ls2))
         (or (null? ls1)
             (shorter? (cdr ls1) (cdr ls2))))))

(define shorter
  (lambda (ls1 ls2)
    (if (shorter? ls2 ls1)
        ls2
        ls1)))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.8.6">2.8.6</a>.</strong> (page <a href="#start:s155">47</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define even?
  (lambda (x)
    (or (= x 0)
        (odd? (- x 1)))))
(define odd?
  (lambda (x)
    (and (not (= x 0))
         (even? (- x 1)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.8.7">2.8.7</a>.</strong> (page <a href="#start:s155">47</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define transpose
  (lambda (ls)
    (cons (map car ls) (map cdr ls))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.9.1">2.9.1</a>.</strong> (page <a href="#start:s186">54</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define make-counter
  (lambda (init incr)
    (let ([next init])
      (lambda ()
        (let ([v next])
          (set! next (+ next incr))
          v)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.9.2">2.9.2</a>.</strong> (page <a href="#start:s188">55</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define make-stack
  (lambda ()
    (let ([ls '()])
      (lambda (msg . args)
        (case msg
          [(empty? mt?) (null? ls)]
          [(push!) (set! ls (cons (car args) ls))]
          [(top) (car ls)]
          [(pop!) (set! ls (cdr ls))]
          [else "oops"])))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.9.3">2.9.3</a>.</strong> (page <a href="#start:s188">55</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define make-stack
  (lambda ()
    (let ([ls '()])
      (lambda (msg . args)
        (case msg
          [(empty? mt?) (null? ls)]
          [(push!) (set! ls (cons (car args) ls))]
          [(top) (car ls)]
          [(pop!) (set! ls (cdr ls))]
          [(ref) (list-ref ls (car args))]
          [(set!) (set-car! (list-tail ls (car args)) (cadr args))]
          [else "oops"])))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.9.4">2.9.4</a>.</strong> (page <a href="#start:s188">55</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define make-stack
  (lambda (n)
    (let ([v (make-vector n)] [i -1])
      (lambda (msg . args)
        (case msg
          [(empty? mt?) (= i -1)]
          [(push!)
           (set! i (+ i 1))
           (vector-set! v i (car args))]
          [(top) (vector-ref v i)]
          [(pop!) (set! i (- i 1))]
          [(ref) (vector-ref v (- i (car args)))]
          [(set!) (vector-set! v (- i (car args)) (cadr args))]
          [else "oops"])))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.9.5">2.9.5</a>.</strong> (page <a href="#start:s194">56</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define emptyq?
  (lambda (q)
    (eq? (car q) (cdr q))))

(define getq
  (lambda (q)
    (if (emptyq? q)
        (assertion-violation 'getq "the queue is empty")
        (car (car q)))))

(define delq!
  (lambda (q)
    (if (emptyq? q)
        (assertion-violation 'delq! "the queue is empty")
        (set-car! q (cdr (car q))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.9.6">2.9.6</a>.</strong> (page <a href="#start:s194">56</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define make-queue
  (lambda ()
    (cons '() '())))

(define putq!
  (lambda (q v)
    (let ([p (cons v '())])
      (if (null? (car q))
          (begin
            (set-car! q p)
            (set-cdr! q p))
          (begin
            (set-cdr! (cdr q) p)
            (set-cdr! q p))))))

(define getq
  (lambda (q)
    (car (car q))))

(define delq!
  (lambda (q)
    (if (eq? (car q) (cdr q))
        (begin
          (set-car! q '())
          (set-cdr! q '()))
        (set-car! q (cdr (car q))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.9.7">2.9.7</a>.</strong> (page <a href="#start:s194">56</a>)</p>
</div>
<div class="paragraph">
<p>When asked to print a cyclic structure, some implementations print a representation of the output that reflects its cyclic structure. Other implementations do not detect the cycle and produce either no output or an infinite stream of output. When <code>length</code> is passed a cyclic list, an exception is raised, likely with a message indicating that the list is not proper. The definition of <code>length</code> on page <a href="#defn:simplelength">42</a> will, however, simply loop indefinitely.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_2.9.8">2.9.8</a>.</strong> (page <a href="#start:s194">56</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define race
  (lambda (hare tortoise)
    (if (pair? hare)
        (let ([hare (cdr hare)])
          (if (pair? hare)
              (and (not (eq? hare tortoise))
                   (race (cdr hare) (cdr tortoise)))
              (null? hare)))
        (null? hare))))

(define list?
  (lambda (x)
    (race x x)))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.1.1">3.1.1</a>.</strong> (page <a href="#further:s25">64</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([x (memv 'a ls)]) (and x (memv 'b x)))
  ((lambda (x) (and x (memv 'b x))) (memv 'a ls))
  ((lambda (x) (if x (and (memv 'b x)) #f)) (memv 'a ls))
  ((lambda (x) (if x (memv 'b x) #f)) (memv 'a ls))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.1.2">3.1.2</a>.</strong> (page <a href="#further:s25">64</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(or (memv x '(a b c)) (list x))
  (let ((t (memv x '(a b c)))) (if t t (or (list x))))
  ((lambda (t) (if t t (or (list x)))) (memv x '(a b c)))
  ((lambda (t) (if t t (list x))) (memv x '(a b c)))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.1.3">3.1.3</a>.</strong> (page <a href="#further:s25">64</a>)</p>
</div>
<div class="paragraph">
<p>See page <a href="#defn:let*">97</a>.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.1.4">3.1.4</a>.</strong> (page <a href="#further:s25">64</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax when
  (syntax-rules ()
    [(_ e0 e1 e2 ...)
     (if e0 (begin e1 e2 ...))]))

(define-syntax unless
  (syntax-rules ()
    [(_ e0 e1 e2 ...)
     (when (not e0) e1 e2 ...)]))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.2.1">3.2.1</a>.</strong> (page <a href="#further:s52">72</a>)</p>
</div>
<div class="paragraph">
<p>Tail-recursive: <code>even?</code> and <code>odd?</code>, <code>race</code>, <code>fact</code> in second definition of <code>factorial</code>, <code>fib</code> in second version of <code>fibonacci</code>. Nontail-recursive: <code>sum</code>, <code>factorial</code>, <code>fib</code> in first version of <code>fibonacci</code>. Both: <code>factor</code>.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.2.2">3.2.2</a>.</strong> (page <a href="#further:s52">72</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define factor
  (lambda (n)
    (letrec ([f (lambda (n i)
                  (cond
                    [(>= i n) (list n)]
                    [(integer? (/ n i))
                     (cons i (f (/ n i) i))]
                    [else (f n (+ i 1))]))])
      (f n 2))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.2.3">3.2.3</a>.</strong> (page <a href="#further:s52">72</a>)</p>
</div>
<div class="paragraph">
<p>Yes, but we need two named <code>let</code> expressions, one for <code>even?</code> and one for <code>odd?</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let even? ([x 20])
  (or (= x 0)
      (let odd? ([x (- x 1)])
        (and (not (= x 0))
             (even? (- x 1))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.2.4">3.2.4</a>.</strong> (page <a href="#further:s52">72</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define fibcount1 0)
(define fibonacci1
  (lambda (n)
    (let fib ([i n])
      (set! fibcount1 (+ fibcount1 1))
      (cond
        [(= i 0) 0]
        [(= i 1) 1]
        [else (+ (fib (- i 1)) (fib (- i 2)))]))))

(define fibcount2 0)
(define fibonacci2
  (lambda (n)
    (if (= n 0)
        0
        (let fib ([i n] [a1 1] [a2 0])
          (set! fibcount2 (+ fibcount2 1))
          (if (= i 1)
              a1
              (fib (- i 1) (+ a1 a2) a1))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The counts for <code>(fibonacci 10)</code> are 177 and 10, for <code>(fibonacci 20)</code> are 21891 and 20, and for <code>(fibonacci 30)</code> are 2692537 and 30. While the number of calls made by the second is directly proportional to the input, the number of calls made by the first grows rapidly (exponentially, in fact) as the input value increases.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.2.5">3.2.5</a>.</strong> (page <a href="#further:s57">73</a>)</p>
</div>
<div class="paragraph">
<p>See page <a href="#defn:let">312</a>.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.2.6">3.2.6</a>.</strong> (page <a href="#further:s57">73</a>)</p>
</div>
<div class="paragraph">
<p>A call in the last subexpression of an <code>or</code> expression in tail position would not be a tail call with the modified definition of <code>or</code>. For the <code>even?</code>/<code>odd?</code> example, the resulting definition of <code>even?</code> would no longer be tail-recursive and for very large inputs might exhaust available space.</p>
</div>
<div class="paragraph">
<p>The expansion performed by this definition is incorrect in another way, which has to do with multiple return values (Section <a href="#section_5.8.">5.8</a>): if the last subexpression returns multiple values, the <code>or</code> expression should return multiple values, but with the incorrect definition, each subexpression appears on the right-hand side of a <code>let</code>, which expects a single return value. The simpler and incorrect definition of <code>and</code> has the same problem.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.2.7">3.2.7</a>.</strong> (page <a href="#further:s57">73</a>)</p>
</div>
<div class="paragraph">
<p>The first of the three versions of <code>factor</code> below directly addresses the identified problems by stopping at \(\sqrt{n}\), avoiding the redundant division, and skipping the even factors after 2. Stopping at \(\sqrt{n}\) probably yields the biggest savings, followed by skipping even factors greater than 2. Avoiding the redundant division is less important, since it occurs only when a factor is found.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define factor
  (lambda (n)
    (let f ([n n] [i 2] [step 1])
      (if (> i (sqrt n))
          (list n)
          (let ([n/i (/ n i)])
            (if (integer? n/i)
                (cons i (f n/i i step))
                (f n (+ i step) 2)))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second version replaces <code>(&gt; i (sqrt n))</code> with <code>(&gt; (* i i) n)</code>, since <code>*</code> is typically much faster than <code>sqrt</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define factor
  (lambda (n)
    (let f ([n n] [i 2] [step 1])
      (if (> (* i i) n)
          (list n)
          (let ([n/i (/ n i)])
            (if (integer? n/i)
                (cons i (f n/i i step))
                (f n (+ i step) 2)))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The third version uses <code>gcd</code> (see page <a href="#page:gcd">179</a>) to avoid most of the divisions, since <code>gcd</code> should be faster than <code>/</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define factor
  (lambda (n)
    (let f ([n n] [i 2] [step 1])
      (if (> (* i i) n)
          (list n)
          (if (= (gcd n i) 1)
              (f n (+ i step) 2)
              (cons i (f (/ n i) i step)))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>To see the difference these changes make, time each version of <code>factor</code>, including the original, in your Scheme system to see which performs better. Try a variety of inputs, including larger ones like <code>(+ (expt 2 100) 1)</code>.</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.3.1">3.3.1</a>.</strong> (page <a href="#further:s66">77</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ([k.n (call/cc (lambda (k) (cons k 0)))])
  (let ([k (car k.n)] [n (cdr k.n)])
    (write n)
    (newline)
    (k (cons k (+ n 1)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>Or with multiple values (see Section <a href="#section_5.8.">5.8</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(call-with-values
  (lambda () (call/cc (lambda (k) (values k 0))))
  (lambda (k n)
    (write n)
    (newline)
    (k k (+ n 1))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.3.2">3.3.2</a>.</strong> (page <a href="#further:s66">77</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define product
  (lambda (ls)
    (if (null? ls)
        1
        (if (= (car ls) 0)
            0
            (let ([n (product (cdr ls))])
              (if (= n 0) 0 (* n (car ls))))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.3.3">3.3.3</a>.</strong> (page <a href="#further:s66">77</a>)</p>
</div>
<div class="paragraph">
<p>If one of the processes returns without calling <code>pause</code>, it returns to the call to <code>pause</code> that first caused it to run, or to the original call to <code>start</code> if it was the first process in the list. Here is a reimplementation of the system that allows a process to <code>quit</code> explicitly. If other processes are active, the <code>lwp</code> system continues to run. Otherwise, control returns to the continuation of the original call to <code>start</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define lwp-list '())
(define lwp
  (lambda (thunk)
    (set! lwp-list (append lwp-list (list thunk)))))
(define start
  (lambda ()
    (call/cc
      (lambda (k)
        (set! quit-k k)
        (next)))))
(define next
  (lambda ()
    (let ([p (car lwp-list)])
      (set! lwp-list (cdr lwp-list))
      (p))))
(define pause
  (lambda ()
    (call/cc
      (lambda (k)
        (lwp (lambda () (k #f)))
        (next)))))
(define quit
  (lambda (v)
    (if (null? lwp-list)
        (quit-k v)
        (next))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.3.4">3.3.4</a>.</strong> (page <a href="#further:s66">77</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define lwp-queue (make-queue))
(define lwp
  (lambda (thunk)
    (putq! lwp-queue thunk)))
(define start
  (lambda ()
    (let ([p (getq lwp-queue)])
      (delq! lwp-queue)
      (p))))
(define pause
  (lambda ()
    (call/cc
      (lambda (k)
        (lwp (lambda () (k #f)))
        (start)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.4.1">3.4.1</a>.</strong> (page <a href="#further:s77">80</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define reciprocal
  (lambda (n success failure)
    (if (= n 0)
        (failure)
        (success (/ 1 n)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.4.2">3.4.2</a>.</strong> (page <a href="#further:s77">80</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define retry #f)

(define factorial
  (lambda (x)
    (let f ([x x] [k (lambda (x) x)])
      (if (= x 0)
          (begin (set! retry k) (k 1))
          (f (- x 1) (lambda (y) (k (* x y))))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.4.3">3.4.3</a>.</strong> (page <a href="#further:s77">80</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define map/k
  (lambda (p ls k)
    (if (null? ls)
        (k '())
        (p (car ls)
           (lambda (x)
             (map/k p (cdr ls)
               (lambda (ls)
                 (k (cons x ls)))))))))

(define reciprocals
  (lambda (ls)
    (map/k (lambda (x k) (if (= x 0) "zero found" (k (/ 1 x))))
           ls
           (lambda (x) x))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.5.1">3.5.1</a>.</strong> (page <a href="#further:s87">85</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax complain
  (syntax-rules ()
    [(_ ek msg expr) (ek (list msg expr))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.5.2">3.5.2</a>.</strong> (page <a href="#further:s87">85</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define calc
  (lambda (expr)
    (call/cc
      (lambda (ek)
        (define do-calc
          (lambda (expr)
            (cond
              [(number? expr) expr]
              [(and (list? expr) (= (length expr) 3))
               (let ([op (car expr)] [args (cdr expr)])
                 (case op
                   [(add) (apply-op + args)]
                   [(sub) (apply-op - args)]
                   [(mul) (apply-op * args)]
                   [(div) (apply-op / args)]
                   [else (complain "invalid operator" op)]))]
              [else (complain "invalid expression" expr)])))
        (define apply-op
          (lambda (op args)
            (op (do-calc (car args)) (do-calc (cadr args)))))
        (define complain
          (lambda (msg expr)
            (ek (list msg expr))))
        (do-calc expr)))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.5.3">3.5.3</a>.</strong> (page <a href="#further:s87">85</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define calc #f)
(let ()
  (define do-calc
    (lambda (expr)
      (cond
        [(number? expr) expr]
        [(and (list? expr) (= (length expr) 3))
         (let ([op (car expr)] [args (cdr expr)])
           (case op
             [(add) (apply-op + args)]
             [(sub) (apply-op - args)]
             [(mul) (apply-op * args)]
             [(div) (apply-op / args)]
             [else (complain "invalid operator" op)]))]
        [else (complain "invalid expression" expr)])))
  (define apply-op
    (lambda (op args)
      (op (do-calc (car args)) (do-calc (cadr args)))))
  (define complain
    (lambda (msg expr)
      (assertion-violation 'calc msg expr)))
  (set! calc
    (lambda (expr)
      (do-calc expr))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.5.4">3.5.4</a>.</strong> (page <a href="#further:s87">85</a>)</p>
</div>
<div class="paragraph">
<p>This adds <code>sqrt</code>, <code>times</code> (an alias for <code>mul</code>), and <code>expt</code> along with <code>minus</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(let ()
  (define do-calc
    (lambda (ek expr)
      (cond
        [(number? expr) expr]
        [(and (list? expr) (= (length expr) 2))
         (let ([op (car expr)] [args (cdr expr)])
           (case op
             [(minus) (apply-op1 ek - args)]
             [(sqrt) (apply-op1 ek sqrt args)]
             [else (complain ek "invalid unary operator" op)]))]
        [(and (list? expr) (= (length expr) 3))
         (let ([op (car expr)] [args (cdr expr)])
           (case op
             [(add) (apply-op2 ek + args)]
             [(sub) (apply-op2 ek - args)]
             [(mul times) (apply-op2 ek * args)]
             [(div) (apply-op2 ek / args)]
             [(expt) (apply-op2 ek expt args)]
             [else (complain ek "invalid binary operator" op)]))]
        [else (complain ek "invalid expression" expr)])))
  (define apply-op1
    (lambda (ek op args)
      (op (do-calc ek (car args)))))
  (define apply-op2
    (lambda (ek op args)
      (op (do-calc ek (car args)) (do-calc ek (cadr args)))))
  (define complain
    (lambda (ek msg expr)
      (ek (list msg expr))))
  (set! calc
    (lambda (expr)
      (call/cc
        (lambda (ek)
          (do-calc ek expr))))))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.6.1">3.6.1</a>.</strong> (page <a href="#further:s91">87</a>)</p>
</div>
<div class="paragraph">
<p>This version of <code>gpa</code> returns <code>x</code> when all of the input letter grades are <code>x</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define-syntax gpa
  (syntax-rules ()
    [(_ g1 g2 ...)
     (let ([ls (map letter->number (remq 'x '(g1 g2 ...)))])
       (if (null? ls)
           'x
           (/ (apply + ls) (length ls))))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.6.2">3.6.2</a>.</strong> (page <a href="#further:s91">87</a>)</p>
</div>
<div class="paragraph">
<p>After defining <code>$distribution</code> and <code>distribution</code> within the library as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define $distribution
  (lambda (ls)
    (let loop ([ls ls] [a 0] [b 0] [c 0] [d 0] [f 0])
      (if (null? ls)
          (list (list a 'a) (list b 'b) (list c 'c)
            (list d 'd) (list f 'f))
          (case (car ls)
            [(a) (loop (cdr ls) (+ a 1) b c d f)]
            [(b) (loop (cdr ls) a (+ b 1) c d f)]
            [(c) (loop (cdr ls) a b (+ c 1) d f)]
            [(d) (loop (cdr ls) a b c (+ d 1) f)]
            [(f) (loop (cdr ls) a b c d (+ f 1))]
           ; ignore x grades, per preceding exercise
            [(x) (loop (cdr ls) a b c d f)]
            [else (assertion-violation 'distribution
                    "unrecognized grade letter"
                    (car ls))])))))
(define-syntax distribution
  (syntax-rules ()
    [(_ g1 g2 ...)
     ($distribution '(g1 g2 ...))]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>modify the <code>export</code> line to add <code>distribution</code> (but not <code>$distribution</code>).</p>
</div>
<div class="paragraph">
<p><strong>Exercise <a href="#exercise_3.6.3">3.6.3</a>.</strong> (page <a href="#further:s91">87</a>)</p>
</div>
<div class="paragraph">
<p>After defining <code>histogram</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">(define histogram
  (lambda (port distr)
    (for-each
      (lambda (n g)
        (put-datum port g)
        (put-string port ": ")
        (let loop ([n n])
          (unless (= n 0)
            (put-char port #\*)
            (loop (- n 1))))
        (put-string port "\n"))
      (map car distr)
      (map cadr distr))))</code></pre>
</div>
</div>
<div class="paragraph">
<p>modify the <code>export</code> line to add <code>histogram</code>. The solution uses <code>for-each</code>, which is described on page <a href="#desc:for-each">118</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="formal_syntax">Formal Syntax</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The formal grammars and accompanying text appearing here describe the written syntax of Scheme data values, or <em>datums</em>. The grammars also effectively cover the written syntax of Scheme syntactic forms, since every Scheme syntactic form has a representation as a Scheme datum. In particular, parenthesized syntactic forms are written as lists, and identifiers (e.g., keywords and variables) are written as symbols. The high-level structure of each syntactic form is described in detail by the entries marked "syntax" in Chapters <a href="#chp_procedures_and_variable_bindings">4</a> through <a href="#chp_exceptions_and_conditions">11</a>, and the syntactic forms are summarized in the Summary of Forms.</p>
</div>
<div class="paragraph">
<p>The written representation of a datum involves tokens, whitespace, and comments. <em>Tokens</em> are sequences of one or more characters representing atomic datums or serving as punctuation marks. The tokens that represent atomic datums are symbols, numbers, strings, booleans, and characters, while the tokens serving as punctuation marks are open and close parentheses, open and close brackets, the open vector parenthesis <code>#(</code>, the open bytevector parenthesis <code>#vu8(</code>, the dotted pair marker <code>.</code> (dot), the quotation marks <code>'</code> and <code>`</code>, the unquotation marks <code>,</code> and <code>,@</code>, the syntax quotation marks <code>#'</code> and <code>#`</code>, and the syntax unquotation marks <code>#,</code> and <code>#,@</code>.</p>
</div>
<div class="paragraph">
<p><em>Whitespace</em> consists of space, tab, newline, form-feed, carriage-return, and next-line characters along with any additional characters categorized as Zs, Zl, or Zp by the Unicode standard <a href="#ref30">[30]</a>. A newline character is also called a linefeed character. Some whitespace characters or character sequences serve as <em>line endings</em>, which are recognized as part of the syntax of line comments and strings. A line ending is a newline character, a next-line character, a line-separator character, a carriage-return character followed by a newline character, a carriage return followed by a next-line character, or a carriage return not followed by a newline or next-line character. A different set of whitspace characters serve as <em>intraline whitespace</em>, which are recognized as part of the syntax of strings. Intraline whitespace includes spaces, tabs, and any additional Unicode characters whose general category is Zs. The sets of intraline whitespace characters and line endings are disjoint, and there are other whitespace characters, such as form feed, that are not in either set.</p>
</div>
<div class="paragraph">
<p><em>Comments</em> come in three flavors: line comments, block comments, and datum comments. A line comment consists of a semicolon ( <code>;</code> ) followed by any number of characters up to the next line ending or end of input. A block comment consists of a <code>#|</code> prefix, any number of characters and nested block comments, and a <code>|#</code> suffix. A datum comment consists of a <code>#;</code> prefix followed by any datum.</p>
</div>
<div class="paragraph">
<p>Symbols, numbers, characters, booleans, and the dotted pair marker ( <code>.</code> ) must be delimited by the end the input, whitespace, the start of a comment, an open or close parenthesis, an open or close bracket, a string quote ( <code>"</code> ), or a hash mark ( <code>#</code> ). Any token may be preceded or followed by any number of whitespace characters and comments.</p>
</div>
<div class="paragraph">
<p>Case is significant in the syntax of characters, strings, and symbols except within a hex scalar value, where the hexadecimal digits "a" through "f" may be written in either upper or lower case. (Hex scalar values are hexadecimal numbers denoting Unicode scalar values.) Case is insignificant in the syntax of booleans and numbers. For example, <code>Hello</code> is distinct from <code>hello</code>, <code>#\A</code> is distinct from <code>#\a</code>, and <code>"String"</code> is distinct from <code>"string"</code>, while <code>#T</code> is equivalent to <code>#t</code>, <code>#E1E3</code> is equivalent to <code>#e1e3</code>, <code>#X2aBc</code> is equivalent to <code>#x2abc</code>, and <code>#\x3BA</code> is equivalent to <code>#\x3ba</code>.</p>
</div>
<div class="paragraph">
<p>A conforming implementation of the Revised<sup>6</sup> Report is not permitted to extend the syntax of datums, with one exception: it is permitted to recognize any token starting with the prefix <code>#!</code> as a flag indicating certain extensions are valid in the text following the flag. So, for example, an implementation might recognize the flag <code>#!braces</code> and switch to a mode in which lists may be enclosed in braces as well as in parentheses and brackets.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">#!braces '{a b c} ⇒ (a b c)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The flag <code>#!r6rs</code> may be used to declare that the subsequent text is written in R6RS syntax. It is good practice to include <code>#!r6rs</code> at the start of any file containing a portable library or top-level program to specify that R6RS syntax is being used, in the event that future reports extend the syntax in ways that are incompatible with the text of the library or program. <code>#!r6rs</code> is otherwise treated as a comment.</p>
</div>
<div class="paragraph">
<p>In the grammars appearing below, &lt;empty&gt; stands for an empty sequence of characters. An item followed by an asterisk ( * ) represents zero or more occurrences of the item, and an item followed by a raised plus sign ( <sup>+</sup> ) represents one or more occurrences. Spacing between items within a production appears for readability only and should be treated as if it were not present.</p>
</div>
<div id="grammar:datums" class="paragraph">
<p><strong>Datums.</strong>  A datum is a boolean, character, symbol, string, number, list, vector, or bytevector.</p>
</div>
<table class="tableblock frame-none grid-none fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;datum&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;boolean&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;character&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;symbol&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;string&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;number&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;list&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;vector&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;bytevector&gt;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Lists, vectors, and bytevectors are compound datums formed from groups of tokens possibly separated by whitespace and comments. The others are single tokens.</p>
</div>
<div id="grammar:booleans" class="paragraph">
<p><strong>Booleans.</strong>  Boolean false is written <code>#f</code>. While all other values count as true, the canonical true value (and only other value to be considered a boolean value by the <code>boolean?</code> predicate) is written <code>#t</code>.</p>
</div>
<table class="tableblock frame-none grid-none fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;boolean&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#t</code> | <code>#f</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Case is not significant in the syntax of booleans, so these may also be written as <code>#T</code> and <code>#F</code>.</p>
</div>
<div id="grammar:characters" class="paragraph">
<p><strong>Characters.</strong>  A character object is written as the prefix <code>#\</code> followed by a single character, a character name, or a sequence of characters specifying a Unicode scalar value.</p>
</div>
<table class="tableblock frame-none grid-none fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;character&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#\</code> &lt;any character&gt; | <code>#\</code> &lt;character name&gt; | <code>#\x</code> &lt;hex scalar value&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;character name&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>alarm</code> | <code>backspace</code> | <code>delete</code> | <code>esc</code> | <code>linefeed</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>newline</code> | <code>page</code> | <code>return</code> | <code>space</code> | <code>tab</code> | <code>vtab</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;hex scalar value&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;digit 16&gt;<sup>+</sup></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The named characters correspond to the Unicode characters alarm (Unicode scalar value 7, i.e., U+0007), backspace (U+0008), delete (U+007F), esc (U+001B), linefeed (U+000A; same as newline), newline (U+000A), page (U+000C), return (U+000D), space (U+0020), tab (U+0009) and vertical tab (U+000B).</p>
</div>
<div class="paragraph">
<p>A hex scalar value represents a Unicode scalar value <em>n</em>, \(0 \le n \le D800_{16}\) or \(E000_{16} \le n \le 10FFF_{16}\). The &lt;digit 16&gt; nonterminal is defined under <strong>Numbers</strong> below.</p>
</div>
<div class="paragraph">
<p>A <code>#\</code> prefix followed by a character name is always interpreted as a named character, e.g., <code>#\page</code> is treated as <code>#\page</code> rather than <code>#\p</code> followed by the symbol <code>age</code>. Characters must also be delimited, as described above, so that <code>#\pager</code> is treated as a syntax error rather than as the character <code>#\p</code> followed by the symbol <code>ager</code> or the character <code>#\page</code> followed by the symbol <code>r</code>.</p>
</div>
<div class="paragraph">
<p>Case is significant in the syntax of character objects, except within a hex scalar value.</p>
</div>
<div id="grammar:strings" class="paragraph">
<p><strong>Strings.</strong>  A string is written as a sequence of string elements enclosed in string quotes (double quotes). Any character other than a string quote or backslash can appear as a string element. A string element can also consist of a backslash followed by a single character, a backslash followed by sequence of characters specifying a Unicode scalar value, or a backslash followed by sequence of intraline whitespace characters that includes a single line ending.</p>
</div>
<table class="tableblock frame-none grid-none fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;string&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"</code> &lt;string character&gt;* <code>"</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;string element&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;any character except <code>"</code> or <code>\</code>&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\"</code> | <code>\\</code> | <code>\a</code> | <code>\b</code> | <code>\f</code> | <code>\n</code> | <code>\r</code> | <code>\t</code> | <code>\v</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\x</code> &lt;hex scalar value&gt; <code>;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code> &lt;intraline whitespace&gt;* &lt;line ending&gt; &lt;intraline whitespace&gt;*</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A string element consisting of a single character represents that character, except that any single character or pair of characters representing a line ending represents a single newline character. A backslash followed by a double quote represents a double quote, while a backslash followed by a backslash represents a backslash. A backslash followed by <code>a</code> represents the alarm character (U+0007); by <code>b</code>, backspace (U+0008); by <code>f</code>, form feed (U+000C); by <code>n</code>, newline (U+000A); by <code>r</code>, carriage return (U+000D); by <code>t</code>, tab (U+0009); and by <code>v</code>, vertical tab (U+000B). A backslash followed by <code>x</code>, a hex scalar value, and a semi-colon ( <code>;</code> ) represents the Unicode character specified by the scalar value. The &lt;hex scalar value&gt; nonterminal is defined under <strong>Characters</strong> above. Finally, a sequence of characters consisting of a backslash followed by intraline whitespace that includes a single line ending represents no characters.</p>
</div>
<div class="paragraph">
<p>Case is significant in the syntax of strings, except within a hex scalar value.</p>
</div>
<div id="grammar:symbols" class="paragraph">
<p><strong>Symbols.</strong>  A symbol is written either as an "initial" character followed by a sequence of "subsequent" characters or as a "peculiar symbol." Initial characters are letters, certain special characters, an additional set of Unicode characters, or arbitrary characters specified by Unicode scalar values. Subsequent characters are initial characters, digits, certain additional special characters, and a set of additional Unicode characters. The peculiar symbols are <code>+</code>, <code>-</code>, <code>...</code>, and any sequence of subsequent characters prefixed by <code>-&gt;</code>.</p>
</div>
<table class="tableblock frame-none grid-none fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;symbol&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;initial&gt; &lt;subsequent&gt;*</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;initial&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;letter&gt; | <code>!</code> | <code>$</code> | <code>%</code> | <code>&amp;</code> | <code>*</code> | <code>/</code> | <code>:</code> | <code>&lt;</code> | <code>=</code> | <code>&gt;</code> | <code>?</code> | <code>~</code> | <code>_</code> | <code>^</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;Unicode Lu, Ll, Lt, Lm, Lo, Mn, Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\x</code> &lt;hex scalar value&gt; <code>;</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;subsequent&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;initial&gt; | &lt;digit 10&gt; | <code>.</code> | <code>+</code> | <code>-</code> | <code>@</code> | &lt;Unicode Nd, Mc, or Me&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;letter&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a</code> | <code>b</code> | &#8230;&#8203; | <code>z</code> | <code>A</code> | <code>B</code> | &#8230;&#8203; | <code>Z</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>&lt;Unicode Lu, Ll, Lt, Lm, Lo, Mn, Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co&gt; represents any character whose Unicode scalar value is greater than 127 and whose Unicode category is one of the listed categories. &lt;Unicode Nd, Mc, or Me&gt; represents any character whose Unicode category is one of the listed categories. The &lt;hex scalar value&gt; nonterminal is defined under <strong>Characters</strong> above, and &lt;digit 10&gt; is defined under <strong>Numbers</strong> below.</p>
</div>
<div class="paragraph">
<p>Case is significant in symbols.</p>
</div>
<div id="grammar:numbers" class="paragraph">
<p><strong>Numbers.</strong>  Numbers can appear in one of four radices: 2, 8, 10, and 16, with 10 the default. Several of the productions below are parameterized by the radix, <code><em>r</em></code>, and each represents four productions, one for each of the four possible radices. Numbers that contain radix points or exponents are constrained to appear in radix 10, so &lt;decimal <code><em>r</em></code>&gt; is valid only when <code><em>r</em></code> is 10.</p>
</div>
<table class="tableblock frame-none grid-none fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;number&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;num 2&gt; | &lt;num 8&gt; | &lt;num 10&gt; | &lt;num 16&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;num <code><em>r</em></code>&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;prefix <code><em>r</em></code>&gt; &lt;complex <code><em>r</em></code>&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;prefix <code><em>r</em></code>&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;radix <code><em>r</em></code>&gt; &lt;exactness&gt; | &lt;exactness&gt; &lt;radix <code><em>r</em></code>&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;radix 2&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#b</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;radix 8&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#o</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;radix 10&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;empty&gt; | <code>#d</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;radix 16&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#x</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;exactness&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;empty&gt; | <code>#i</code> | <code>#e</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;complex <code><em>r</em></code>&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;real <code><em>r</em></code>&gt; | &lt;real <code><em>r</em></code>&gt; @ &lt;real <code><em>r</em></code>&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;real <code><em>r</em></code>&gt; <code>+</code> &lt;imag <code><em>r</em></code>&gt; | &lt;real <code><em>r</em></code>&gt; <code>-</code> &lt;imag <code><em>r</em></code>&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+</code> &lt;imag <code><em>r</em></code>&gt; | <code>-</code> &lt;imag <code><em>r</em></code>&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;real <code><em>r</em></code>&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;sign&gt; &lt;ureal <code><em>r</em></code>&gt; | <code>+nan.0</code> | <code>-nan.0</code> | <code>+inf.0</code> | <code>-inf.0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;imag <code><em>r</em></code>&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>i</code> | &lt;ureal <code><em>r</em></code>&gt; <code>i</code> | <code>inf.0</code> <code>i</code> | <code>nan.0</code> <code>i</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;ureal <code><em>r</em></code>&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;uinteger <code><em>r</em></code>&gt; | &lt;uinteger <code><em>r</em></code>&gt; <code>/</code> &lt;uinteger <code><em>r</em></code>&gt; | &lt;decimal <code><em>r</em></code>&gt; &lt;suffix&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;uinteger <code><em>r</em></code>&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;digit <code><em>r</em></code>&gt;<sup>+</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;decimal 10&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;uinteger 10&gt; &lt;suffix&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>.</code> &lt;digit 10&gt;<sup>+</sup> &lt;suffix&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;digit 10&gt;<sup>+</sup> <code>.</code> &lt;digit 10&gt;* &lt;suffix&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;suffix&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;exponent&gt; &lt;mantissa width&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;exponent&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;empty&gt; | &lt;exponent marker&gt; &lt;sign&gt; &lt;digit 10&gt;<sup>+</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;exponent marker&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>e</code> | <code>s</code> | <code>f</code> | <code>d</code> | <code>l</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;mantissa width&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;empty&gt; | <code>|</code> &lt;digit 10&gt;<sup>+</sup></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;sign&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;empty&gt; | <code>+</code> | <code>-</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;digit 2&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code> | <code>1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;digit 8&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code> | <code>1</code> | <code>2</code> | <code>3</code> | <code>4</code> | <code>5</code> | <code>6</code> | <code>7</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;digit 10&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>0</code> | <code>1</code> | <code>2</code> | <code>3</code> | <code>4</code> | <code>5</code> | <code>6</code> | <code>7</code> | <code>8</code> | <code>9</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;digit 16&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;digit 10&gt; | <code>a</code> | <code>b</code> | <code>c</code> | <code>d</code> | <code>e</code> | <code>f</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>A number written as above is inexact if it is prefixed by <code>#i</code> or if it is not prefixed by <code>#e</code> and contains a decimal point, nonempty exponent, or nonempty mantissa width. Otherwise, it is exact.</p>
</div>
<div class="paragraph">
<p>Case is not significant in the syntax of numbers.</p>
</div>
<div id="grammar:lists" class="paragraph">
<p><strong>Lists.</strong>  Lists are compound datums formed from groups of tokens and possibly involving other datums, including other lists. Lists are written as a sequence of datums within parentheses or brackets; as a nonempty sequence of datums, dotted-pair marker ( . ), and single datum enclosed within parentheses or brackets; or as an abbreviation.</p>
</div>
<table class="tableblock frame-none grid-none fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;list&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(</code>&lt;datum&gt;*<code>)</code> | <code>[</code>&lt;datum&gt;*<code>]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(</code>&lt;datum&gt;<sup>+</sup> <code>.</code> &lt;datum&gt;<code>)</code> | <code>[</code>&lt;datum&gt;<sup>+</sup> <code>.</code> &lt;datum&gt;<code>]</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;abbreviation&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;abbreviation&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'</code> &lt;datum&gt; | <code>`</code> &lt;datum&gt; | <code>,</code> &lt;datum&gt; | <code>,@</code> &lt;datum&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">|</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#'</code> &lt;datum&gt; | <code>#`</code> &lt;datum&gt; | <code>#,</code> &lt;datum&gt; | <code>#,@</code> &lt;datum&gt;</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>If no dotted-pair marker appears in a list enclosed in parentheses or brackets, it is a proper list, and the datums are the elements of the list, in the order given. If a dotted-pair marker appears, the initial elements of the list are those before the marker, and the datum that follows the marker is the tail of the list. The dotted-pair marker is typically used only when the datum that follows the marker is not itself a list. While any proper list may be written without a dotted-pair marker, a proper list can be written in dotted-pair notation by placing a list after the dotted-pair marker.</p>
</div>
<div class="paragraph">
<p>The abbreviations are equivalent to the corresponding two-element lists shown below. Once an abbreviation has been read, the result is indistinguishable from its nonabbreviated form.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="scheme" class="language-scheme hljs">'&lt;datum&gt; ⇒ (quote &lt;datum&gt;)
`&lt;datum&gt; ⇒ (quasiquote &lt;datum&gt;)
,&lt;datum&gt; ⇒ (unquote &lt;datum&gt;)
,@&lt;datum&gt; ⇒ (unquote-splicing &lt;datum&gt;)
#'&lt;datum&gt; ⇒ (syntax &lt;datum&gt;)
#`&lt;datum&gt; ⇒ (quasisyntax &lt;datum&gt;)
#,&lt;datum&gt; ⇒ (unsyntax &lt;datum&gt;)
#,@&lt;datum&gt; ⇒ (unsyntax-splicing &lt;datum&gt;)</code></pre>
</div>
</div>
<div id="grammar:vectors" class="paragraph">
<p><strong>Vectors.</strong>  Vectors are compound datums formed from groups of tokens and possibly involving other datums, including other vectors. A vector is written as an open vector parenthesis followed by a sequence of datums and a close parenthesis.</p>
</div>
<table class="tableblock frame-none grid-none fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;vector&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#(</code>&lt;datum&gt;*<code>)</code></p></td>
</tr>
</tbody>
</table>
<div id="grammar:bytevectors" class="paragraph">
<p><strong>Bytevectors.</strong>  Bytevectors are compound datums formed from groups of tokens, but the syntax does not permit them to contain arbitrary nested datums. A bytevector is written as an open bytevector parenthesis followed by a sequence of octets (unsigned 8-bit exact integers) and a close parenthesis.</p>
</div>
<table class="tableblock frame-none grid-none fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;bytevector&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#vu8(</code>&lt;octet&gt;*<code>)</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;octet&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#8594;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;any &lt;number&gt; representing an exact integer <code><em>n</em></code>, \(0 ≤ n ≤ 255\)&gt;</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="summary_of_forms">Summary of Forms</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The table that follows summarizes the Scheme syntactic forms and procedures described in Chapters <a href="#chp_procedures_and_variable_bindings">4</a> through <a href="#chp_exceptions_and_conditions">11</a>. It shows the category of the form and the page number where it is defined. The category states whether the form describes a syntactic form or a procedure.</p>
</div>
<div class="paragraph">
<p>All page numbers appearing here refer to the printed version of this book and also serve as hypertext links to the corresponding locations in the electronic version of this book.</p>
</div>
<table class="tableblock frame-none grid-none fit-content">
<colgroup>
<col>
<col>
<col>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Form</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Category</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Page</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'<em>obj</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s2">141</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>`<em>obj</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s5">142</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>,<em>obj</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s5">142</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>,@<em>obj</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s5">142</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>=&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s16">112</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>_</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s26">297</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>...</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s26">297</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#'<em>template</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s33">300</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#`<em>template</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s40">305</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#,<em>template</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s40">305</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>#,@<em>template</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s40">305</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;assertion</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s21">366</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;condition</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s13">362</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;error</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s22">367</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;i/o</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s32">371</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;i/o-decoding</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s42">375</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;i/o-encoding</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s43">376</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;i/o-file-already-exists</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s39">374</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;i/o-file-does-not-exist</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s40">374</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;i/o-file-is-read-only</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s38">374</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;i/o-file-protection</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s37">373</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;i/o-filename</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s36">373</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;i/o-invalid-position</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s35">372</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;i/o-port</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s41">375</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;i/o-read</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s33">372</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;i/o-write</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s34">372</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;implementation-restriction</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s28">369</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;irritants</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s25">368</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;lexical</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s29">370</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;message</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s24">368</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;no-infinities</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s44">376</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;no-nans</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s45">377</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;non-continuable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s27">369</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;serious</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s19">366</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;syntax</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s30">370</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;undefined</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s31">371</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;violation</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s20">366</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;warning</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s23">367</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;who</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s26">369</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(* <em>num</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s91">172</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(+ <em>num</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s89">171</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(- <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s90">172</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(- <em>num<sub>1</sub></em> <em>num<sub>2</sub></em> <em>num<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s90">172</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(/ <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s92">172</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(/ <em>num<sub>1</sub></em> <em>num<sub>2</sub></em> <em>num<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s92">172</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(&lt; <em>real<sub>1</sub></em> <em>real<sub>2</sub></em> <em>real<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s88">170</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(&lt;= <em>real<sub>1</sub></em> <em>real<sub>2</sub></em> <em>real<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s88">170</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(= <em>num<sub>1</sub></em> <em>num<sub>2</sub></em> <em>num<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s88">170</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(&gt; <em>real<sub>1</sub></em> <em>real<sub>2</sub></em> <em>real<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s88">170</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(&gt;= <em>real<sub>1</sub></em> <em>real<sub>2</sub></em> <em>real<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s88">170</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(abs <em>real</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s105">178</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(acos <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s132">185</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(and <em>expr</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s11">110</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(angle <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s124">183</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(append)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s49">160</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(append <em>list</em> ... <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s49">160</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(apply <em>procedure</em> <em>obj</em> ... <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s3">107</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(asin <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s132">185</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(assert <em>expression</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s5">359</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(assertion-violation <em>who</em> <em>msg</em> <em>irritant</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s4">358</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(assertion-violation? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s21">366</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(assoc <em>obj</em> <em>alist</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s58">165</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(assp <em>procedure</em> <em>alist</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s60">166</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(assq <em>obj</em> <em>alist</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s58">165</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(assv <em>obj</em> <em>alist</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s58">165</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(atan <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s133">185</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(atan <em>real<sub>1</sub></em> <em>real<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s133">185</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(begin <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s4">108</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(binary-port? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s45">270</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-and <em>exint</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s134">186</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-arithmetic-shift <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s144">190</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-arithmetic-shift-left <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s143">189</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-arithmetic-shift-right <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s143">189</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-bit-count <em>exint</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s136">187</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-bit-field <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em> <em>exint<sub>3</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s141">189</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-bit-set? <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s139">188</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-copy-bit <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em> <em>exint<sub>3</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s140">188</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-copy-bit-field <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em> <em>exint<sub>3</sub></em> <em>exint<sub>4</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s142">189</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-first-bit-set <em>exint</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s138">187</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-if <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em> <em>exint<sub>3</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s135">186</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-ior <em>exint</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s134">186</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-length <em>exint</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s137">187</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-not <em>exint</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s134">186</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-reverse-bit-field <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em> <em>exint<sub>3</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s146">191</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-rotate-bit-field <em>exint<sub>1</sub></em> <em>exint<sub>2</sub></em> <em>exint<sub>3</sub></em> <em>exint<sub>4</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s145">190</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bitwise-xor <em>exint</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s134">186</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(boolean=? <em>boolean<sub>1</sub></em> <em>boolean<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s271">243</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(boolean? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s14">150</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bound-identifier=? <em>identifier<sub>1</sub></em> <em>identifier<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s37">302</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(buffer-mode <em>symbol</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s27">261</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(buffer-mode? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s28">262</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-&gt;sint-list <em>bytevector</em> <em>eness</em> <em>size</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s260">238</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-&gt;string <em>bytevector</em> <em>transcoder</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s91">286</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-&gt;u8-list <em>bytevector</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s252">232</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-&gt;uint-list <em>bytevector</em> <em>eness</em> <em>size</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s260">238</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-copy <em>bytevector</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s246">229</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-copy! <em>src</em> <em>src-start</em> <em>dst</em> <em>dst-start</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s247">230</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-fill! <em>bytevector</em> <em>fill</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s245">229</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-ieee-double-native-ref <em>bytevector</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s262">239</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-ieee-double-native-set! <em>bytevector</em> <em>n</em> <em>x</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s263">239</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-ieee-double-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s264">240</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-ieee-double-set! <em>bytevector</em> <em>n</em> <em>x</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s265">240</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-ieee-single-native-ref <em>bytevector</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s262">239</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-ieee-single-native-set! <em>bytevector</em> <em>n</em> <em>x</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s263">239</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-ieee-single-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s264">240</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-ieee-single-set! <em>bytevector</em> <em>n</em> <em>x</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s265">240</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-length <em>bytevector</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s243">229</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s16-native-ref <em>bytevector</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s254">232</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s16-native-set! <em>bytevector</em> <em>n</em> <em>s16</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s255">233</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s16-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s256">235</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s16-set! <em>bytevector</em> <em>n</em> <em>s16</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s257">236</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s32-native-ref <em>bytevector</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s254">232</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s32-native-set! <em>bytevector</em> <em>n</em> <em>s32</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s255">233</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s32-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s256">235</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s32-set! <em>bytevector</em> <em>n</em> <em>s32</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s257">236</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s64-native-ref <em>bytevector</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s254">232</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s64-native-set! <em>bytevector</em> <em>n</em> <em>s64</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s255">233</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s64-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s256">235</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s64-set! <em>bytevector</em> <em>n</em> <em>s64</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s257">236</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s8-ref <em>bytevector</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s249">231</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-s8-set! <em>bytevector</em> <em>n</em> <em>s8</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s251">231</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-sint-ref <em>bytevector</em> <em>n</em> <em>eness</em> <em>size</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s258">237</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-sint-set! <em>bytevector</em> <em>n</em> <em>sint</em> <em>eness</em> <em>size</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s259">238</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u16-native-ref <em>bytevector</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s254">232</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u16-native-set! <em>bytevector</em> <em>n</em> <em>u16</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s255">233</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u16-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s256">235</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u16-set! <em>bytevector</em> <em>n</em> <em>u16</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s257">236</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u32-native-ref <em>bytevector</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s254">232</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u32-native-set! <em>bytevector</em> <em>n</em> <em>u32</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s255">233</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u32-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s256">235</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u32-set! <em>bytevector</em> <em>n</em> <em>u32</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s257">236</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u64-native-ref <em>bytevector</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s254">232</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u64-native-set! <em>bytevector</em> <em>n</em> <em>u64</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s255">233</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u64-ref <em>bytevector</em> <em>n</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s256">235</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u64-set! <em>bytevector</em> <em>n</em> <em>u64</em> <em>eness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s257">236</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u8-ref <em>bytevector</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s248">230</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-u8-set! <em>bytevector</em> <em>n</em> <em>u8</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s250">231</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-uint-ref <em>bytevector</em> <em>n</em> <em>eness</em> <em>size</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s258">237</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector-uint-set! <em>bytevector</em> <em>n</em> <em>uint</em> <em>eness</em> <em>size</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s259">238</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector=? <em>bytevector<sub>1</sub></em> <em>bytevector<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s244">229</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(bytevector? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s24">155</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(caaaar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(caaadr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(caaar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(caadar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(caaddr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(caadr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(caar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cadaar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cadadr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cadar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(caddar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cadddr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(caddr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cadr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(call-with-bytevector-output-port <em>procedure</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s38">266</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(call-with-bytevector-output-port <em>procedure</em> <em>?transcoder</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s38">266</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(call-with-current-continuation <em>procedure</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s54">123</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(call-with-input-file <em>path</em> <em>procedure</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s77">281</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(call-with-output-file <em>path</em> <em>procedure</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s78">282</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(call-with-port <em>port</em> <em>procedure</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s51">272</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(call-with-string-output-port <em>procedure</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s39">267</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(call-with-values <em>producer</em> <em>consumer</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s71">131</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(call/cc <em>procedure</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s54">123</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(car <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s38">156</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(case <em>expr<sub>0</sub></em> <em>clause<sub>1</sub></em> <em>clause<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s18">113</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(case-lambda <em>clause</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s13">94</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cdaaar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cdaadr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cdaar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cdadar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cdaddr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cdadr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cdar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cddaar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cddadr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cddar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cdddar <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cddddr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cdddr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cddr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s42">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cdr <em>pair</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s39">156</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(ceiling <em>real</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s103">177</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-&gt;integer <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s210">215</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-alphabetic? <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s203">213</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-ci&lt;=? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s202">212</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-ci&lt;? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s202">212</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-ci=? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s202">212</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-ci&gt;=? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s202">212</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-ci&gt;? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s202">212</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-downcase <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s207">214</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-foldcase <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s209">215</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-general-category <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s205">214</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-lower-case? <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s204">213</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-numeric? <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s203">213</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-title-case? <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s204">213</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-titlecase <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s208">214</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-upcase <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s206">214</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-upper-case? <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s204">213</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char-whitespace? <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s203">213</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char&lt;=? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s201">212</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char&lt;? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s201">212</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char=? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s201">212</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char&gt;=? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s201">212</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char&gt;? <em>char<sub>1</sub></em> <em>char<sub>2</sub></em> <em>char<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s201">212</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(char? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s19">154</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(close-input-port <em>input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s88">285</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(close-output-port <em>output-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s88">285</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(close-port <em>port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s46">270</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(command-line)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#libraries:s17">350</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(complex? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s17">151</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cond <em>clause<sub>1</sub></em> <em>clause<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s13">111</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(condition <em>condition</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s15">362</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(condition-accessor <em>rtd</em> <em>procedure</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s18">365</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(condition-irritants <em>condition</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s25">368</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(condition-message <em>condition</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s24">368</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(condition-predicate <em>rtd</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s18">365</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(condition-who <em>condition</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s26">369</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(condition? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s14">362</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cons <em>obj<sub>1</sub></em> <em>obj<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s37">156</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cons* <em>obj</em> ... <em>final-obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s44">158</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><em>constant</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s1">141</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(cos <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s131">185</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(current-error-port)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s32">263</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(current-input-port)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s32">263</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(current-output-port)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s32">263</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(datum-&gt;syntax <em>template-identifier</em> <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s45">308</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(define <em>var</em> <em>expr</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s24">100</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(define <em>var</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s24">100</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(define (<em>var<sub>0</sub></em> <em>var<sub>1</sub></em> ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s24">100</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(define (<em>var<sub>0</sub></em> . <em>var<sub>r</sub></em>) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s24">100</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(define (<em>var<sub>0</sub></em> <em>var<sub>1</sub></em> <em>var<sub>2</sub></em> ... . <em>var<sub>r</sub></em>) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s24">100</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(define-condition-type <em>name</em> <em>parent</em> <em>constructor</em> <em>pred</em> <em>field</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s17">364</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(define-enumeration <em>name</em> (<em>symbol</em> ...) <em>constructor</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s290">250</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(define-record-type <em>record-name</em> <em>clause</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s13">328</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(define-record-type (<em>record-name</em> <em>constructor</em> <em>pred</em>) <em>clause</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s13">328</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(define-syntax <em>keyword</em> <em>expr</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s12">292</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(delay <em>expr</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s65">128</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(delete-file <em>path</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s90">286</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(denominator <em>rat</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s119">181</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(display <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s85">285</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(display <em>obj</em> <em>textual-output-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s85">285</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(div <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s99">175</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(div-and-mod <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s99">175</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(div0 <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s100">176</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(div0-and-mod0 <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s100">176</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(do ((<em>var</em> <em>init</em> <em>update</em>) ...) (<em>test</em> <em>result</em> ...) <em>expr</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s25">115</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(dynamic-wind <em>in</em> <em>body</em> <em>out</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s56">124</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>else</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s16">112</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(endianness <em>symbol</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s240">228</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(enum-set-&gt;list <em>enum-set</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s294">252</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(enum-set-complement <em>enum-set</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s299">254</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(enum-set-constructor <em>enum-set</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s292">251</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(enum-set-difference <em>enum-set<sub>1</sub></em> <em>enum-set<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s298">253</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(enum-set-indexer <em>enum-set</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s301">254</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(enum-set-intersection <em>enum-set<sub>1</sub></em> <em>enum-set<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s298">253</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(enum-set-member? <em>symbol</em> <em>enum-set</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s297">253</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(enum-set-projection <em>enum-set<sub>1</sub></em> <em>enum-set<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s300">254</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(enum-set-subset? <em>enum-set<sub>1</sub></em> <em>enum-set<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s295">252</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(enum-set-union <em>enum-set<sub>1</sub></em> <em>enum-set<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s298">253</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(enum-set-universe <em>enum-set</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s293">252</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(enum-set=? <em>enum-set<sub>1</sub></em> <em>enum-set<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s296">252</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(environment <em>import-spec</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s81">137</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(eof-object)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s54">273</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(eof-object? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s53">273</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(eol-style <em>symbol</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s23">259</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(eq? <em>obj<sub>1</sub></em> <em>obj<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s10">143</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(equal-hash <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s279">245</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(equal? <em>obj<sub>1</sub></em> <em>obj<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s13">148</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(eqv? <em>obj<sub>1</sub></em> <em>obj<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s12">146</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(error <em>who</em> <em>msg</em> <em>irritant</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s4">358</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(error-handling-mode <em>symbol</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s25">260</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(error? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s22">367</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(eval <em>obj</em> <em>environment</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s80">136</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(even? <em>int</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s96">174</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(exact <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s114">180</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(exact-&gt;inexact <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s116">181</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(exact-integer-sqrt <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s128">184</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(exact? <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s86">170</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(exists <em>procedure</em> <em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s36">119</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(exit)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#libraries:s18">350</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(exit <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#libraries:s18">350</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(exp <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s129">184</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(expt <em>num<sub>1</sub></em> <em>num<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s111">179</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fields</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s16">331</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(file-exists? <em>path</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s89">286</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(file-options <em>symbol</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s26">261</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(filter <em>procedure</em> <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s55">164</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(find <em>procedure</em> <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s57">165</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(finite? <em>real</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s97">174</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fixnum-&gt;flonum <em>fx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s198">211</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fixnum-width)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s152">193</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fixnum? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s150">193</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fl* <em>fl</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s186">207</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fl+ <em>fl</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s184">206</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fl- <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s185">206</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fl- <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s185">206</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fl/ <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s187">207</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fl/ <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s187">207</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fl&lt;=? <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s178">203</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fl&lt;? <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s178">203</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fl=? <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s178">203</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fl&gt;=? <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s178">203</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fl&gt;? <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> <em>fl<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s178">203</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flabs <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s192">209</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flacos <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s195">210</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flasin <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s195">210</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flatan <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s195">210</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flatan <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s195">210</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flceiling <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s190">208</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flcos <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s194">210</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fldenominator <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s191">209</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fldiv <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s188">207</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fldiv-and-mod <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s188">207</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fldiv0 <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s189">208</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fldiv0-and-mod0 <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s189">208</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fleven? <em>fl-int</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s182">205</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flexp <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s193">209</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flexpt <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s197">210</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flfinite? <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s181">205</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flfloor <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s190">208</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flinfinite? <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s181">205</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flinteger? <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s180">204</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fllog <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s193">209</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fllog <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s193">209</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flmax <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s183">205</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flmin <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s183">205</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flmod <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s188">207</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flmod0 <em>fl<sub>1</sub></em> <em>fl<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s189">208</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flnan? <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s181">205</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flnegative? <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s179">204</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flnumerator <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s191">209</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flodd? <em>fl-int</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s182">205</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flonum? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s177">203</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(floor <em>real</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s102">177</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flpositive? <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s179">204</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flround <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s190">208</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flsin <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s194">210</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flsqrt <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s196">210</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fltan <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s194">210</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fltruncate <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s190">208</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flush-output-port <em>output-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s74">280</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(flzero? <em>fl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s179">204</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fold-left <em>procedure</em> <em>obj</em> <em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s38">120</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fold-right <em>procedure</em> <em>obj</em> <em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s41">121</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(for-all <em>procedure</em> <em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s37">119</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(for-each <em>procedure</em> <em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s33">118</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(force <em>promise</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s65">128</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(free-identifier=? <em>identifier<sub>1</sub></em> <em>identifier<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s37">302</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fx* <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s159">195</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fx*/carry <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s162">197</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fx+ <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s157">195</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fx+/carry <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s162">197</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fx- <em>fx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s158">195</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fx- <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s158">195</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fx-/carry <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s162">197</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fx&lt;=? <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s153">193</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fx&lt;? <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s153">193</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fx=? <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s153">193</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fx&gt;=? <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s153">193</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fx&gt;? <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s153">193</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxand <em>fx</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s163">197</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxarithmetic-shift <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s173">201</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxarithmetic-shift-left <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s172">201</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxarithmetic-shift-right <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s172">201</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxbit-count <em>fx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s165">198</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxbit-field <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s170">200</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxbit-set? <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s168">199</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxcopy-bit <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s169">200</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxcopy-bit-field <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> <em>fx<sub>4</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s171">200</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxdiv <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s160">196</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxdiv-and-mod <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s160">196</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxdiv0 <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s161">196</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxdiv0-and-mod0 <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s161">196</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxeven? <em>fx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s155">194</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxfirst-bit-set <em>fx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s167">199</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxif <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s164">198</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxior <em>fx</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s163">197</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxlength <em>fx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s166">198</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxmax <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s156">195</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxmin <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s156">195</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxmod <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s160">196</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxmod0 <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s161">196</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxnegative? <em>fx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s154">194</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxnot <em>fx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s163">197</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxodd? <em>fx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s155">194</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxpositive? <em>fx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s154">194</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxreverse-bit-field <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s175">202</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxrotate-bit-field <em>fx<sub>1</sub></em> <em>fx<sub>2</sub></em> <em>fx<sub>3</sub></em> <em>fx<sub>4</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s174">201</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxxor <em>fx</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s163">197</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(fxzero? <em>fx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s154">194</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(gcd <em>int</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s109">179</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(generate-temporaries <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s49">310</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(get-bytevector-all <em>binary-input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s60">275</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(get-bytevector-n <em>binary-input-port</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s57">274</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(get-bytevector-n! <em>binary-input-port</em> <em>bytevector</em> <em>start</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s58">274</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(get-bytevector-some <em>binary-input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s59">275</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(get-char <em>textual-input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s61">275</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(get-datum <em>textual-input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s67">278</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(get-line <em>textual-input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s66">277</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(get-string-all <em>textual-input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s65">277</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(get-string-n <em>textual-input-port</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s63">276</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(get-string-n! <em>textual-input-port</em> <em>string</em> <em>start</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s64">276</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(get-u8 <em>binary-input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s55">274</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(greatest-fixnum)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s151">193</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(guard (<em>var</em> <em>clause<sub>1</sub></em> <em>clause<sub>2</sub></em> ...) <em>b1</em> <em>b2</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s8">361</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-clear! <em>hashtable</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s287">249</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-clear! <em>hashtable</em> <em>size</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s287">249</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-contains? <em>hashtable</em> <em>key</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s282">246</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-copy <em>hashtable</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s286">248</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-copy <em>hashtable</em> <em>mutable?</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s286">248</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-delete! <em>hashtable</em> <em>key</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s284">248</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-entries <em>hashtable</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s289">250</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-equivalence-function <em>hashtable</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s278">245</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-hash-function <em>hashtable</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s278">245</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-keys <em>hashtable</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s288">249</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-mutable? <em>hashtable</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s277">245</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-ref <em>hashtable</em> <em>key</em> <em>default</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s281">246</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-set! <em>hashtable</em> <em>key</em> <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s280">246</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-size <em>hashtable</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s285">248</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable-update! <em>hashtable</em> <em>key</em> <em>procedure</em> <em>default</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s283">247</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(hashtable? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s25">155</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-decoding-error? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s42">375</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-encoding-error-char <em>condition</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s43">376</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-encoding-error? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s43">376</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-error-filename <em>condition</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s36">373</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-error-port <em>condition</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s41">375</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-error-position <em>condition</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s35">372</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-error? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s32">371</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-file-already-exists-error? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s39">374</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-file-does-not-exist-error? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s40">374</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-file-is-read-only-error? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s38">374</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-file-protection-error? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s37">373</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-filename-error? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s36">373</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-invalid-position-error? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s35">372</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-port-error? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s41">375</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-read-error? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s33">372</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(i/o-write-error? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s34">372</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(identifier-syntax <em>tmpl</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s27">297</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(identifier-syntax (<em>id<sub>1</sub></em> <em>tmpl<sub>1</sub></em>) set! <em>id<sub>2</sub></em> <em>e<sub>2</sub></em>) <em>tmpl<sub>2</sub></em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s27">297</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(identifier? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s35">301</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(if <em>test</em> <em>consequent</em> <em>alternative</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s8">109</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(if <em>test</em> <em>consequent</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s8">109</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(imag-part <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s121">182</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>immutable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s16">331</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(implementation-restriction-violation? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s28">369</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(inexact <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s112">180</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(inexact-&gt;exact <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s116">181</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(inexact? <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s87">170</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(infinite? <em>real</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s97">174</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(input-port? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s44">270</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(integer-&gt;char <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s211">215</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(integer-valued? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s18">153</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(integer? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s17">151</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(irritants-condition? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s25">368</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(lambda <em>formals</em> <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s3">92</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(latin-1-codec)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s22">259</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(lcm <em>int</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s110">179</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(least-fixnum)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s151">193</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(length <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s46">159</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(let ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s16">95</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(let <em>name</em> ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s20">114</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(let* ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s18">96</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(let*-values ((<em>formals</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s23">99</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(let-syntax ((<em>keyword</em> <em>expr</em>) ...) <em>form<sub>1</sub></em> <em>form<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s13">293</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(let-values ((<em>formals</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s23">99</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(letrec ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s20">97</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(letrec* ((<em>var</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s22">98</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(letrec-syntax ((<em>keyword</em> <em>expr</em>) ...) <em>form<sub>1</sub></em> <em>form<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s13">293</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(lexical-violation? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s29">370</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(list <em>obj</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s43">158</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(list-&gt;string <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s229">223</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(list-&gt;vector <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s238">226</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(list-ref <em>list</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s47">159</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(list-sort <em>predicate</em> <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s62">167</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(list-tail <em>list</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s48">160</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(list? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s45">158</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(log <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s130">184</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(log <em>num<sub>1</sub></em> <em>num<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s130">184</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(lookahead-char <em>textual-input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s62">275</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(lookahead-u8 <em>binary-input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s56">274</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(magnitude <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s125">183</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-assertion-violation)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s21">366</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-bytevector <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s242">228</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-bytevector <em>n</em> <em>fill</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s242">228</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-custom-binary-input-port <em>id</em> <em>r!</em> <em>gp</em> <em>sp!</em> <em>close</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s41">267</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-custom-binary-input/output-port <em>id</em> <em>r!</em> <em>w!</em> <em>gp</em> <em>sp!</em> <em>close</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s41">267</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-custom-binary-output-port <em>id</em> <em>w!</em> <em>gp</em> <em>sp!</em> <em>close</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s41">267</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-custom-textual-input-port <em>id</em> <em>r!</em> <em>gp</em> <em>sp!</em> <em>close</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s42">268</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-custom-textual-input/output-port <em>id</em> <em>r!</em> <em>w!</em> <em>gp</em> <em>sp!</em> <em>close</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s42">268</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-custom-textual-output-port <em>id</em> <em>w!</em> <em>gp</em> <em>sp!</em> <em>close</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s42">268</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-enumeration <em>symbol-list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s291">251</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-eq-hashtable)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s274">243</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-eq-hashtable <em>size</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s274">243</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-eqv-hashtable)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s275">244</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-eqv-hashtable <em>size</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s275">244</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-error)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s22">367</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-hashtable <em>hash</em> <em>equiv?</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s276">244</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-hashtable <em>hash</em> <em>equiv?</em> <em>size</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s276">244</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-i/o-decoding-error <em>pobj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s42">375</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-i/o-encoding-error <em>pobj</em> <em>cobj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s43">376</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-i/o-error)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s32">371</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-i/o-file-already-exists-error <em>filename</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s39">374</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-i/o-file-does-not-exist-error <em>filename</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s40">374</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-i/o-file-is-read-only-error <em>filename</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s38">374</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-i/o-file-protection-error <em>filename</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s37">373</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-i/o-filename-error <em>filename</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s36">373</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-i/o-invalid-position-error <em>position</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s35">372</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-i/o-port-error <em>pobj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s41">375</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-i/o-read-error)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s33">372</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-i/o-write-error)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s34">372</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-implementation-restriction-violation)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s28">369</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-irritants-condition <em>irritants</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s25">368</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-lexical-violation)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s29">370</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-message-condition <em>message</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s24">368</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-no-infinities-violation)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s44">376</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-no-nans-violation)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s45">377</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-non-continuable-violation)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s27">369</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-polar <em>real<sub>1</sub></em> <em>real<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s123">183</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-record-constructor-descriptor <em>rtd</em> <em>parent-rcd</em> <em>protocol</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s24">332</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-record-type-descriptor <em>name</em> <em>parent</em> <em>uid</em> <em>s?</em> <em>o?</em> <em>fields</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s20">331</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-rectangular <em>real<sub>1</sub></em> <em>real<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s122">182</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-serious-condition)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s19">366</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-string <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s218">218</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-string <em>n</em> <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s218">218</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-syntax-violation <em>form</em> <em>subform</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s30">370</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-transcoder <em>codec</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s19">259</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-transcoder <em>codec</em> <em>eol-style</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s19">259</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-transcoder <em>codec</em> <em>eol-style</em> <em>error-handling-mode</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s19">259</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-undefined-violation)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s31">371</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-variable-transformer <em>procedure</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s42">306</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-vector <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s232">224</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-vector <em>n</em> <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s232">224</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-violation)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s20">366</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-warning)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s23">367</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(make-who-condition <em>who</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s26">369</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(map <em>procedure</em> <em>list<sub>1</sub></em> <em>list<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s30">117</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(max <em>real<sub>1</sub></em> <em>real<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s107">178</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(member <em>obj</em> <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s51">161</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(memp <em>procedure</em> <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s52">163</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(memq <em>obj</em> <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s51">161</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(memv <em>obj</em> <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s51">161</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(message-condition? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s24">368</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(min <em>real<sub>1</sub></em> <em>real<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s108">178</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(mod <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s99">175</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(mod0 <em>x<sub>1</sub></em> <em>x<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s100">176</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(modulo <em>int<sub>1</sub></em> <em>int<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s98">175</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>mutable</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s16">331</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(nan? <em>real</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s97">174</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(native-endianness)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s241">228</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(native-eol-style)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s24">260</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(native-transcoder)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s21">259</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(negative? <em>real</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s95">173</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(newline)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s87">285</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(newline <em>textual-output-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s87">285</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(no-infinities-violation? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s44">376</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(no-nans-violation? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s45">377</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(non-continuable-violation? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s27">369</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nongenerative</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s16">331</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(not <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s10">110</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(null-environment <em>version</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s82">137</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(null? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s15">151</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(number-&gt;string <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s148">191</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(number-&gt;string <em>num</em> <em>radix</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s148">191</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(number-&gt;string <em>num</em> <em>radix</em> <em>precision</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s148">191</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(number? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s17">151</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(numerator <em>rat</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s118">181</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(odd? <em>int</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s96">174</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>opaque</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s16">331</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-bytevector-input-port <em>bytevector</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s34">264</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-bytevector-input-port <em>bytevector</em> <em>?transcoder</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s34">264</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-bytevector-output-port)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s36">265</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-bytevector-output-port <em>?transcoder</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s36">265</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-file-input-port <em>path</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s29">262</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-file-input-port <em>path</em> <em>options</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s29">262</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-file-input-port <em>path</em> <em>options</em> <em>b-mode</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s29">262</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-file-input-port <em>path</em> <em>options</em> <em>b-mode</em> <em>?transcoder</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s29">262</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-file-input/output-port <em>path</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s31">263</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-file-input/output-port <em>path</em> <em>options</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s31">263</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-file-input/output-port <em>path</em> <em>options</em> <em>b-mode</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s31">263</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-file-input/output-port <em>path</em> <em>options</em> <em>b-mode</em> <em>?transcoder</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s31">263</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-file-output-port <em>path</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s30">262</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-file-output-port <em>path</em> <em>options</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s30">262</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-file-output-port <em>path</em> <em>options</em> <em>b-mode</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s30">262</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-file-output-port <em>path</em> <em>options</em> <em>b-mode</em> <em>?transcoder</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s30">262</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-input-file <em>path</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s75">280</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-output-file <em>path</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s76">281</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-string-input-port <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s35">265</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(open-string-output-port)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s37">266</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(or <em>expr</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s12">110</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(output-port-buffer-mode <em>port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s52">273</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(output-port? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s44">270</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(pair? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s16">151</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>parent</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s16">331</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>parent-rtd</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s16">331</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(partition <em>procedure</em> <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s56">164</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(peek-char)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s83">284</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(peek-char <em>textual-input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s83">284</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(port-eof? <em>input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s68">278</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(port-has-port-position? <em>port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s49">271</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(port-has-set-port-position!? <em>port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s50">272</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(port-position <em>port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s49">271</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(port-transcoder <em>port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s48">271</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(port? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s43">270</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(positive? <em>real</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s94">173</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(<em>expr<sub>0</sub></em> <em>expr<sub>1</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s1">107</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(procedure? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s23">155</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>protocol</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s16">331</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(put-bytevector <em>binary-output-port</em> <em>bytevector</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s70">279</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(put-bytevector <em>binary-output-port</em> <em>bytevector</em> <em>start</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s70">279</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(put-bytevector <em>binary-output-port</em> <em>bytevector</em> <em>start</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s70">279</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(put-char <em>textual-output-port</em> <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s71">279</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(put-datum <em>textual-output-port</em> <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s73">279</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(put-string <em>textual-output-port</em> <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s72">279</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(put-string <em>textual-output-port</em> <em>string</em> <em>start</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s72">279</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(put-string <em>textual-output-port</em> <em>string</em> <em>start</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s72">279</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(put-u8 <em>binary-output-port</em> <em>octet</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s69">278</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(quasiquote <em>obj</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s5">142</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(quasisyntax <em>template</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s40">305</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(quote <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s2">141</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(quotient <em>int<sub>1</sub></em> <em>int<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s98">175</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(raise <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s3">357</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(raise-continuable <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s3">357</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(rational-valued? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s18">153</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(rational? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s17">151</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(rationalize <em>real<sub>1</sub></em> <em>real<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s117">181</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(read)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s81">284</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(read <em>textual-input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s81">284</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(read-char)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s82">284</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(read-char <em>textual-input-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s82">284</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(real-&gt;flonum <em>real</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s198">211</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(real-part <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s120">182</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(real-valued? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s18">153</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(real? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s17">151</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-accessor <em>rtd</em> <em>idx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s31">334</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-constructor <em>rcd</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s29">333</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-constructor-descriptor <em>record-name</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s28">333</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-field-mutable? <em>rtd</em> <em>idx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s39">338</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-mutator <em>rtd</em> <em>idx</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s32">334</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-predicate <em>rtd</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s30">333</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-rtd <em>record</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s41">338</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-type-descriptor <em>record-name</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s28">333</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-type-descriptor? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s23">332</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-type-field-names <em>rtd</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s38">337</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-type-generative? <em>rtd</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s37">337</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-type-name <em>rtd</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s34">336</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-type-opaque? <em>rtd</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s37">337</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-type-parent <em>rtd</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s35">336</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-type-sealed? <em>rtd</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s37">337</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record-type-uid <em>rtd</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s36">336</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(record? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s40">338</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(remainder <em>int<sub>1</sub></em> <em>int<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s98">175</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(remove <em>obj</em> <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s53">163</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(remp <em>procedure</em> <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s54">163</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(remq <em>obj</em> <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s53">163</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(remv <em>obj</em> <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s53">163</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(reverse <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s50">161</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(round <em>real</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s104">178</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(scheme-report-environment <em>version</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s82">137</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sealed</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#records:s16">331</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(serious-condition? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s19">366</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(set! <em>var</em> <em>expr</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s28">102</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(set-car! <em>pair</em> <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s40">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(set-cdr! <em>pair</em> <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s41">157</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(set-port-position! <em>port</em> <em>pos</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s50">272</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(simple-conditions <em>condition</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s16">363</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(sin <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s131">185</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(sint-list-&gt;bytevector <em>list</em> <em>eness</em> <em>size</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s261">239</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(sqrt <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s127">183</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(standard-error-port)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s33">264</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(standard-input-port)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s33">264</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(standard-output-port)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s33">264</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string <em>char</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s217">218</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-&gt;bytevector <em>string</em> <em>transcoder</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s92">287</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-&gt;list <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s228">222</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-&gt;number <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s147">191</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-&gt;number <em>string</em> <em>radix</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s147">191</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-&gt;symbol <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s269">242</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-&gt;utf16 <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s94">287</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-&gt;utf16 <em>string</em> <em>endianness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s94">287</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-&gt;utf32 <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s94">287</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-&gt;utf32 <em>string</em> <em>endianness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s94">287</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-&gt;utf8 <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s93">287</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-append <em>string</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s223">219</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-ci-hash <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s279">245</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-ci&lt;=? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s216">217</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-ci&lt;? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s216">217</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-ci=? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s216">217</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-ci&gt;=? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s216">217</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-ci&gt;? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s216">217</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-copy <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s222">219</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-downcase <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s226">221</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-fill! <em>string</em> <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s225">220</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-foldcase <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s226">221</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-for-each <em>procedure</em> <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s50">122</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-hash <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s279">245</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-length <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s219">218</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-normalize-nfc <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s227">222</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-normalize-nfd <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s227">222</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-normalize-nfkc <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s227">222</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-normalize-nfkd <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s227">222</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-ref <em>string</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s220">218</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-set! <em>string</em> <em>n</em> <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s221">219</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-titlecase <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s226">221</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string-upcase <em>string</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s226">221</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string&lt;=? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s215">216</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string&lt;? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s215">216</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string=? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s215">216</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string&gt;=? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s215">216</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string&gt;? <em>string<sub>1</sub></em> <em>string<sub>2</sub></em> <em>string<sub>3</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s215">216</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(string? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s20">154</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(substring <em>string</em> <em>start</em> <em>end</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s224">220</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(symbol-&gt;string <em>symbol</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s270">242</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(symbol-hash <em>symbol</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s279">245</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(symbol=? <em>symbol<sub>1</sub></em> <em>symbol<sub>2</sub></em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s268">242</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(symbol? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s22">154</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(syntax <em>template</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s33">300</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(syntax-&gt;datum <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s44">308</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(syntax-case <em>expr</em> (<em>literal</em> ...) <em>clause</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s30">299</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(syntax-rules (<em>literal</em> ...) <em>clause</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s14">294</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(syntax-violation <em>who</em> <em>msg</em> <em>form</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s6">359</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(syntax-violation <em>who</em> <em>msg</em> <em>form</em> <em>subform</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s6">359</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(syntax-violation-form <em>condition</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s30">370</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(syntax-violation-subform <em>condition</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s30">370</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(syntax-violation? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s30">370</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(tan <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s131">185</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(textual-port? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s45">270</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(transcoded-port <em>binary-port</em> <em>transcoder</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s47">271</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(transcoder-codec <em>transcoder</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s20">259</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(transcoder-eol-style <em>transcoder</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s20">259</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(transcoder-error-handling-mode <em>transcoder</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s20">259</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(truncate <em>real</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s101">177</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(u8-list-&gt;bytevector <em>list</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s253">232</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(uint-list-&gt;bytevector <em>list</em> <em>eness</em> <em>size</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s261">239</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(undefined-violation? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s31">371</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(unless <em>test-expr</em> <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s17">112</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(unquote <em>obj</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s5">142</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(unquote-splicing <em>obj</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s5">142</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(unsyntax <em>template</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s40">305</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(unsyntax-splicing <em>template</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s40">305</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(utf-16-codec)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s22">259</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(utf-8-codec)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s22">259</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(utf16-&gt;string <em>bytevector</em> <em>endianness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s96">288</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(utf16-&gt;string <em>bytevector</em> <em>endianness</em> <em>endianness-mandatory?</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s96">288</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(utf32-&gt;string <em>bytevector</em> <em>endianness</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s96">288</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(utf32-&gt;string <em>bytevector</em> <em>endianness</em> <em>endianness-mandatory?</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s96">288</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(utf8-&gt;string <em>bytevector</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s95">287</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(values <em>obj</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s70">131</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><em>variable</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#binding:s2">91</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(vector <em>obj</em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s231">224</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(vector-&gt;list <em>vector</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s237">225</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(vector-fill! <em>vector</em> <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s236">225</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(vector-for-each <em>procedure</em> <em>vector<sub>1</sub></em> <em>vector<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s47">122</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(vector-length <em>vector</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s233">224</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(vector-map <em>procedure</em> <em>vector<sub>1</sub></em> <em>vector<sub>1</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s44">121</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(vector-ref <em>vector</em> <em>n</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s234">224</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(vector-set! <em>vector</em> <em>n</em> <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s235">225</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(vector-sort <em>predicate</em> <em>vector</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s239">226</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(vector-sort! <em>predicate</em> <em>vector</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s239">226</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(vector? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s21">154</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(violation? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s20">366</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(warning? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s23">367</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(when <em>test-expr</em> <em>expr<sub>1</sub></em> <em>expr<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#control:s17">112</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(who-condition? <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s26">369</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(with-exception-handler <em>procedure</em> <em>thunk</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#exceptions:s7">360</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(with-input-from-file <em>path</em> <em>thunk</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s79">283</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(with-output-to-file <em>path</em> <em>thunk</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s80">283</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(with-syntax ((<em>pattern</em> <em>expr</em>) ...) <em>body<sub>1</sub></em> <em>body<sub>2</sub></em> ...)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syntax</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#syntax:s38">304</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(write <em>obj</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s84">284</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(write <em>obj</em> <em>textual-output-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s84">284</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(write-char <em>char</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s86">285</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(write-char <em>char</em> <em>textual-output-port</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#io:s86">285</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(zero? <em>num</em>)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">procedure</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="#objects:s93">173</a></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="index">Index</h2>
<div class="sectionbody">
<div class="paragraph">
<p>All page numbers appearing here refer to the printed version of this book and also serve as hypertext links to the corresponding locations in the electronic version of this book.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_book_converting_tools">Appendix A: Book Converting Tools</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p><a href="https://asciidoctor.org/docs/user-manual/">Asciidoctor User Manual</a></p>
</li>
<li>
<p><a href="https://asciidoctor.org/docs/asciidoc-syntax-quick-reference/">AsciiDoc Syntax Quick Reference</a></p>
</li>
<li>
<p><a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJax basic tutorial and quick reference</a></p>
</li>
<li>
<p><a href="https://www.whatsmyip.org/html-characters/">HTML Entities &amp; Special Characters</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_format_javascript_and_replacement_regex_for_the_original_book">Appendix B: Format Javascript and Replacement Regex for The Original Book</h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>Format Javascript<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">// Format the content with AsciiDoc syntax
document.querySelectorAll('h3')
        .forEach(function(node) {
            var title=node.innerText;
            var anchor='section_'+title.replace(/^Section ([\d.]+) .+/, '$1');
            node.outerHTML = '=== ' + title + ' [['+anchor+']]';
        })
document.querySelectorAll('h4')
        .forEach(function(node) {
            var title=node.innerText;
            var anchor='exercise_'+title.replace(/^Exercise ([\d.]+)$/, '$1');
            node.outerHTML = '==== ' + title + ' [['+anchor+']]&lt;br&gt;&lt;br&gt;';
        })
document.querySelectorAll('[src="math/tspl/0.gif"]')
        .forEach(function(node) { node.outerHTML = '⇒' })
document.querySelectorAll('tt')
        .forEach(function(node) { node.innerHTML = '`'+node.innerHTML+'`' })
document.querySelectorAll('i')
        .forEach(function(node) { node.innerHTML = '_'+node.innerHTML+'_' })
document.querySelectorAll('li')
        .forEach(function(node) { node.innerHTML = '- '+node.innerHTML })
document.querySelectorAll('sub')
        .forEach(function(node) { node.outerHTML = '~'+node.innerText+'~' })
document.querySelectorAll('sup')
        .forEach(function(node) { node.outerHTML = '^'+node.innerText+'^' })
document.querySelectorAll('a')
        .forEach(function(node) {
            var name=node.name;
            if (name && name.match(/^\.\/(.+)$/)) {
                node.outerHTML='[#'+(name.replace(/^\.\/(.+)$/, '$1'))+']&lt;br&gt;';
            }
        })
document.querySelectorAll('a')
        .forEach(function(node) {
            var name=node.name;
            if (name && name.match(/^[^#.\/]+$/)) {
                node.outerHTML='[#'+name+']&lt;br&gt;';
            }
        })

// Highlight the code blocks and italic text
document.querySelectorAll('tt')
        .forEach(function(node) {
            node.style='font-size: 2em; border-bottom: 1px solid grey;'
        })
document.querySelectorAll('i')
        .forEach(function(node) {
            node.style='font-size: 2em; border-right: 1px solid red;'
        })</code></pre>
</div>
</div>
</li>
<li>
<p>Replacement Regex<br></p>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Regex</th>
<th class="tableblock halign-left valign-top">Replacement</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">^$\n\s*`\s*\(</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\n[source,scheme,subs=""]\n----\n(</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">\)`\n^$</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>)\n----\n</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\[(\d+)\]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;&lt;ref$1&gt;&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(^|\(|[^=] )Section ([\d\.]+\d)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$1&lt;&lt;section_$2.,Section $2&gt;&gt;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>(^|\(|[^=] )Exercise ([\d\.]+\d)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">$1&lt;&lt;exercise_$2,Exercise $2&gt;&gt;</p></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Check the lost links<br></p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="javascript" class="language-javascript hljs">var lostAnchors=[];
document.querySelector('#content')
        .querySelectorAll('a[href^="#"]')
        .forEach(function(node) {
            var anchor = node.getAttribute('href');

            if (!document.querySelector('[id="' + anchor.replace(/^#/, '') + '"]')) {
                lostAnchors.push(anchor);
            }
        });
console.log(lostAnchors.join('\n'));</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="../../theme/js/highlight/styles/github.min.css">
<script src="../../theme/js/highlight/highlight.min.js"></script>
<script src="../../theme/js/highlight/languages/scheme.min.js"></script>
<script src="../../theme/js/highlight/languages/bash.min.js"></script>
<script src="../../theme/js/highlight/languages/javascript.min.js"></script>
<script>hljs.initHighlighting()</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [["\\(", "\\)"]],
    displayMath: [["\\[", "\\]"]],
    ignoreClass: "nostem|nolatexmath"
  },
  asciimath2jax: {
    delimiters: [["\\$", "\\$"]],
    ignoreClass: "nostem|noasciimath"
  },
  TeX: { equationNumbers: { autoNumber: "none" } }
})
MathJax.Hub.Register.StartupHook("AsciiMath Jax Ready", function () {
  MathJax.InputJax.AsciiMath.postfilterHooks.Add(function (data, node) {
    if ((node = data.script.parentNode) && (node = node.parentNode) && node.classList.contains('stemblock')) {
      data.math.root.display = "block"
    }
    return data
  })
})
</script>
<script src="../../theme/js/mathjax/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
</body>
</html>